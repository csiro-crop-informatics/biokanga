// kanga.cpp : Defines the entry point for the console application.
//
// This process is manually renamed to be - 'kanga' or K-mer Adaptive Next Generation Aligner
//
// Purpose -
// Loads preprocessed reads generated by genreads and aligns these to an assembly after specified filtering into an output file
// for subsequent efficent pipeline processing
// 1.6.0	Public release of prebuilt binaries on code.google.com and sourceforge
// 1.6.1    Added option allowing user to specify that alignments are to be made to a specific strand
// 1.6.2	Generates alignment site potentials
//          Takes all octamers at start of aligned reads and generates the relative (to all other octamers) probability of that site being observed; intention is for this to be
//          in RNA-seq differential expression replicate normalisation
// 1.7.0	Multi-threaded qsorts implemented
// 1.8.1    Bug fix release for issue in colorspace with optimisation reusing prev hit results if identical sequences
// 1.8.4	Re-release of 1.8.3 with colorspace 1.8.1 bugfix actually applied!
// 1.8.5	SNP detection now uses local window in which to determine background expected sub rate instead of the whole chromosome
// 1.9.0    Processing for SAM paired end implemented
// 1.9.1    Fix for single ended SAM output and quality scores scaled to fit within 4bits
// 1.9.3    Fix for possibility that splice junction length specified may actually be longer than the targeted genome assembly length
// 1.9.5    SNP basespace calling was not incrementing the base mms correctly - SNP was still called but usually A was only mm counted
// 1.9.6    SNP basespace calling was not correctly handling antisense aligned reads
// 1.9.7    added optional SNP centroid processing and reporting
// 1.9.8    changed '-k' processing to specify PCR differential amplification artefact reduction window length
// 1.9.9    PCR differential amplification artefact reduction algorithmic changes
// 1.9.10   PCR differential amplification artefact reduction algorithmic changes
// 1.9.11   ensured that all output file close() are preceded by fsync() unless closed as a result of errors
// 1.9.12   simple typo error when reporting strand processing setting - was referencing both watson and crick strand as being the '+'!!
//          alloc memory in larger chunks as small chunks seem to adversely impact on Windows allocations ( observed speedup of 2x on w2k8 HPC 64 core machine)
// 1.9.13   Allows comment lines in parameter files
// 1.9.14   Reporting of putative uniquely aligned and multialigned read counts
// Release 1.10.0	Restructured build directories to reflect application name
// Release 1.10.1	Increased number of raw reads parsed before notifying alignment threads that more reads are avail for alignment
// Release 1.10.2	Can handle tsRawReadV6 kangar preprocessed reads
// Release 1.10.3   Fix for unitialised start site octamer preferencing file name
// Release 1.10.4   Increased PCR artfact max window from 50 to 250 and changed maximum read thresholds within the artifact window
// Release 1.10.5   Only process for alignment site probs if explicitly asked to do so
// Release 1.10.6   micoInDel processing bug (occasionally reporting InDel length 0) fix
// Release 1.11.0   public binary release
// Release 1.11.1   allow multihit reporting in SAM format
// Release 1.11.1   default alignment hits changed to be SAM format
// Release 1.11.2   Bug fix for SAM microInDel reporting (InDels correctly detected but reported SAM CIGAR string was truncated)
// Release 1.11.3   Bug fix for SAM multialignment reporting
// Release 1.11.4   Added option whereby multialigned reads exceeding the user specified limit are treated as though they were at the limit
// Release 1.11.5   Windows 64bit release had an issue with treating a unsigned 32 bit index as a signed 32 bit index
// Release 1.12.0   Public release
// Release 1.12.1   Bug fix - '-X' option may result in additional SAM alignment with either 0M or 256M reported for each read exceeding allowed limit
// Release 1.12.2   changed _MAX_PATH to 260 to maintain compatibility with windows
// Release 1.12.3   added option whereby user can specify a experiment name which is reported in the log file for subsequent log parser processing
// Release 1.12.4   fix for 3'end trimming bug (was using the 5'end trim)
// Release 1.12.5   allowed multiple 3' PE2 files to be specified, previously would only accept a single 3' PE2 file
// Release 1.12.6   report number of reads not aligned because they contained an excess of indeterminate bases
// Release 1.12.7   max allowed indeterminate bases is as percentage of read length if length > 100
// Release 1.12.8   soft trim was reporting swapped left and right number of bases (<N>S) in SAM output format for reads aligning antisense to target sequence
// Release 1.12.9	allocating larger chunks of memory when parsing fasta reads input files 
// Release 2.0.0	handles alignments to assemblies which can be greater than 4Gb, for instance wheat
//                  allows for prioritorisation of exactly matching hits to specified regions - enables RNA-seq alignments to be better normalised
// Release 2.0.1    first of many bugfixes - if no BED file specified then was still attempting to prioritorise regions
// Release 2.0.2    option to only report alignments to the prioritorised regions
// Release 2.0.3    set chrom identifier to be 0 if read alignment filtered out from non-prioritorised regions
// Release 2.0.4    changed substitution distribution reporting to exclude subs in auto-trimming of flanks
// Release 2.0.5    changed handling for EINTR within SafeWrite
//                  allowed aligner induced substitutions to be reported in M0..M5
// Release 2.0.7	Extended paired end processing
// Release 2.0.8	Allowed SNP read coverage to be specified down to 2 reads, assumes that the reads were filtered for any errors!
//                  Default SNP read coverage is now 5, was previously 10
// Release 2.0.9    Correctly report first 10 under length reads which are being sloughed
// Release 2.1.0    Public release
// Release 2.1.1    Fix for float point exception when accepting multialigned reads as limited with '-X' and randomly selecting which alignment to report  
// Release 2.1.2    Individual chromosomes can now be just less than 4GB in size  

#include "stdafx.h"

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if _WIN32
#include <process.h>
#include "../libbiokanga/commhdrs.h"
#else
#include <sys/mman.h>
#include <pthread.h>
#include "../libbiokanga/commhdrs.h"
#endif

#include "kanga.h"

const char *cpszProgVer = "2.1.2";		// increment with each release


// processing modes
typedef enum TAG_ePMode {
	ePMdefault,					// default processing mode
	ePMMoreSens,				// more sensitive - slower
	ePMUltraSens,				// ultra sensitive - much slower
	ePMLessSens,				// less sensitive - quicker
	ePMplaceholder				// used to set the enumeration range
	} etPMode;

// multiloci read handling modes
typedef enum TAG_eMLMode {
	eMLdefault,					// default is to simply slough those reads which match to multiple loci
	eMLdist,					// acumulate distribution stats only
	eMLrand,					// randomly select one of the aligned loci
	eMLuniq,					// cluster multiply aligned reads with those reads which are uniquely aligned
	eMLcluster,					// cluster multiply aligned reads with both uniquely (high priority) aligned and then with other multiloci alignments
	eMLall,						// report all multihit loci
	eMLplaceholder				// used to set the enumeration range
} etMLMode;

// output format modes
typedef enum TAG_eFMode {
	eFMdefault,					// default is for CSV match loci only
	eFMmatch,					// CSV loci + match sequence
	eFMread,					// CSV loci + read sequence
	eFMreadmatch,				// CSV loci + read + match sequence
	eFMbed,						// UCSC BED format
	eFMsam,						// SAM toolset format
	eFMsamAll,					// SAM toolset format, includes all reads even if not accepted as aligned
	eFMplaceholder				// used to set the enumeration range
	} etFMode;

// paired reads alignment processing mode
typedef enum TAG_ePEproc {
	ePEdefault = 0,				// default is not to process for paired ends, single end alignment only
	ePEorphan,					// process for paired ends and if one end is orphaned because multiple aligned then try to locate unique alignment downstream
	ePEunique,					// process for paired ends but only accept putative if both ends uniquely aligned
	ePEplaceholder				// used to set the enumeration range
} etPEproc;

typedef enum TAG_eQFiltType {
	eQFnone,					// no filtering by quality scores
	eQFabs,						// filter by absolute quality scores
	eQFrel,						// filter by relative quality scores
	eQFplaceholder				// used to set the enumeration range
	} etQFiltType;

typedef enum TAG_eReadsSortMode {
		eRSMReadID,				// index by ascending ReadID
		eRSMPairReadID,			// index by ascending PairReadID
		eRSMPEHitMatch,			// index by ascending hit count, chrom, PairReadID
		eRSMHitMatch,			// index by ascending hit count,chrom, loci, strand, level
		eRSMSeq,				// index by ascending sequence then ReadID
		eRSMplaceholder			// used to limit the enumeration range
} etReadsSortMode;


#pragma pack(4)
typedef struct TAG_sThreadMatchPars {
	int ThreadIdx;				// index of this thread (1..m_NumThreads)
	int NumIdentNodes;			// number of ident nodes allocd for use by this thread
	tsIdentNode *pIdentNodes;	// thread to use these nodes

#ifdef _WIN32
	HANDLE threadHandle;			// handle as returned by _beginthreadex()
	unsigned int threadID;			// identifier as set by _beginthreadex()
#else
	int threadRslt;					// result as returned by pthread_create ()
	pthread_t threadID;				// identifier as set by pthread_create ()
#endif
	int CurBlockID;					// current suffix block identifier
	int ChromID;					// hit chrom identifier
    int NumAllowedSubs;				// number of allowed substitutions
	int MaxNumSlides;				// limit on number of times core window can be moved or slide to right over read
    etQFiltType FiltQuality;		// filtering type
	bool bQAbove;					// if true then filter out those below or equal to FiltThres
	int FiltThres;					// filter threshold
	eALStrand AlignStrand;		// align on to watson, crick or both strands of target
	int microInDelLen;				// microInDel length maximum
	int SpliceJunctLen;				// maximum splice junction length when aligning RNAseq reads
	int Rslt;						// returned result code
	int MinEditDist;				// any matches must have at least this Hamming edit distance to the next best match
	int MaxSubs;					// maximum number of substitutions allowed, if -1 then 1/10th of actual read length
	int PlusHits;					// returned number of hits on to plus strand
	int MinusHits;					// returned number of hits on to minus strand
	int NumReadsProc;				// returned number of reads processed by this thread instance
	int OutBuffIdx;					// index at which to write next formated hit into szOutBuff
	UINT8 *pszOutBuff;				// used to buffer multiple hit formated output records prior to writing to disk
	tsHitLoci *pMultiHits;			// allocated to hold read multihit loci
} tsThreadMatchPars;

typedef struct TAG_sClusterThreadPars {
	int ThreadIdx;						// uniquely identifies this thread
	#ifdef _WIN32
	HANDLE threadHandle;			// handle as returned by _beginthreadex()
	unsigned int threadID;			// identifier as set by _beginthreadex()
#else
	int threadRslt;					// result as returned by pthread_create ()
	pthread_t threadID;				// identifier as set by pthread_create ()
#endif
	int Rslt;						// returned result code
} tsClusterThreadPars;

typedef struct TAG_sReadsHitBlock {
	int NumReads;			// number of reads for processing in this block
	int MaxReads;			// block can hold at most this number of reads
	tsReadHit *pReadHits[cMaxReadsPerBlock]; // reads for processing
} tsReadsHitBlock;
#pragma pack()

#pragma pack(1)
typedef struct TAG_sSNPcnts {
	etSeqBase RefBase;	// reference base
	UINT32 NumRefBases;		// counts of reference base in reads covering this loci
	UINT32 NumNonRefBases;	// total count of non-reference bases in reads covering this loci
	UINT16 NonRefBaseCnts[5]; // counts of non-reference bases a,c,g,t,n covering this loci; clamped to be no more than 0x0ffff
	} tsSNPcnts;

typedef struct TAG_sChromSNPs {
	UINT32 ChromID;		// uniquely identifies this chromosome
	UINT32 ChromLen;	// this chromosome length
	UINT32 AllocChromLen; // cnts can be for a chromosome of at most this length
	INT64 TotMatch;	// total number of aligned read bases which exactly matched corresponding chrom sequence bases
	INT64 TotMismatch;	// total number of aligned read bases which mismatched corresponding chrom sequence base
	tsSNPcnts Cnts[1]; // will be allocated to hold base cnts at each loci in this chromosome
	} tsChromSNPs;

typedef struct TAG_sSegJuncts {
	tsReadHit *pRead;	// read containing this RNA-seq splice or microInDel junction
	UINT32 Cnt;			// number of reads sharing this splice junction or microInDel junction
	UINT32 ChromID;		// junction is on this chrom
	UINT32 Starts;		// junction starts
	UINT32 Ends;		// junction ends
	} tsSegJuncts;


typedef struct TAG_sLociPValues {
	UINT32 Loci;		// putative SNP at this loci
	double PValue;      // having this PValue
	UINT32 Rank;		// and this ordered rank
	double LocalBkGndSubRate; // local background substitution rate
	UINT32 LocalReads;  // total number of aligned bases within the local background
	UINT32 LocalSubs;	// total number local aligner induced substitutions within the local background
	tsSNPcnts SNPcnts;	// counts of each base a,c,g,t,n at this loci
	UINT32 NumReads;	// number of reads aligned at this loci
	UINT32 NumSubs;		// number of aligner induced substitutions at this loci
} tsLociPValues;

typedef struct TAG_sSNPCentroid {
	UINT32 CentroidID;		// uniquely identifies this centroid sequence
	UINT32 NumInsts;		// number of instances of this centroid sequence (qualified by having at least min number of reads covering)
	int NumSNPs;			// number of SNPs identified centroid to this sequence
	UINT32 RefBaseCnt;		// counts of reference bases covering SNP
	UINT32 NonRefBaseCnts[5]; // counts of each non-reference bases covering SNP
} tsSNPCentroid;


#pragma pack()


CMTqsort mtqsort;		// muti-threaded qsort

#ifdef _WIN32
HANDLE m_hMtxIterReads;
HANDLE m_hMtxMHReads;
HANDLE m_hMtxMultiMatches;
SRWLOCK m_hRwLock;
HANDLE m_hThreadLoadReads;
unsigned __stdcall AssignMultiMatchesThread(void * pThreadPars);
unsigned __stdcall ThreadedCoredApprox(void * pThreadPars);
unsigned __stdcall LoadReadFilesThread(void * pThreadPars);
#else
pthread_mutex_t m_hMtxIterReads;
pthread_mutex_t m_hMtxMHReads;
pthread_mutex_t m_hMtxMultiMatches;
pthread_rwlock_t m_hRwLock;
void *AssignMultiMatchesThread(void * pThreadPars);
void *ThreadedCoredApprox(void * pThreadPars);
void *LoadReadFilesThread(void * pThreadPars);
#endif

void ResetThreadedIterReads(void);
bool ThreadedIterReads(tsReadsHitBlock *pRetBlock);		// returns false if no more reads availing for processing by calling thread


int
Process(etPMode PMode,					// processing mode
		etFQMethod Quality,				// quality scoring for fastq sequence files
		bool bSOLiD,					// if true then processing in colorspace
		bool bBisulfite,				// if true then process for bisulfite methylation patterning
		etPEproc PEproc,				// paired reads alignment processing mode
		int PairMinLen,					// accept paired end alignments with apparent length of at least this (default = 100)
		int PairMaxLen,					// accept paired end alignments with apparent length of at most this (default = 300)
		eALStrand AlignStrand,			// align on to watson, crick or both strands of target
		int microInDelLen,				// microInDel length maximum
		int SpliceJunctLen,				// maximum splice junction length when aligning RNAseq reads
		int MinSNPreads,				// must be at least this number of reads covering any loci before processing for SNPs at this loci
		double QValue,					// QValue controlling FDR (Benjamini–Hochberg) SNP prediction
		int PCRartefactWinLen,			// if >= 0 then window size to use when attempting to reduce the number of  PCR differential amplification artefacts (reads stacking to same loci)
		etMLMode MLMode,				// multimatch loci reads processing mode
		int MaxMLmatches,				// accept at most this number of multimatched alignments for any read
		bool bClampMaxMLmatches,		// accept as if MaxMLmatches even if more than this number of MaxMLmatches multimached alignments
		int MaxNs,					    // allow at most this number of indeterminate eBaseNs in read before deeming as nonalignable
		int MinEditDist,				// any matches must have at least this edit distance to the next best match
		int MaxSubs,					// maximum number of substitutions allowed, or if -1 then 1/10th of actual read length
		int Trim5,						// trim this number of bases from 5' end of reads when loading the reads
		int Trim3,						// trim this number of bases from 3' end of reads when loading the reads
		int MinFlankExacts,				// trim matched reads on 5' and 3' flanks until at least this number of exactly matching bases in flanks
		etFMode FMode,					// output format mode
		int SitePrefsOfs,				// offset read start sites when processing  octamer preferencing, range -100..100
		int NumThreads,					// number of worker threads to use
		char *pszTrackTitle,			// track title if output format is UCSC BED
		int NumPE1InputFiles,			// number of input PE1 or single ended file specs
		char *pszPE1InputFiles[],		// names of input files (wildcards allowed unless processing paired ends) containing raw reads
		int NumPE2InputFiles,			// number of input PE2 file specs
		char *pszPE2InputFiles[],		// optional raw paired reads are in these files
		char *pszPriorityRegionFile,	// optional exact match priority BED file contains prioritised region loci
		bool bFiltPriorityRegions,		// true if non-priority alignments to be filtered out 
		char *pszOutFile,				// where to write alignments
		char *pszSNPFile,				// Output SNPs (CSV format) to this file (default is to output file name with '.snp' appended)
		char *pszSNPCentroidFile,		// Output SNP centorids (CSV format) to this file (default is for no centroid processing)
		char *pszSfxFile,				// target as suffix array
		char *pszStatsFile,				// aligner induced substitutions stats file
		char *pszMultiAlignFile,		// file to contain reads which are aligned to multiple locations
		char *pszNoneAlignFile,			// file to contain reads which were non-alignable
		char *pszSitePrefsFile,			// file to contain aligned reads octamer preferencing
		char *pszHammFile,				// Hamming edit distance file
		int	NumIncludeChroms,			// number of chromosome regular expressions to include
		char **ppszIncludeChroms,		// array of include chromosome regular expressions
		int	NumExcludeChroms,			// number of chromosome expressions to exclude
		char **ppszExcludeChroms);		// array of exclude chromosome regular expressions

int AssignMultiMatches(void);			// assign one of the hit loci to those reads with multimatch hits

int WriteSubDist(tsReadHit *pReadHit);	// generate aligner induced substitution counts

int LoadReads(char *pszRdsFile);			// load preprocessed reads (genreads output)

int LocateCoredApprox(int MinEditDist,				// any matches must have at least this edit distance to the next best match
		int MaxSubs);					// maximum number of substitutions allowed

tsReadHit *LocateRead(UINT32 ReadID);			// locate read identified by ReadID

tsReadHit *IterReads(tsReadHit *pCurReadHit);	// iterate over unsorted reads
tsReadHit *IterSortedReads(tsReadHit *pCurReadHit);			// iterate over unsorted reads

int SortReadHits(etReadsSortMode SortMode,				// index read hits according to specified SortMode
						bool bSeqSorted);			// used to optimise eRSMSeq processing, if it is known that reads are already sorted in sequence order (loaded from pre-processed .rds file)


UINT32 ApproxNumReadsAligned(UINT32 *pNumAligned,UINT32 *pNumLoaded);					// gets an approximation of the number of reads thus far aligned



int ProcessSiteProbabilites(int RelSiteStartOfs);  // offset site octamer by this relative start offset ( < 0 for 5' upstream, > 0 for 3' downstream)
int WriteSitePrefs(void);

int ConstructSortedSeqIdx(bool bForRDS);		// true if reads sequence index being constructed for pre-processed .rds reads, false if for raw reads loaded from multifasta

int											// returned number of unique reads
NumUpUniques(tsReadHit *pCurReadHit,		// current read
				int WinLen,					// only interested in unique reads starting within this window
				bool bStrandDep);			// if true then unique loci reads must be on current read stand

int											// returned number of unique reads
NumDnUniques(tsReadHit *pCurReadHit,		// current read
				int WinLen,					// only interested in unique reads starting within this window
				bool bStrandDep);			// if true then unique loci reads must be on current read stand

int
AddMHitReads(UINT32 NumHits,	// number of multimatches loci in pHits
		tsReadHit *pHits);		// pts to array of hit loci

int ProcessSNPs(void);

int CreateMutexes(void);
void DeleteMutexes(void);

void AcquireLock(bool bExclusive);	// acquire shared read or exclusive write lock on certain global vars (mainly used to sync reads loader thread and alignment threads)
void ReleaseLock(bool bExclusive);  // release lock

void AcquireSerialise(void);
void ReleaseSerialise(void);
void AcquireSerialiseMH(void);
void ReleaseSerialiseMH(void);

int
AppendStr(char *pszBuff,	// write to this buffer
		  char LeadSep,		// if != '\0' then prefix with this separator (usually ',' or '\t')
		  char Quote,		// if != '\0' then quote string with this char (usually single or double quote char)
		  char *pStr,		// '\0' terminated string
		  char TrailSep);	// if != '\0' then suffix with this separator (usually ',' or '\t' or '\n')

int
AppendChrs(char *pszBuff,	// write to this buffer
		  char LeadSep,		// if != '\0' then prefix with this separator (usually ',' or '\t')
		  char Quote,		// if != '\0' then quote chars with this char (usually single or double quote char)
		  int NumChrs,		// number of chars to append
		  char *Chrs,		// pts to chars to append
		  char TrailSep);	// if != '\0' then suffix with this separator (usually ',' or '\t' or '\n')

int							// length written
AppendUInt(char *pszBuff,	// write to this buffer
		  char LeadSep,		// if > '\0' then prefix with this separator (usually ',' or '\t')
		  UINT32 Value,
		  char TrailSep);	// if > '\0' then suffix with this separator (usually ',' or '\t' or '\n')

// ReplaceTabs
// Inplace replacement of any tabs with a single space char
char *ReplaceTabs(char *pszTabTxt);

static int SortReadIDs(const void *arg1, const void *arg2);
static int SortPairReadIDs(const void *arg1, const void *arg2);
static int SortPEHitMatch(const void *arg1, const void *arg2);
static int SortHitMatch(const void *arg1, const void *arg2);
static int SortMultiHits(const void *arg1, const void *arg2);
static int SortMultiHitReadIDs(const void *arg1, const void *arg2);
static int SortSegJuncts(const void *arg1, const void *arg2);
static int SortReadSeqs(const void *arg1, const void *arg2);
static int SortLociPValues(const void *arg1, const void *arg2);
static int SortPValuesLoci(const void *arg1, const void *arg2);
static int SortSiteRelScale(const void *arg1, const void *arg2);
static int SortSiteRelOctamer(const void *arg1, const void *arg2);

extern CStopWatch gStopWatch;
extern CDiagnostics gDiagnostics;				// for writing diagnostics messages to log file
extern char gszProcName[_MAX_FNAME];			// process name

// SOLiDmap
// Used for mapping from base to colorspace and the reverse
static UINT8 SOLiDmap[5][5] = {
	{0,1,2,3,4},	// a
	{1,0,3,2,4},	// c
	{2,3,0,1,4},    // g
	{3,2,1,0,4},    // t
	{0,1,2,3,4}};	// n

typedef struct TAG_sOctSitePrefs {
	int Octamer;	// identifies this octamer (0 == bases:aaaaaaaa, 1 == bases:aaaaaaac, 0xFFFF == tttttttt)
	int NumSites;	// number of unique loci at which at least 1 read starting with this octamer aligned
	int NumOccs;   // total number of reads aligning to assembly with this start octamer
	double RelScale; // relative normalisation scaling factor to use
	} tsOctSitePrefs;

const int cNumOctamers = 0x010000;			// number of different octamers (4^8)
tsOctSitePrefs m_OctSitePrefs[2][cNumOctamers];	// to contain all 64k possible octamers for each aligned to strand

CStopWatch gStopWatch;
CDiagnostics gDiagnostics;				// for writing diagnostics messages to log file
char gszProcName[_MAX_FNAME];			// process name

#ifdef _WIN32
// required by str library
#if !defined(__AFX_H__)  ||  defined(STR_NO_WINSTUFF)
HANDLE STR_get_stringres()
{
	return NULL;	//Works for EXEs; in a DLL, return the instance handle
}
#endif

const STRCHAR* STR_get_debugname()
{
	return _T("kanga");
}
// end of str library required code
#endif


#ifdef _WIN32
int _tmain(int argc, char* argv[])
{
// determine my process name
_splitpath(argv[0],NULL,NULL,gszProcName,NULL);
#else
int
main(int argc, const char** argv)
{
// determine my process name
CUtility::splitpath((char *)argv[0],NULL,gszProcName);
#endif
int iFileLogLevel;			// level of file diagnostics
int iScreenLogLevel;		// level of file diagnostics
char szLogFile[_MAX_PATH];	// write diagnostics to this file
int Rslt = 0;   			// function result code >= 0 represents success, < 0 on failure
int Idx;
int LenChromList;

etPMode PMode;				// processing mode
bool bSOLiD;				// if true then process for colorspace (SOLiD)
bool bBisulfite;			// if true then process for bisulfite methylation patterning
int PCRartefactWinLen;		// if >= 0 then window size to use when attempting to reduce the number of  PCR differential amplification artefacts (reads stacking to same loci)
etFMode FMode;				// format output mode

int NumberOfProcessors;		// number of installed CPUs
int NumThreads;				// number of threads (0 defaults to number of CPUs)
etFQMethod Quality;			// quality scoring for fastq sequence files
int MinEditDist;			// any matches must have at least this edit distance to the next best match
int MaxSubs;				// maximum number of substitutions allowed
etMLMode MLMode;			// processing mode for multiple loci aligned reads
int MaxMLmatches;			// accept at most this number of multimached alignments for any read
bool bClampMaxMLmatches;	// accept as if MaxMLmatches even if more than this number of MaxMLmatches multimached alignments
int MaxNs;				    // allow at most this number of indeterminate eBaseNs in read before deeming as nonalignable
int MinFlankExacts;			// trim matched reads on 5' and 3' flanks until at least this number of exactly matching bases in flanks
int Trim5;					// trim this number of bases from 5' end of reads when loading the reads
int Trim3;					// trim this number of bases from 3' end of reads when loading the reads
eALStrand AlignStrand;	// align on to watson, crick or both strands of target
int microInDelLen;			// microInDel length maximum
int SpliceJunctLen;			// maximum splice junction length when aligning RNAseq reads
int MinSNPreads;			// must be at least this number of reads covering any loci before processing for SNPs at this loci
double QValue;			    // used in Benjamini–Hochberg for SNP prediction


char szTrackTitle[cMaxDatasetSpeciesChrom];		// track title if output format is UCSC BED
char szExperiment[cMaxDatasetSpeciesChrom];     // allow user to specify a name by which this alignment processing instance is to be referenced as in the log file

char szRsltsFile[_MAX_PATH];			// results to this file
char szTargFile[_MAX_PATH];				// align against this target suffix array genome file

int NumPE1InputFiles;					// number of input PE1 or single ended file spe
char *pszPE1InputFiles[cMaxInFileSpecs];		// names of input files (wildcards allowed unless processing paired ends) containing raw reads
int NumPE2InputFiles;					// number of input PE2 file specs
char *pszPE2InputFiles[cMaxInFileSpecs];		// optional raw paired reads are in these files

etPEproc PEproc;						// paired end processing mode
int PairMinLen;							// accept paired end alignments with apparent length of at least this (default = 100)
int PairMaxLen;							// accept paired end alignments with apparent length of at most this (default = 300)

char szPriorityRegionFile[_MAX_PATH];	// optional exact match priority file contains prioritised region loci as a BED file
bool bFiltPriorityRegions;				// if priority regions requested then can also request that only alignments into these regions be reported

char szSNPFile[_MAX_PATH];				// Output SNPs (CSV format) to this file (default is to output file name with '.snp' appended)
char szSNPCentroidFile[_MAX_PATH];		// Output SNP centorids (CSV format) to this file (default is for no centroid processing)

char szHammFile[_MAX_PATH];				// optional Hammings from this file
char szStatsFile[_MAX_PATH];			// optional output basic distribution counts/stats to this file
char szMultiAlignFile[_MAX_PATH];		// optional output file to contain reads which are aligned to multiple locations
char szNoneAlignFile[_MAX_PATH];		// optional output file to contain reads which could not be aligned
char szSitePrefsFile[_MAX_PATH];		// optional output file to contain aligned reads start site octamer preferencing
int SitePrefsOfs;						// offset read start sites when processing  octamer preferencing, range -100..100

int NumIncludeChroms;
char *pszIncludeChroms[cMaxIncludeChroms];
int NumExcludeChroms;
char *pszExcludeChroms[cMaxExcludeChroms];

// command line args
// Note that following 'B' 'c', 'G','g','K','N','S','V','w','W' are currently unallocated!
struct arg_lit  *help    = arg_lit0("h","help",                 "print this help and exit");
struct arg_lit  *version = arg_lit0("v","version,ver",			"print version information and exit");
struct arg_int *FileLogLevel=arg_int0("f", "FileLogLevel",		"<int>","Level of diagnostics written to screen and logfile 0=fatal,1=errors,2=info,3=diagnostics,4=debug");
struct arg_file *LogFile = arg_file0("F","log","<file>",		"diagnostics log file");

struct arg_int *pmode = arg_int0("m","mode","<int>",		    "alignment processing mode: 0 - standard sensitivity, 1 - more sensitive (slower), 2 - ultra sensitive (slowest), 3 - less sensitive (quicker)");
struct arg_int *format = arg_int0("M","format","<int>",		    "output format: 0 - CSV loci only, 1 - CSV loci + match sequence, 2 - CSV loci + read sequence, 3 - CSV loci + read + match sequence, 4 - UCSC BED, 5 - SAM format with accepted aligned, 6 - SAM format with all reads (default: 5)");
struct arg_int *peproc = arg_int0("U","pemode","<int>",		    "paired end processing mode: 0 - none, 1 - paired end with recover orphan ends, 2 - paired end no orphan recovery (default: 0)");

struct arg_lit  *bisulfite = arg_lit0("b","bisulfite",          "process for bisulfite methylation patterning");
struct arg_lit  *solid = arg_lit0("C","colorspace",             "process for colorspace (SOLiD)");
struct arg_int  *pcrartefactwinlen = arg_int0("k","pcrwin", "<int>",   "PCR differential amplification artefact reduction window length (default is for no artefact reduction, 0..250)");
struct arg_file *pe1inputfiles = arg_filen("i","in","<file>",0,cMaxInFileSpecs,"input from these raw sequencer read files, wildcards allowed if single ended");
struct arg_file *pe2inputfiles = arg_filen("u","pair","<file>",0,cMaxInFileSpecs,"if raw paired end processing then input read pairs from these raw paired end files");

struct arg_file *priorityregionfile = arg_file0("B","priorityregionfile","<file>",	"prioritise exact match alignments to loci regions in this BED file");
struct arg_lit  *nofiltpriority = arg_lit0("V","nofiltpriority",          "do not filter priority region alignments");

struct arg_int  *pairminlen = arg_int0("d","pairminlen","<int>", "accept paired end alignments with apparent length of at least this (default = 100)");
struct arg_int  *pairmaxlen = arg_int0("D","pairmaxlen","<int>", "accept paired end alignments with apparent length of at most this (default = 300)");

struct arg_int  *alignstrand = arg_int0("Q","alignstrand","<int>", "align to this strand: 0 either, 1 Watson '+', 2 Crick '-' (default is to align to either strand)");

struct arg_int *qual = arg_int0("q","quality","<int>",		    "fastq quality scoring - 0 - Sanger, 1 = Illumina 1.3+, 2 = Solexa < 1.3, 3 = Ignore quality (default = 3)");
struct arg_file *sfxfile = arg_file1("I","sfx","<file>",		"align against this suffix array (kangax generated) file");
struct arg_file *outfile = arg_file1("o","out","<file>",		"output alignments to this file");

struct arg_int  *microindellen = arg_int0("a","microindellen","<int>", "accept microInDels inclusive of this length: 0 to 20 (default = 0 or no microIndels)");
struct arg_int  *splicejunctlen = arg_int0("A","splicejunctlen","<int>", "aligning RNA-seq, force flank trim, accept splice junctions separated by at most this distance: 25 to 100000 (default = 0 for DNA non-spliced aligning)");

struct arg_file *statsfile = arg_file0("O","stats","<file>",	"output aligner induced substitution distribution stats (not supported for '-M6' output mode) or paired end length distributions to this file");
struct arg_file *nonealignfile = arg_file0("j","nonealign","<file>",	"output unalignable reads to this file (requires '-M3' output mode specified)");
struct arg_file *multialignfile = arg_file0("J","multialign","<file>",	"output multialigned reads to this file (requires '-M3' output mode specified)");

struct arg_file *siteprefsfile = arg_file0("L","siteprefs","<file>", "output aligned reads start site octamer preferencing to this file");
struct arg_int *siteprefsofs = arg_int0("l","siteprefsofs","<int>", "offset read start sites when processing site octamer preferencing, range -100..100 (default is -4)");

struct arg_file *hammfile = arg_file0("H","hamming","<file>",	"Optional pre-generated Hamming edit distance file for targeted genome");

struct arg_file *snpfile = arg_file0("S","snpfile","<file>",	"Output SNPs (CSV format) to this file (default is to output file name with '.snp' appended)");
struct arg_file *centroidfile = arg_file0("c","snpcentroid","<file>", "Output SNP centroid distributions (CSV format) to this file (default is for no centroid processing)");

struct arg_int *mineditdist = arg_int0("e","editdelta","<int>",	"accepted matches must be at least this Hamming edit distance from the next best match (default is 1, max 2)");
struct arg_int *maxsubs = arg_int0("s","substitutions","<int>",	"accept up to this number of aligner induced substitutions in alignments (default is auto at 1/10th of individual read lengths, max is 15)");
struct arg_int *minflankexacts = arg_int0("x","minflankexacts","<int>",	"trim matching reads on 5' and 3' flanks until at least this number of exactly matching bases in flanks (default is 0 or no trimming)");

struct arg_int *maxns = arg_int0("n","maxns","<int>",	        "maximum number, percentage if read length > 100, of indeterminate 'N's in reads before treating read as unalignable (default is 1, max 5)");

struct arg_str  *title = arg_str0("t","title","<string>",       "track title");

struct arg_str  *experiment = arg_str0("E","experiment","<string>", "specify experiment name by which this alignment processing instance can be subsequently identified in the log");

struct arg_str  *ExcludeChroms = arg_strn("Z","chromexclude",	"<string>",0,cMaxExcludeChroms,"high priority - regular expressions defining chromosomes to exclude");
struct arg_str  *IncludeChroms = arg_strn("z","chromeinclude",	"<string>",0,cMaxIncludeChroms,"low priority - regular expressions defining chromosomes to include");
struct arg_int *threads = arg_int0("T","threads","<int>",		"number of processing threads 0..n (defaults to 0 which sets threads to number of CPU cores, max 64)");

struct arg_int *maxmlmatches = arg_int0("R","maxmulti","<int>",	"allow any read to match at most this many genome loci then process according to mlmode (default is 5)");
struct arg_lit *clampmaxmulti = arg_lit0("X","clampmaxmulti",	    "treat reads mapping to more than limit set with '-R<n>' as if exactly <n> matches (default is not to further process reads exceeding limit set with '-R<n>')");

struct arg_int *mlmode = arg_int0("r","mlmode","<int>",			"processing mode for reads mapped to multiple loci: 0 slough, 1 stats only, 2 rand, 3 cluster with uniques only, 4 cluster with uniques + other multi, 5 report all match loci up to '-R<limit>' (default is 0)");
struct arg_int *minsnpreads = arg_int0("p","snpreadsmin","<int>","minimum read coverage at loci before processing for SNP determination (default is 0 or no SNP processing)");
struct arg_dbl *qvalue = arg_dbl0("P","qvalue","<dbl>",		"QValue controlling FDR (Benjamini-Hochberg) SNP prediction (default is 0.05, range is <= 0.20)");
struct arg_int *trim5 = arg_int0("y","trim5","<int>",		"trim this number of bases from 5' end of reads when loading raw reads (default is 0)");
struct arg_int *trim3 = arg_int0("Y","trim3","<int>",		"trim this number of bases from 3' end of reads when loading raw reads (default is 0)");

struct arg_end *end = arg_end(50);

void *argtable[] = {help,version,FileLogLevel,LogFile,experiment,
					pmode,alignstrand,microindellen,splicejunctlen,solid,pcrartefactwinlen,qual,mlmode,trim5,trim3,maxmlmatches,clampmaxmulti,bisulfite,
					mineditdist,maxsubs,maxns,minflankexacts,minsnpreads,qvalue,format,title,priorityregionfile,nofiltpriority,
					pe1inputfiles,peproc,pairminlen,pairmaxlen,pe2inputfiles,sfxfile,snpfile,centroidfile,
					outfile,nonealignfile,multialignfile,statsfile,siteprefsfile,siteprefsofs,hammfile,ExcludeChroms,IncludeChroms,threads,
					end};

char **pAllArgs;
int argerrors;
argerrors = CUtility::arg_parsefromfile(argc,(char **)argv,&pAllArgs);
if(argerrors >= 0)
	argerrors = arg_parse(argerrors,pAllArgs,argtable);

/* special case: '--help' takes precedence over error reporting */
if (help->count > 0)
        {
		printf("\n%s the K-mer Adaptive Next Generation Aligner, Version %s\nOptions ---\n", gszProcName,cpszProgVer);
        arg_print_syntax(stdout,argtable,"\n");
        arg_print_glossary(stdout,argtable,"  %-25s %s\n");
		printf("\nNote: Parameters can be entered into a parameter file, one parameter per line.");
		printf("\n      To invoke this parameter file then precede it's name with '@'");
		printf("\n      e.g. %s @myparams.txt\n",gszProcName);
		printf("\nPlease report any issues regarding usage of %s to stuart.stephen@csiro.au\n\n",gszProcName);
		exit(1);
        }

    /* special case: '--version' takes precedence error reporting */
if (version->count > 0)
        {
		printf("\n%s Version %s\n",gszProcName,cpszProgVer);
		exit(1);
        }

if (!argerrors)
	{
	if(FileLogLevel->count && !LogFile->count)
		{
		printf("\nError: FileLogLevel '-f%d' specified but no logfile '-F<logfile>\n'",FileLogLevel->ival[0]);
		exit(1);
		}

	iScreenLogLevel = iFileLogLevel = FileLogLevel->count ? FileLogLevel->ival[0] : eDLInfo;
	if(iFileLogLevel < eDLNone || iFileLogLevel > eDLDebug)
		{
		printf("\nError: FileLogLevel '-l%d' specified outside of range %d..%d\n",iFileLogLevel,eDLNone,eDLDebug);
		exit(1);
		}

	if(LogFile->count)
		{
		strncpy(szLogFile,LogFile->filename[0],_MAX_PATH);
		szLogFile[_MAX_PATH-1] = '\0';
		}
	else
		{
		iFileLogLevel = eDLNone;
		szLogFile[0] = '\0';
		}

	// now that log parameters have been parsed then initialise diagnostics log system
	if(!gDiagnostics.Open(szLogFile,(etDiagLevel)iScreenLogLevel,(etDiagLevel)iFileLogLevel,true))
		{
		printf("\nError: Unable to start diagnostics subsystem\n");
		if(szLogFile[0] != '\0')
			printf(" Most likely cause is that logfile '%s' can't be opened/created\n",szLogFile);
		exit(1);
		}

	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Version: %s",cpszProgVer);

	// ensure all filenames are initialised as none user specified
	szRsltsFile[0] = '\0';
	szTargFile[0] = '\0';
	NumPE1InputFiles = 0;
	NumPE2InputFiles = 0;
	szSNPFile[0] = '\0';
	szSNPCentroidFile[0] = '\0';

	szHammFile[0] = '\0';
	szStatsFile[0] = '\0';
	szMultiAlignFile[0] = '\0';
	szNoneAlignFile[0] = '\0';
	szSitePrefsFile[0] = '\0';

	bSOLiD = solid->count ? true : false;

	PMode = (etPMode)(pmode->count ? pmode->ival[0] : ePMdefault);
	if(PMode < ePMdefault || PMode >= ePMplaceholder)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Processing mode '-m%d' specified outside of range %d..%d\n",PMode,ePMdefault,(int)ePMplaceholder-1);
		exit(1);
		}

	AlignStrand = (eALStrand)(alignstrand->count ? alignstrand->ival[0] : eALSboth);
	if(AlignStrand < eALSboth || AlignStrand >= eALSnone)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Aligned to strand '-Q%d' specified outside of range %d..%d\n",AlignStrand,eALSboth,(int)eALSnone-1);
		exit(1);
		}


	Quality = (etFQMethod)(qual->count ? qual->ival[0] : eFQIgnore);
	if(Quality < eFQSanger || Quality >= eFQplaceholder)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: fastq quality '-q%d' specified outside of range %d..%d\n",Quality,eFQSanger,(int)eFQplaceholder-1);
		exit(1);
		}


	MLMode = (etMLMode)(mlmode->count ? mlmode->ival[0] : 0);
	FMode = (etFMode)(format->count ? format->ival[0] : eFMsam);
	if(FMode < eFMdefault || FMode >= eFMplaceholder)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Output format mode '-m%d' specified outside of range %d..%d\n",FMode,eFMdefault,(int)eFMplaceholder-1);
		exit(1);
		}

	MinFlankExacts = minflankexacts->count ? minflankexacts->ival[0] : 0;
	SpliceJunctLen = splicejunctlen->count ? splicejunctlen->ival[0] : 0;
	microInDelLen = microindellen->count ? microindellen->ival[0] : 0;
	bBisulfite = bisulfite->count ? true : false;
	PEproc = (etPEproc)(peproc->count ? peproc->ival[0] : 0);

	if(PEproc > ePEdefault)			// only a limited subset of processing options/parameters avail if paired end processing
		{
		if(!(FMode == eFMdefault || FMode == eFMbed || FMode >= eFMsam))
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Sorry, currently output format '-M%d' not supported with paired end '-U%d' processing\n",MLMode,PEproc);
			exit(1);
			}

		if(bBisulfite)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Sorry, currently bisulfite processing '-b' not supported in paired end '-U%d' processing\n",PEproc);
			exit(1);
			}
		if(MLMode != eMLdefault)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Sorry, currently multiloci processing '-r%d' not supported in paired end '-U%d' processing\n",MLMode,PEproc);
			exit(1);
			}

		if(microInDelLen != 0)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Sorry, currently microInDel processing '-a%d' not supported in paired end '-U%d' processing\n",microInDelLen,PEproc);
			exit(1);
			}

		if(SpliceJunctLen != 0)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Sorry, currently RNA-seq splice junction processing '-A%d' not supported in paired end '-U%d' processing\n",SpliceJunctLen,PEproc);
			exit(1);
			}
		}

	if(statsfile->count)
		{
		if(PEproc == ePEdefault && FMode == eFMsamAll)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Output induced substitution mode '-O<file>' not available in '-M6' output mode\n");
			exit(1);
			}
		strncpy(szStatsFile,statsfile->filename[0],_MAX_PATH);
		szStatsFile[_MAX_PATH-1] = '\0';
		}

	for(NumPE1InputFiles=Idx=0;NumPE1InputFiles < cMaxInFileSpecs && Idx < pe1inputfiles->count; Idx++)
		{
		pszPE1InputFiles[Idx] = NULL;
		if(pszPE1InputFiles[NumPE1InputFiles] == NULL)
			pszPE1InputFiles[NumPE1InputFiles] = new char [_MAX_PATH];
		strncpy(pszPE1InputFiles[NumPE1InputFiles],pe1inputfiles->filename[Idx],_MAX_PATH);
		pszPE1InputFiles[NumPE1InputFiles][_MAX_PATH-1] = '\0';
		CUtility::TrimQuotedWhitespcExtd(pszPE1InputFiles[NumPE1InputFiles]);
		if(pszPE1InputFiles[NumPE1InputFiles][0] != '\0')
			NumPE1InputFiles++;
		}

	if(!NumPE1InputFiles)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: After removal of whitespace, no input file(s) specified with '-i<filespec>' option)\n");
		exit(1);
		}

	if(PEproc != ePEdefault)
		{
		for(NumPE2InputFiles=Idx=0;NumPE2InputFiles < cMaxInFileSpecs && Idx < pe2inputfiles->count; Idx++)
			{
			pszPE2InputFiles[Idx] = NULL;
			if(pszPE2InputFiles[NumPE2InputFiles] == NULL)
				pszPE2InputFiles[NumPE2InputFiles] = new char [_MAX_PATH];
			strncpy(pszPE2InputFiles[NumPE2InputFiles],pe2inputfiles->filename[Idx],_MAX_PATH);
			pszPE2InputFiles[NumPE2InputFiles][_MAX_PATH-1] = '\0';
			CUtility::TrimQuotedWhitespcExtd(pszPE2InputFiles[NumPE2InputFiles]);
			if(pszPE2InputFiles[NumPE2InputFiles][0] != '\0')
				NumPE2InputFiles++;
			}

		if(!NumPE2InputFiles)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: After removal of whitespace, no input file(s) specified with '-u<filespec>' option)\n");
			exit(1);
			}

		if(NumPE1InputFiles != NumPE2InputFiles)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Number (%d) of PE1 files must match number of PE2 (%d) files\n",NumPE1InputFiles,NumPE2InputFiles);
			exit(1);
			}


		PairMinLen = pairminlen->count ? pairminlen->ival[0] : cDfltPairMinLen;
		if(PairMinLen < cPairMinLen || PairMinLen > cPairMaxLen)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: paired end apparent min length '-d%d' must be in range %d..%d\n",PairMinLen,cPairMinLen,cPairMaxLen);
			exit(1);
			}
		PairMaxLen = pairmaxlen->count ? pairmaxlen->ival[0] : max(cDfltPairMaxLen,PairMinLen);
		if(PairMaxLen < PairMinLen || PairMaxLen > cPairMaxLen)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: paired end apparent max length '-D%d' must be in range %d..%d\n",PairMaxLen,PairMinLen,cPairMaxLen);
			exit(1);
			}
		}
	else
		{
		pszPE2InputFiles[0] = NULL;
		PairMinLen = 0;
		PairMaxLen = 0;
		}

	if(MLMode < eMLdefault || MLMode >= eMLplaceholder)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: multiple aligned reads processing mode '-r%d' specified outside of range 0..%d\n",MLMode,eMLplaceholder-1);
		exit(1);
		}

	if(MLMode != eMLdefault)
		{
		MaxMLmatches = maxmlmatches->count ? maxmlmatches->ival[0] : cDfltMaxMultiHits;
		if(MLMode != eMLall)
			{
			if(MaxMLmatches < 2 || MaxMLmatches > cMaxMultiHits)
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: multiple aligned reads '-R%d' specified outside of range 2..%d\n",MaxMLmatches,cMaxMultiHits);
				exit(1);
				}
			}
		else
			{
			if(MaxMLmatches < 2 || MaxMLmatches > cMaxAllHits)
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: multiple aligned reads '-R%d' specified outside of range 2..%d\n",MaxMLmatches,cMaxAllHits);
				exit(1);
				}
			gDiagnostics.DiagOut(eDLWarn,gszProcName,"Warning: in report all multimatch mode '-R5', there is no splice or SNP processing..\n");
			}
		}
	else
		MaxMLmatches = 1;

	if(MaxMLmatches > 1)
		bClampMaxMLmatches = clampmaxmulti->count ? true : false;
	else
		bClampMaxMLmatches = false;

	microInDelLen = microindellen->count ? microindellen->ival[0] : 0;
	if(microInDelLen < 0 || microInDelLen > cMaxMicroInDelLen)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: microInDel length maximum '-a%d' specified outside of range 0..%d\n",microInDelLen,cMaxMicroInDelLen);
		exit(1);
		}

	if(MLMode != eMLall)
		{
		PCRartefactWinLen = pcrartefactwinlen->count ? pcrartefactwinlen->ival[0] : -1;
		if(PCRartefactWinLen != -1 && (PCRartefactWinLen < 0 || PCRartefactWinLen > 250))
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: PCR differential amplification artefacts window length '-k%d' specified outside of range 0..%d\n",PCRartefactWinLen,250);
			exit(1);
			}


		SpliceJunctLen = splicejunctlen->count ? splicejunctlen->ival[0] : 0;
		if(SpliceJunctLen != 0 && (SpliceJunctLen < cMinJunctAlignSep || SpliceJunctLen > cMaxJunctAlignSep))
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: RNAseq maximum splice junction separation '-A%d' must be either 0 or in the range %d..%d\n",SpliceJunctLen,cMinJunctAlignSep,cMaxJunctAlignSep);
			exit(1);
			}
		}
	else
		{
		PCRartefactWinLen = -1;
		SpliceJunctLen = 0;
		}

	Trim5 = trim5->count ? trim5->ival[0] : 0;
	if(Trim5 < 0 || Trim5 > 50)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Trim 5' raw reads '-y%d' specified outside of range %d..%d\n",Trim5,0,50);
		exit(1);
		}
	Trim3 = trim3->count ? trim3->ival[0] : 0;
	if(Trim3 < 0 || Trim3 > 50)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Trim 3' raw reads '-y%d' specified outside of range %d..%d\n",Trim3,0,50);
		exit(1);
		}

	MinEditDist = mineditdist->count ? mineditdist->ival[0] : 1;
	if(MinEditDist < 1 || MinEditDist > 2)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Minimum edit distance '-e%d' specified outside of range %d..%d\n",MinEditDist,1,2);
		exit(1);
		}

	if(maxsubs->count)
		{
		MaxSubs = maxsubs->ival[0];
		if(MaxSubs < 0 || MaxSubs > cMaxAllowedSubs)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Max allowed substitutions '-s%d' specified outside of range %d..%d\n",MaxSubs,0,cMaxAllowedSubs);
			exit(1);
			}
		}
	else
		MaxSubs = -1;	// auto-determine as 10% of actual read length

	MaxNs = maxns->count ? maxns->ival[0] : cDfltMaxNs;
	if(MaxNs < 0 || MaxNs > cMaxNs)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Allowed number, percentage if read length > 100, of indeterminate bases in reads '-n%d' specified outside of range 0..%d\n",MaxNs,cMaxNs);
		exit(1);
		}

	if(MLMode != eMLall)
		{
		MinFlankExacts = minflankexacts->count ? minflankexacts->ival[0] : 0;
		if(MinFlankExacts < 0 || MinFlankExacts > cMaxAllowedSubs/2)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Max flank trimming '-x%d' specified outside of range 0..%d\n",MinFlankExacts,cMaxAllowedSubs/2);
			exit(1);
			}
		}
	else
		MinFlankExacts = 0;

	if(SpliceJunctLen > 0 && MinFlankExacts == 0)
		MinFlankExacts = MaxSubs;

#ifdef _WIN32
	SYSTEM_INFO SystemInfo;
	GetSystemInfo(&SystemInfo);
	NumberOfProcessors = SystemInfo.dwNumberOfProcessors;
#else
	NumberOfProcessors = sysconf(_SC_NPROCESSORS_CONF);
#endif
	int MaxAllowedThreads = min(cMaxWorkerThreads,NumberOfProcessors);	// limit to be at most cMaxWorkerThreads
	if((NumThreads = threads->count ? threads->ival[0] : MaxAllowedThreads)==0)
		NumThreads = MaxAllowedThreads;
	if(NumThreads < 0 || NumThreads > MaxAllowedThreads)
		{
		gDiagnostics.DiagOut(eDLWarn,gszProcName,"Warning: Number of threads '-T%d' specified was outside of range %d..%d",NumThreads,1,MaxAllowedThreads);
		gDiagnostics.DiagOut(eDLWarn,gszProcName,"Warning: Defaulting number of threads to %d",MaxAllowedThreads);
		NumThreads = MaxAllowedThreads;
		}

	if(MLMode == eMLall && !(FMode == eFMdefault || FMode == eFMbed || FMode == eFMsam || FMode == eFMsamAll))
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Output format mode '-M%d' not supported when reporting all multihit read loci\n",FMode);
		exit(1);
		}

	if(bSOLiD && (FMode == eFMread || FMode == eFMreadmatch))
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Output format '-M%d' currently not supported in '-C' colorspace (SOLiD) Processing mode\n",FMode);
		exit(1);
		}

	strcpy(szTargFile,sfxfile->filename[0]);
	strcpy(szRsltsFile,outfile->filename[0]);

	if(MLMode != eMLall)
		{
		MinSNPreads = minsnpreads->count ? minsnpreads->ival[0] : 0;
		if(MinSNPreads != 0 && (MinSNPreads < cMinSNPreads || MinSNPreads > cMaxSNPreads))
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Minimum read coverage at any loci '-p%d' must be in range %d..%d\n",MinSNPreads,cMinSNPreads,cMaxSNPreads);
			exit(1);
			}
		QValue = qvalue->count ? qvalue->dval[0] : 0.0;
		if(QValue < 0.0 || QValue > 0.20)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: QValue '-P%1.5f' for controlling SNP FDR (Benjamini-Hochberg) must be in range 0.0 to 0.2\n",QValue);
			exit(1);
			}
		if(QValue > 0.0 && MinSNPreads == 0)
			MinSNPreads = cDfltMinSNPreads;
		else
			if(QValue == 0.0 && MinSNPreads != 0)
				QValue = cDfltQValueSNP;

		if(MinSNPreads > 0 && (FMode > eFMsam || bBisulfite == true))
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Sorry, SNP processing not currently supported if processing bisulfite reads\n");
			exit(1);
			}

		if(snpfile->count)
			{
			strncpy(szSNPFile,snpfile->filename[0],_MAX_PATH);
			szSNPFile[_MAX_PATH-1] = '\0';
			}
		else
			{
			strcpy(szSNPFile,szRsltsFile);
			strcat(szSNPFile,".snp");
			}

		if(centroidfile->count)
			{
			strncpy(szSNPCentroidFile,centroidfile->filename[0],_MAX_PATH);
			szSNPCentroidFile[_MAX_PATH-1] = '\0';
			}
		else
			szSNPCentroidFile[0] = '\0';
		}
	else
		{
		MinSNPreads = 0;
		QValue = 0.0;
		szSNPFile[0] = '\0';
		szSNPCentroidFile[0] = '\0';
		}

	if(experiment->count)
		{
		strncpy(szExperiment,experiment->sval[0],sizeof(szExperiment));
		szExperiment[sizeof(szExperiment)-1] = '\0';
		CUtility::TrimQuotedWhitespcExtd(szExperiment);
		CUtility::ReduceWhitespace(szExperiment);
		}
	else
		szExperiment[0] = '\0';

	szTrackTitle[0] = '\0';

	if(FMode == eFMbed)
		{
		if(title->count)
			{
			strncpy(szTrackTitle,title->sval[0],sizeof(szTrackTitle));
			szTrackTitle[sizeof(szTrackTitle)-1] = '\0';
			CUtility::TrimQuotedWhitespcExtd(szTrackTitle);
			CUtility::ReduceWhitespace(szTrackTitle);
			}
		if(szTrackTitle[0] == '\0')
			{
			gDiagnostics.DiagOut(eDLWarn,gszProcName,"Warning: output format requested to be UCSC BED but no track title with '-t<title' specified, defaulting to 'kanga'\n");
			strcpy(szTrackTitle,"kanga");
			}
		}

	if(MLMode != eMLall)
		{
		NumIncludeChroms = IncludeChroms->count;
		for(Idx=0;Idx < IncludeChroms->count; Idx++)
			{
			LenChromList = (int)strlen(IncludeChroms->sval[Idx]);
			pszIncludeChroms[Idx] = new char [LenChromList+1];
			strcpy(pszIncludeChroms[Idx],IncludeChroms->sval[Idx]);
			CUtility::TrimQuotes(pszIncludeChroms[Idx]);
			}

		NumExcludeChroms = ExcludeChroms->count;
		for(Idx=0;Idx < ExcludeChroms->count; Idx++)
			{
			LenChromList = (int)strlen(ExcludeChroms->sval[Idx]);
			pszExcludeChroms[Idx] = new char [LenChromList+1];
			strcpy(pszExcludeChroms[Idx],ExcludeChroms->sval[Idx]);
			CUtility::TrimQuotes(pszExcludeChroms[Idx]);
			}
		}
	else
		{
		NumIncludeChroms = 0;
		NumExcludeChroms = 0;
		}

	if(MLMode != eMLall)
		{
		if(hammfile->count)
			{
			strncpy(szHammFile,hammfile->filename[0],_MAX_PATH);
			szHammFile[_MAX_PATH-1] = '\0';
			}
		else
			szHammFile[0] = '\0';

		if(statsfile->count)
			{
			if(FMode == eFMsamAll)
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: Output induced substitution mode '-O<file>' not available in '-M6' output mode\n");
				exit(1);
				}
			strncpy(szStatsFile,statsfile->filename[0],_MAX_PATH);
			szStatsFile[_MAX_PATH-1] = '\0';
			}
		else
			szStatsFile[0] = '\0';
	
		SitePrefsOfs = siteprefsofs->count ? siteprefsofs->ival[0] : cDfltRelSiteStartOfs;
		if(abs(SitePrefsOfs) > cMaxSitePrefOfs)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Error: offset read start sites '-l%d' when processing site octamer preferencing must be in range -100..100\n",SitePrefsOfs);
			exit(1);
			}

		if(siteprefsfile->count)
			{
			strncpy(szSitePrefsFile,siteprefsfile->filename[0],_MAX_PATH);
			szSitePrefsFile[_MAX_PATH-1] = '\0';
			}
		else
			szSitePrefsFile[0] = '\0';

		if(nonealignfile->count)
			{
			strncpy(szNoneAlignFile,nonealignfile->filename[0],_MAX_PATH);
			szNoneAlignFile[_MAX_PATH-1] = '\0';
			}
		else
			szNoneAlignFile[0] = '\0';

		if(multialignfile->count)
			{
			strncpy(szMultiAlignFile,multialignfile->filename[0],_MAX_PATH);
			szMultiAlignFile[_MAX_PATH-1] = '\0';
			}
		else
			szMultiAlignFile[0] = '\0';
		}
	else
		{
		szHammFile[0] = '\0';
		szSitePrefsFile[0] = '\0';
		szNoneAlignFile[0] = '\0';
		szMultiAlignFile[0] = '\0';
		SitePrefsOfs = cDfltRelSiteStartOfs;
		}

	if(priorityregionfile->count)
		{
		strncpy(szPriorityRegionFile,priorityregionfile->filename[0],_MAX_PATH);
		szPriorityRegionFile[_MAX_PATH-1] = '\0';
		bFiltPriorityRegions = nofiltpriority->count ? false : true;
		}
	else
		{
		szPriorityRegionFile[0] = '\0';
		bFiltPriorityRegions = false;
		}

	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Processing parameters:");

	const char *pszDescr;
	switch(PMode) {
		case ePMdefault:
			pszDescr = "Standard alignment sensitivity";
			break;
		case ePMMoreSens:
			pszDescr = "More sensitive alignment (slower)";
			break;
		case ePMUltraSens:
			pszDescr = "Ultra sensitive alignment (very slow)";
			break;
		case ePMLessSens:
		default:
			pszDescr = "Less sensitive alignment (quicker)";
			break;
		}
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Processing mode is : '%s'",pszDescr);
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Processing in %s mode",bSOLiD ? "colorspace (SOLiD)" : "standard basespace");

	if(bBisulfite)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Processing for: %s",bBisulfite ? "bisulfite methylation patterning" : "standard");

	switch(AlignStrand) {
		case eALSboth:
			pszDescr = "either Watson '+' and Crick '-' strands";
			break;
		case eALSWatson:
			pszDescr = "Watson '+' strand only";
			break;
		case eALSCrick:
			pszDescr = "Crick '-' strand only";
			break;
		}

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"alignments are to : %s",pszDescr);

	if(PCRartefactWinLen >= 0)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Use this window length when reducing PCR differential amplification artefacts : %d",PCRartefactWinLen);
	else
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"No PCR differential amplification artefact reduction");
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"trim 5' ends raw reads by : %d",Trim5);
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"trim 3' ends raw reads by : %d",Trim3);

	if(MaxSubs >=0)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"maximum aligner induced substitutions : %d",MaxSubs);
	else
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"maximum aligner induced substitutions : 1/10th of actual read length");
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"minimum Hamming edit distance : %d",MinEditDist);

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"maximum number, precentage of length if read length > 100, of indeterminate 'N's : %d",MaxNs);
	if(MinFlankExacts >= 0)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"minimum 5' and 3' flank exacts : %d",MinFlankExacts);
	else
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"minimum 5' and 3' flank exacts :  1/10th of actual read length");

	switch(FMode) {
		case eFMdefault:
			pszDescr = "CSV match loci only";
			break;
		case eFMmatch:
			pszDescr = "CSV loci + match sequence";
			break;
		case eFMread:
			pszDescr = "CSV loci + read sequence";
			break;
		case eFMreadmatch:
			pszDescr = "CSV loci + read + match sequence";
			break;
		case eFMbed:
			pszDescr = "UCSC BED";
			break;
		case eFMsam:
			pszDescr = "SAM Toolset Format, accepted aligned reads only";
			break;
		case eFMsamAll:
			pszDescr = "SAM toolset format, includes all reads";
			break;
		}

	const char *pszProcMode;
	switch(Quality) {
		case eFQSanger:
			pszProcMode = "Sanger Phred";
			break;

		case eFQIllumia:
			pszProcMode = "Illumina 1.3+ Phred";
			break;

		case eFQSolexa:
			pszProcMode = "Solexa/Illumia pre-1.3";
			break;

		case eFQIgnore:
			pszProcMode = "Ignore";
			break;

		default:
			pszProcMode = "Unknown quality scoring, defaulting to ignore";
			Quality = eFQIgnore;
			break;
		};

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Raw read quality scores are : '%s'",pszProcMode);

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"output format is : '%s'",pszDescr);
	if(szTrackTitle[0] != '\0')
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"track title: '%s'",szTrackTitle);
	for(Idx=0; Idx < NumPE1InputFiles; Idx++)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"input PE1 raw reads files (%d): '%s'",Idx+1,pszPE1InputFiles[Idx]);

	switch(PEproc) {
		case ePEdefault:
			pszProcMode = "Single ended reads";
			break;

		case ePEorphan:					// process for paired ends and if one end is orphaned because multiple aligned then try to locate unique alignment downstream
			pszProcMode = "Paired end reads with orphan partner processing";
			break;

		case ePEunique:					// process for paired ends but only accept putative if both ends uniquely aligned
			pszProcMode = "Paired end reads with both ends uniquely aligned within the targeted genome";
			break;
		}

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"process for: '%s'",pszProcMode);

	for(Idx=0; Idx < NumPE2InputFiles; Idx++)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"input PE2 raw reads files (%d): '%s'",Idx+1,pszPE2InputFiles[Idx]);

	if(szPriorityRegionFile[0] != '\0')
		{
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Prioritise exact matchs to regions in this BED file: '%s'",szPriorityRegionFile);
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Filter out matchs in non-prioritorised regions: '%s'",bFiltPriorityRegions ? "Yes" : "No");
		}

	if(PEproc > ePEdefault)
		{
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"accept as paired if apparent sequence length is between %d and %d",PairMinLen,PairMaxLen);
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Output paired end sequence length distribution to file: '%s'",szStatsFile[0] == '\0' ? "none specified" : szStatsFile);
		}
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"input target sequence(s) suffix array file: '%s'",szTargFile);
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"output results file: '%s'",szRsltsFile);

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Output none-aligned reads to fasta file: '%s'",szNoneAlignFile[0] == '\0' ? "none specified" : szNoneAlignFile);
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Output reads with multiple alignments to fasta file: '%s'",szMultiAlignFile[0] == '\0' ? "none specified" : szMultiAlignFile);
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Output aligner induced substitution distributions to file: '%s'",szStatsFile[0] == '\0' ? "none specified" : szStatsFile);
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Hamming edit distance file: '%s'",szHammFile[0] == '\0' ? "none specified" : szHammFile);

	switch(MLMode) {
		case eMLdefault:
			pszDescr = "slough all reads which match to multiple loci";
			break;
		case eMLdist:
			pszDescr = "accumulate distribution stats only, slough reads matching to multiple loci";
			break;
		case eMLrand:
			pszDescr = "randomly select one of the aligned loci";
			break;
		case eMLuniq:
			pszDescr = "cluster with reads which are uniquely aligned";
			break;
		case eMLcluster:
			pszDescr = "cluster with unique (high priority) and other multiloci alignments";
			break;
		case eMLall:
			pszDescr = "report all multiple loci to which reads align";
			break;
		}
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Process multiple alignment reads by: '%s'",pszDescr);

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Offset read start sites when processing site octamer preferencing: %d",SitePrefsOfs);

	if(szSitePrefsFile[0] != '\0')
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Aligned read octamer site preferencing into this file: '%s'",szSitePrefsFile);

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Allow microInDels of upto this inclusive length: %d",microInDelLen);
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Maximum RNA-seq splice junction separation distance: %d",SpliceJunctLen);
	if(MinSNPreads == 0)
		{
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Minimum read coverage at loci before processing for SNP: No SNP processing");
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"QValue controlling FDR (Benjamini-Hochberg) SNP prediction : No SNP processing");
		}
	else
		{
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Minimum read coverage at loci before processing for SNP: %d",MinSNPreads);
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"QValue controlling FDR (Benjamini-Hochberg) SNP prediction : %0.5f",QValue);
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"SNP predictions written to file : '%s'",szSNPFile);
		if(szSNPCentroidFile[0] != '\0')
			gDiagnostics.DiagOutMsgOnly(eDLInfo,"SNP prediction centroid distributions written to file : '%s'",szSNPCentroidFile);
		}

	if(MaxMLmatches == 1)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Only accept reads which uniquely match a single loci");
	else
		{
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Allow at most any read to match this many loci and then process: %d",MaxMLmatches);
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"If read aligns to more than %d loci then treat as if aligned to the first %d loci discovered : %s",MaxMLmatches, MaxMLmatches,bClampMaxMLmatches ? "Yes" : "No");
		}

	for(Idx = 0; Idx < NumIncludeChroms; Idx++)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"reg expressions defining chroms to include: '%s'",pszIncludeChroms[Idx]);
	for(Idx = 0; Idx < NumExcludeChroms; Idx++)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"reg expressions defining chroms to exclude: '%s'",pszExcludeChroms[Idx]);

	if(szExperiment[0] != '\0')
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"This alignment processing instance reference: %s",szExperiment);

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"number of threads : %d",NumThreads);


#ifdef _WIN32
	SetPriorityClass(GetCurrentProcess(), BELOW_NORMAL_PRIORITY_CLASS);
#endif
	gStopWatch.Start();
	Rslt = Process(PMode,Quality,bSOLiD,bBisulfite,PEproc,PairMinLen,PairMaxLen,AlignStrand,microInDelLen,SpliceJunctLen,
					MinSNPreads,QValue,PCRartefactWinLen,MLMode,
					MaxMLmatches,bClampMaxMLmatches,
					MaxNs,MinEditDist,MaxSubs,Trim5,Trim3,MinFlankExacts,FMode,SitePrefsOfs,NumThreads,szTrackTitle,
					NumPE1InputFiles,pszPE1InputFiles,NumPE2InputFiles,pszPE2InputFiles,szPriorityRegionFile,bFiltPriorityRegions,szRsltsFile, szSNPFile, szSNPCentroidFile, szTargFile,
					szStatsFile,szMultiAlignFile,szNoneAlignFile,szSitePrefsFile,szHammFile,NumIncludeChroms,pszIncludeChroms,NumExcludeChroms,pszExcludeChroms);
	gStopWatch.Stop();

#ifdef _DEBUG
#ifdef _WIN32
_ASSERTE( _CrtCheckMemory());
#endif
#endif

	Rslt = Rslt >=0 ? 0 : 1;
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Exit code: %d Total processing time: %s",Rslt,gStopWatch.Read());
	exit(Rslt);
	}
else
	{
	printf("\n%s the K-mer Adaptive Next Generation Aligner, Version %s\n",gszProcName,cpszProgVer);
	arg_print_errors(stdout,end,gszProcName);
	arg_print_syntax(stdout,argtable,"\nUse '-h' to view option and parameter usage\n");
	exit(1);
	}
return 0;
}


tsBSFRdsHdr m_FileHdr;			// processed reads file header

bool m_bAllReadsLoaded;			// set true when all reads have been parsed and loaded
teBSFrsltCodes m_LoadReadsRslt;	// set with exit code from background reads load thread, read after checking if m_bAllReadsLoaded has been set
size_t m_DataBuffOfs;			// offset at which to read in next read
UINT32 m_NumDescrReads;			// number of reads thus far parsed

tsReadHit *m_pReadHits;			// memory allocated to hold reads, reads are written contiguously into this memory
								// caution: m_pReadHits is allocated/freed with malloc/realloc/free or mmap/mremap/munmap
size_t m_AllocdReadHitsMem;		// how many bytes of memory  for reads have been allocated
size_t m_UsedReadHitsMem;		// how many bytes of allocated reads memory is currently used
UINT32 m_NumReadsLoaded;		// m_pReadHits contains this many reads
UINT32 m_FinalReadID;			// final read identifier loaded as a preprocessed read (tsProcRead)

tsReadHit **m_ppReadHitsIdx;	// memory allocated to hold array of ptrs to read hits in m_pReadHits - usually sorted by some critera
UINT32 m_AllocdReadHitsIdx;		// how many elements for m_pReadHitsIdx have been allocated
etReadsSortMode	m_CurReadsSortMode;	// sort mode last used on m_ppReadHitsIdx

size_t m_AllocLociPValuesMem;   // total memory currently allocated to m_pLociPValues
UINT32 m_NumLociPValues;		// current number of LociPValues
tsLociPValues *m_pLociPValues; // allocated to hold putative SNP loci and their associated PValues
double m_QValue;				// QValue used in

etMLMode m_MLMode;				// how to process multiloci matching reads
bool m_bClampMaxMLmatches;		// normally if too many multiloci hits for a read that read is not accepted as aligned; if m_bAcceptAllMultihits true then these reads are accepted as aligned
int m_ClustWinSize;				// multimatch clustering window size
int m_SMscore;					// score for uniquely matched reads in clustering window
int m_MMscore;					// score for multimatched matched reads in clustering window
tsReadHit *m_pMultiHits;		// holds multihit loci instances
UINT32 m_AllocdMultiHits;		// how many elements for m_pMultiHits have been allocated
size_t m_AllocdMultiHitsMem;	// how much memory for m_pMultiHits has been allocated
UINT32 m_NumMultiHits;			// number of multihit loci elements currently used
UINT32 m_NumUniqueMultiHits;	// number of multihit reads which were initially mapped to a single loci
UINT32 m_NumProvMultiAligned;	// number of reads provisionally with more than one aligned to loci

UINT32 m_NumSloughedNs;			// number of reads which were not aligned because they contained excessive number of indeterminate bases
UINT32 m_TotNonAligned;			// number of reads for which no alignment was discovered
UINT32 m_TotAcceptedAsAligned;	// number of reads accepted as being aligned
UINT32 m_TotAcceptedAsUniqueAligned;  // number of reads accepted as aligned which were uniquely aligned
UINT32 m_TotAcceptedAsMultiAligned;   // number of reads accepted as aligned which aligned to multiple loci


UINT32 m_TotAcceptedHitInsts;	// number of reads aligned and accepted (included in m_TotAcceptedAsAligned) even though there were more than m_MaxMLmatches instances
UINT32 m_TotLociAligned;		// number of loci aligned which have been reported
UINT32 m_TotNotAcceptedDelta;	// number of reads aligned but not accepted because of insufficient hamming

UINT32 m_MaxReadsLen;			// longest read processed
UINT32 m_MinReadsLen;			// shortest read processed
UINT32 m_AvReadsLen;			// average length read processed

int m_MinSNPreads;				// before SNP can be called there must be at least this number of reads covering the loci

tBSFEntryID m_PrevSAMTargEntry; // used to determine when generating SAM output if the target chrom has already been loaded
char m_szSAMTargChromName[128];	// holds previously loaded SAM chrom

UINT64 m_BlockTotSeqLen;		// total sequence length in currently loaded suffix block
int	m_MinCoreLen;				// minimum core length allowed

eALStrand m_AlignStrand;		// which strand to align to - both, watson '+' or crick '-'

int m_microInDelLen;			// microInDel length maximum
int m_SpliceJunctLen;			// minimum splice junction length when aligning RNAseq reads

int m_PerThreadAllocdIdentNodes;    // each thread can use this many tsIdentNodes
int m_TotAllocdIdentNodes;			// total number of tsIdentNodes allocated
tsIdentNode *m_pAllocsIdentNodes;	// memory allocated to hold tsIdentNodes required by all threads

int m_hInFile;			// input file handle
int m_hOutFile;			// output file handle
int m_hIndOutFile;		// optional output microInDel file handle
int m_hJctOutFile;		// optional output splice junction file handle
int m_hSitePrefsFile;	// optional output site octamer preferencing file

int m_hStatsFile;		// optional output stats file handle
int m_hNoneAlignFile;	// optional output none-alignable file handle
int m_hMultiAlignFile;	// optional output multialigned reads file handle

char m_szIndRsltsFile[_MAX_PATH];		// microIndel results to this file
char m_szJctRsltsFile[_MAX_PATH];		// splice junction results to this file

tsSNPCentroid *m_pSNPCentroids;		// allocated to hold centroid distributions if SNP processing

char *m_pszSitePrefsFile;		// site octamer preferencing to this file
int m_SitePrefsOfs;				// offset read start sites when processing  octamer preferencing, range -100..100

etPEproc m_PEproc;				// paired reads alignment processing mode
int m_NumPE2InputFiles;			// number of input PE2 file specs
char **m_ppszPE2InputFiles;		// optional raw PE2 paired reads are in these files
char *m_pszOutFile;				// write alignments to this file
char *m_pszSNPRsltsFile;		// write SNPs to this file
char *m_pszSNPCentroidFile;		// write SNP centroids to this file

char *m_pszSfxFile;				// target as suffix array
char *m_pszStatsFile;			// aligner induced substitutions stats file or paired end length distributions
char *m_pszMultiAlignFile;		// file to contain reads which are aligned to multiple locations
char *m_pszNoneAlignFile;		// file to contain reads which were non-alignable
char *m_pszHammFile;			// Hamming edit distance file

int m_NumPE1InputFiles;			// number of input PE1 file specs
char **m_ppszPE1InputFiles;		// names of inputs file (wildcards allowed unless in dump mode) containing raw reads



int m_hSNPfile;		// file handle used if SNPs are being processed
int m_hSNPCentsfile;		// file handle used if SNP centroids are being processed

tsChromSNPs *m_pChromSNPs; // allocated for use in SNP processing
int m_TotNumSNPs;		// total number of SNPs discovered

int m_szLineBuffIdx;	// offset into m_pszLineBuff at which to next write
char *m_pszLineBuff;	// allocated to hold output line buffering

CSfxArrayV3 *m_pSfxArray; // suffix array holds genome of interest
char m_szTargSpecies[cMaxDatasetSpeciesChrom+1]; // suffix array was generated over this targeted species

CBEDfile *m_pPriorityRegionBED;	// to hold exact match priority regions
bool m_bFiltPriorityRegions;		// if priority regions requested then can also request that only alignments into these regions be reported

tsHamHdr *m_pHamHdr;			// header for binary format hamming edit distances
tsHamChrom *m_pCurHamChrom;		// pts to current chromosome specific binary hammings

int *m_pLenDist;		// allocated to hold paired read sequence length counts

int m_Trim5;						// trim this number of bases from 5' end of reads when loading the reads
int m_Trim3;						// trim this number of bases from 3' end of reads when loading the reads


typedef struct TAG_sQScoreDist {
	UINT32 Subs;				// count of aligner induced substitutions
	UINT32 QInsts;				// count of instances of this Phred quality score
} tsQScoreDist;

// note that sub distributions are characterised into 4 bands: Phred 0..8, 9..19, 20..29, and 30+
tsQScoreDist m_AlignQSubDist[4][cMaxFastQSeqLen+1];	// to hold aligner induced substitution count distribution
int m_AlignMSubDist[cMaxFastQSeqLen+1];  // to hold multiple aligner induced substitutions counts
int m_MaxMSubDist;		// actual maximum number of multiple aligner induced substitutions in any read
int m_MaxAlignLen;		// actual maximum length aligned read length

etPMode m_PMode;		// processing mode
etFMode m_FMode;		// output format mode
int m_NumThreads;		// number of worker threads to use
int m_MaxNs;			// max number of indeterminate bases 'N' to acept in read before deeming read as unalignable
int m_MaxMLmatches;			// allow at most this many multihits by any single read before accepting read as being aligned
int m_MultiHitDist[cMaxMultiHits];	// used to record the accepted as aligned multihit distribution

tsHitLoci *m_pAllocsMultiHitLoci; // allocated to hold all multihit loci for all threads
char *m_pszTrackTitle;			// track title if output format is UCSC BED
UINT8 *m_pAllocsMultiHitBuff;	  // allocated to hold per thread buffered output when processing all multihit loci

int m_NumIncludeChroms;				// number of RE include chroms
int m_NumExcludeChroms;				// number of RE exclude chroms

#ifdef _WIN32
Regexp *m_IncludeChromsRE[cMaxIncludeChroms];	// compiled regular expressions
Regexp *m_ExcludeChromsRE[cMaxExcludeChroms];
#else
regex_t m_IncludeChromsRE[cMaxIncludeChroms];	// compiled regular expressions
regex_t m_ExcludeChromsRE[cMaxExcludeChroms];
#endif

UINT32 m_NumReadsProc;		// number of reads thus far processed - note this is total reads handed out to processing threads
							// and should be treated as a guide only
size_t m_NxtReadProcOfs;	// byte offset into m_pReadHits of next read to be processed

bool m_bBisulfite;			// true if bisulfite methylation patterning processing
bool m_bIsSOLiD;			// true if SOLiD or colorspace processing
etFQMethod m_QMethod;		// fastq quality value method

int m_ElimPlusTrimed;		// number of aligned reads flank trimmed on the '+' strand
int m_ElimMinusTrimed;		// number of aligned reads flank trimmed on the '-' strand

bool m_bMutexesCreated;		// will be set true if synchronisation mutexes have been created

UINT8 m_TermBackgoundThreads = 0; // if non-zero then all background threads are to immediately terminate processing

int m_ThreadLoadReadsRslt;
#ifdef _WIN32
unsigned int m_ThreadLoadReadsID;
#else
pthread_t m_ThreadLoadReadsID;
#endif

int	(CSfxArrayV3::*m_pIterateExactsFn)(etSeqBase *,unsigned int,unsigned int,unsigned int *,unsigned int *);

void
Init(void)
{
m_hInFile = -1;
m_hOutFile = -1;
m_hIndOutFile = -1;
m_hJctOutFile = -1;
m_hStatsFile = -1;
m_hSitePrefsFile = -1;
m_hNoneAlignFile = -1;
m_hMultiAlignFile = -1;
m_hSNPfile = -1;
m_hSNPCentsfile = -1;
m_pReadHits = NULL;
m_ppReadHitsIdx = NULL;
m_ppReadHitsIdx = NULL;
m_pMultiHits = NULL;
m_pLociPValues = NULL;
m_pSfxArray = NULL;
m_pPriorityRegionBED = NULL;
m_pAllocsIdentNodes = NULL;
m_pAllocsMultiHitLoci = NULL;
m_pAllocsMultiHitBuff = NULL;
m_pChromSNPs = NULL;
m_pHamHdr = NULL;
m_pCurHamChrom = NULL;
m_pszLineBuff = NULL;
m_pLenDist = NULL;
m_pSNPCentroids = NULL;

m_szLineBuffIdx = 0;
m_MaxMLmatches = 0;
m_bClampMaxMLmatches = false;
m_TotAllocdIdentNodes = 0;
m_PerThreadAllocdIdentNodes = 0;
m_AllocdReadHitsMem = 0;
m_UsedReadHitsMem = 0;
m_NumReadsLoaded = 0;
m_FinalReadID = 0;
m_AllocdReadHitsIdx = 0;
m_AllocdMultiHits = 0;
m_AllocdMultiHitsMem = 0;
m_NumMultiHits = 0;
m_NumUniqueMultiHits = 0;
m_NumProvMultiAligned = 0;
m_MaxAlignLen = 0;
m_MaxNs = 0;
m_bIsSOLiD = false;
m_bBisulfite = false;
m_AlignStrand = eALSnone;
m_microInDelLen = 0;
m_SpliceJunctLen = 0;
m_AllocLociPValuesMem = 0;
m_NumLociPValues = 0;
m_QValue = 0.0;
m_MinSNPreads = 0;
m_NumReadsProc = 0;
m_NxtReadProcOfs = 0;
m_ElimPlusTrimed = 0;
m_ElimMinusTrimed = 0;
m_PEproc = ePEdefault;
m_TotNonAligned = 0;
m_NumSloughedNs = 0;
m_TotAcceptedAsAligned = 0;
m_TotLociAligned = 0;
m_TotAcceptedAsUniqueAligned = 0;
m_TotAcceptedAsMultiAligned = 0;
m_TotNotAcceptedDelta = 0;
m_TotAcceptedHitInsts = 0;
m_SitePrefsOfs = cDfltRelSiteStartOfs;
m_pszOutFile = NULL;
m_szIndRsltsFile[0] = '\0';
m_szJctRsltsFile[0] = '\0';
m_pszSNPRsltsFile = NULL;
m_pszSNPCentroidFile = NULL;
m_pszSitePrefsFile = NULL;
m_MaxReadsLen = 0;
m_MinReadsLen = 0;
m_AvReadsLen = 0;
m_bFiltPriorityRegions = false;
memset(m_AlignQSubDist,0,sizeof(m_AlignQSubDist));
memset(m_AlignMSubDist,0,sizeof(m_AlignMSubDist));
memset(m_MultiHitDist,0,sizeof(m_MultiHitDist));
memset(&m_FileHdr,0,sizeof(m_FileHdr));
m_bMutexesCreated = false;
}

void
Reset(bool bSync)			// if bSync true then fsync before closing output file handles
{
m_TermBackgoundThreads = 0x01;	// need to require any background threads to self-terminate
if(m_hInFile != -1)
	{
	close(m_hInFile);
	m_hInFile = -1;
	}
if(m_hOutFile != -1)
	{
	if(bSync)
#ifdef _WIN32
		_commit(m_hOutFile);
#else
		fsync(m_hOutFile);
#endif
	close(m_hOutFile);
	m_hOutFile = -1;
	}
if(m_hJctOutFile != -1)
	{
	if(bSync)
#ifdef _WIN32
		_commit(m_hJctOutFile);
#else
		fsync(m_hJctOutFile);
#endif
	close(m_hJctOutFile);
	m_hJctOutFile = -1;
	}
if(m_hIndOutFile != -1)
	{
	if(bSync)
#ifdef _WIN32
		_commit(m_hIndOutFile);
#else
		fsync(m_hIndOutFile);
#endif
	close(m_hIndOutFile);
	m_hIndOutFile = -1;
	}
if(m_hStatsFile != -1)
	{
	if(bSync)
#ifdef _WIN32
		_commit(m_hStatsFile);
#else
		fsync(m_hStatsFile);
#endif
	close(m_hStatsFile);
	m_hStatsFile = -1;
	}
if(m_hNoneAlignFile != -1)
	{
	if(bSync)
#ifdef _WIN32
		_commit(m_hNoneAlignFile);
#else
		fsync(m_hNoneAlignFile);
#endif
	close(m_hNoneAlignFile);
	m_hNoneAlignFile = -1;
	}
if(m_hMultiAlignFile != -1)
	{
	if(bSync)
#ifdef _WIN32
		_commit(m_hMultiAlignFile);
#else
		fsync(m_hMultiAlignFile);
#endif
	close(m_hMultiAlignFile);
	m_hMultiAlignFile = -1;
	}
if(m_hSitePrefsFile != -1)
	{
	if(bSync)
#ifdef _WIN32
		_commit(m_hSitePrefsFile);
#else
		fsync(m_hSitePrefsFile);
#endif
	close(m_hSitePrefsFile);
	m_hSitePrefsFile = -1;
	}

if(m_hSNPfile != -1)
	{
	if(bSync)
#ifdef _WIN32
		_commit(m_hSNPfile);
#else
		fsync(m_hSNPfile);
#endif
	close(m_hSNPfile);
	m_hSNPfile = -1;
	}

if(m_hSNPCentsfile != -1)
	{
	if(bSync)
#ifdef _WIN32
		_commit(m_hSNPCentsfile);
#else
		fsync(m_hSNPCentsfile);
#endif
	close(m_hSNPCentsfile);
	m_hSNPCentsfile = -1;
	}

if(m_pSNPCentroids != NULL)
	{
	delete(m_pSNPCentroids);
	m_pSNPCentroids = NULL;
	}

if(m_pszLineBuff != NULL)
	{
	delete m_pszLineBuff;
	m_pszLineBuff = NULL;
	}
if(m_pAllocsIdentNodes != NULL)
	{
	delete m_pAllocsIdentNodes;
	m_pAllocsIdentNodes = NULL;
	}

if(m_pAllocsMultiHitBuff != NULL)
	{
	delete m_pAllocsMultiHitBuff;
	m_pAllocsMultiHitBuff = NULL;
	}

if(m_pAllocsMultiHitLoci != NULL)
	{
	delete m_pAllocsMultiHitLoci;
	m_pAllocsMultiHitLoci = NULL;
	}
if(m_pSfxArray != NULL)
	{
	delete m_pSfxArray;
	m_pSfxArray = NULL;
	}
if(m_pPriorityRegionBED != NULL)
	{
	delete m_pPriorityRegionBED;
	m_pPriorityRegionBED = NULL;
	}

if(m_pReadHits != NULL)
	{
#ifdef _WIN32
	free(m_pReadHits);				// was allocated with malloc/realloc, or mmap/mremap, not c++'s new....
#else
	if(m_pReadHits != MAP_FAILED)
		munmap(m_pReadHits,m_AllocdReadHitsMem);
#endif
	m_pReadHits = NULL;
	}
if(m_ppReadHitsIdx != NULL)
	{
	delete m_ppReadHitsIdx;
	m_ppReadHitsIdx = NULL;
	}
if(m_pMultiHits != NULL)
	{
#ifdef _WIN32
	free(m_pMultiHits);				// was allocated with malloc/realloc, or mmap/mremap, not c++'s new....
#else
	if(m_pMultiHits != MAP_FAILED)
		munmap(m_pMultiHits,m_AllocdMultiHitsMem);
#endif
	m_pMultiHits = NULL;
	}

if(m_pLociPValues != NULL)
	{
#ifdef _WIN32
	free(m_pLociPValues);				// was allocated with malloc/realloc, or mmap/mremap, not c++'s new....
#else
	if(m_pLociPValues != MAP_FAILED)
		munmap(m_pLociPValues,m_AllocLociPValuesMem);
#endif
	m_pLociPValues = NULL;
	}

if(m_pHamHdr != NULL)
	{
	delete(m_pHamHdr);
	m_pHamHdr = NULL;
	}

if(m_pChromSNPs != NULL)
	{
	delete m_pChromSNPs;
	m_pChromSNPs = NULL;
	}

if(m_pLenDist != NULL)
	{
	delete m_pLenDist;
	m_pLenDist = NULL;
	}

DeleteMutexes();

Init();
m_TermBackgoundThreads = 0x0;	// can startup any background thread processing
}

teBSFrsltCodes
LoadHammings(char *pszHammings)
{
int hHamFile;
tsHamHdr HamHdr;

#ifdef _WIN32
hHamFile = open(pszHammings, O_READSEQ ); // file access will be sequential..
#else
hHamFile = open64(pszHammings, O_READSEQ ); // file access will be sequential..
#endif
if(hHamFile == -1)					// check if file open succeeded
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open %s - %s",pszHammings,strerror(errno));
	Reset(false);
	return(eBSFerrOpnFile);
	}

if(read(hHamFile,&HamHdr,sizeof(tsHamHdr))!=sizeof(tsHamHdr))
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to read %s - %s",pszHammings,strerror(errno));
	close(hHamFile);
	Reset(false);
	return(eBSFerrParse);
	}
if(HamHdr.Magic[0] != 'b' || HamHdr.Magic[1] != 'h' || HamHdr.Magic[2] != 'a' || HamHdr.Magic[3] != 'm')
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Not a binary format Hamming distance file - %s",pszHammings);
	close(hHamFile);
	Reset(false);
	return(eBSFerrFileType);
	}
if(HamHdr.NumChroms < 1)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Hamming distance file contains no edit distances - %s",pszHammings);
	close(hHamFile);
	Reset(false);
	return(eBSFerrNoEntries);
	}

if((m_pHamHdr = (tsHamHdr *)new UINT8 [HamHdr.Len])==NULL)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Unable to allocate memory (%d bytes) for holding Hamming distances loaded from - %s",HamHdr.Len,pszHammings);
	close(hHamFile);
	Reset(false);
	return(eBSFerrMem);
	}
memcpy(m_pHamHdr,&HamHdr,sizeof(tsHamHdr));
if(read(hHamFile,(UINT8 *)m_pHamHdr+sizeof(tsHamHdr),HamHdr.Len-sizeof(tsHamHdr))!=HamHdr.Len-sizeof(tsHamHdr))
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Unable to read all Hamming edit distances from - %s",pszHammings);
	close(hHamFile);
	Reset(false);
	return(eBSFerrFileAccess);
	}

close(hHamFile);
return(eBSFSuccess);
}

int						// returned Hamming distance, 0 if no hammings loaded, -1 if not located
LocateHamming(char *pszChrom,UINT32 Loci)
{
int ChromIdx;
if(m_pHamHdr == NULL)
	return(0);
if(m_pCurHamChrom == NULL || stricmp((char *)m_pCurHamChrom->szChrom,pszChrom))
	{
	for(ChromIdx = 0; ChromIdx < m_pHamHdr->NumChroms; ChromIdx++)
		{
		m_pCurHamChrom = (tsHamChrom *)((UINT8 *)m_pHamHdr + m_pHamHdr->ChromOfs[ChromIdx]);
		if(!stricmp((char *)m_pCurHamChrom->szChrom,pszChrom))
			break;
		}
	if(ChromIdx == m_pHamHdr->NumChroms)
		{
		m_pCurHamChrom = NULL;
		return(-1);
		}
	}
if(m_pCurHamChrom->NumEls < Loci)
	return(-1);
return(m_pCurHamChrom->Dists[Loci]);
}



teBSFrsltCodes
Disk2Hdr(char *pszRdsFile)
{
if(_lseeki64(m_hInFile,0,SEEK_SET)!=0)			// read in header..
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Seek failed to offset 0 - %s",pszRdsFile,strerror(errno));
	Reset(false);			// closes opened files..
	return(eBSFerrFileAccess);
	}

if(sizeof(tsBSFRdsHdr) != read(m_hInFile,&m_FileHdr,sizeof(tsBSFRdsHdr)))
	return(eBSFerrNotBioseq);

// header read, validate it as being a reads file header
if(tolower(m_FileHdr.Magic[0]) != 'b' ||
	tolower(m_FileHdr.Magic[1]) != 'i' ||
	tolower(m_FileHdr.Magic[2]) != 'o' ||
	tolower(m_FileHdr.Magic[3]) != 'r')
	return(eBSFerrNotBioseq);

	// can we handle this version?
if(m_FileHdr.Version < cBSFRdsVersionBack || m_FileHdr.Version > cBSFRdsVersion)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"%s opened as a preprocessed reads file - expected between version %d and %d, file version is %d",
					pszRdsFile,cBSFRdsVersionBack,cBSFRdsVersion,m_FileHdr.Version);
	Reset(false);			// closes opened files..
	return(eBSFerrFileVer);
	}

return(eBSFSuccess);
}

// Following DiagSequences and LogReadHit are purely for use during low level debugging
#ifdef USEWHILEDBUG1

char *
DiagCmpSequences(int SeqLen,etSeqBase *pProbeSeq,etSeqBase *pTargSeq)
{
int Idx;

static char szBuff[(cMaxFastQSeqLen + 10) * 3];
int BuffIdx;
BuffIdx=sprintf(szBuff,"P:\"%s\"\n   ",CSeqTrans::MapSeq2Ascii(pProbeSeq,SeqLen));
// compare with probe sequence and highlight the differences
for(Idx = 0; Idx < SeqLen; Idx++)
	{
	if((pTargSeq[Idx] & 0x07) != (pProbeSeq[Idx]  & 0x07))
		szBuff[BuffIdx++] = '|';
	else
		szBuff[BuffIdx++] = '.';
	}

BuffIdx+=sprintf(&szBuff[BuffIdx],"\nT:\"%s\"\n",CSeqTrans::MapSeq2Ascii(pTargSeq,SeqLen));
return(szBuff);
}

char *
DiagSequences(int ProbeLen,etSeqBase *pProbeSeq,char Strand,int ChromID,int MatchLoci,int MatchLen)
{
int Idx;

static char szBuff[(cMaxFastQSeqLen + 10) * 3];
etSeqBase Sequence[cMaxFastQSeqLen+1];	// to hold matched sequence
int BuffIdx;
BuffIdx=sprintf(szBuff,"P:\"%s\"\n   ",CSeqTrans::MapSeq2Ascii(pProbeSeq,ProbeLen));
m_pSfxArray->GetSeq(ChromID,MatchLoci,Sequence,MatchLen);	// get sequence for entry starting at offset and of length len
if(Strand == '-')
	CSeqTrans::ReverseComplement(MatchLen,Sequence);
// compare with probe sequence and highlight the differences
for(Idx = 0; Idx < ProbeLen; Idx++)
	{
	if((Sequence[Idx] & 0x07) != (pProbeSeq[Idx]  & 0x07))
		szBuff[BuffIdx++] = '|';
	else
		szBuff[BuffIdx++] = '.';
	}

BuffIdx+=sprintf(&szBuff[BuffIdx],"\nT:\"%s\"\n",CSeqTrans::MapSeq2Ascii(Sequence,MatchLen));
return(szBuff);
}

void
LogReadHit(tsReadHit *pReadHit)
{
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Read hit dump - ReadHitIdx: %d ReadID: %d ReadLen: %d\n LowHitInstances: %d LowMMCnt: %d NumHits: %d NumReads: %d \n FlagSegs: %d FlgInDel: %d FlgInsert: %d FlgNonOrphan: %d FlgSplice: %d",
						    pReadHit->ReadHitIdx,pReadHit->ReadID,pReadHit->ReadLen,pReadHit->LowHitInstances,pReadHit->LowMMCnt,pReadHit->NumHits,pReadHit->NumReads,
							pReadHit->HitLoci.FlagSegs,
							pReadHit->HitLoci.Hit.FlgInDel,pReadHit->HitLoci.Hit.FlgInsert,pReadHit->HitLoci.Hit.FlgNonOrphan,pReadHit->HitLoci.Hit.FlgSplice);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Read hit dump (Hit Seg[0]) : ReadHitIdx: %d\n        ChromID: %d HitLen: %d HitLoci: %d Mismatches: %d ProbeOfs: %d Strand: %c",pReadHit->ReadHitIdx,
	pReadHit->HitLoci.Hit.Seg[0].ChromID,pReadHit->HitLoci.Hit.Seg[0].MatchLen,pReadHit->HitLoci.Hit.Seg[0].MatchLoci,pReadHit->HitLoci.Hit.Seg[0].Mismatches,pReadHit->HitLoci.Hit.Seg[0].ReadOfs,pReadHit->HitLoci.Hit.Seg[0].Strand);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Read hit dump (Hit Seg[1]) : ReadHitIdx: %d\n        ChromID: %d HitLen: %d HitLoci: %u Mismatches: %d ProbeOfs: %d Strand: %c",pReadHit->ReadHitIdx,
	pReadHit->HitLoci.Hit.Seg[1].ChromID,pReadHit->HitLoci.Hit.Seg[1].MatchLen,pReadHit->HitLoci.Hit.Seg[1].MatchLoci,pReadHit->HitLoci.Hit.Seg[1].Mismatches,pReadHit->HitLoci.Hit.Seg[1].ReadOfs,pReadHit->HitLoci.Hit.Seg[1].Strand);

}
#endif

int WriteReadHits(bool bPEProc);		   // true if processing paired ends;
int WriteSAMReadHits(etFMode SAMformat,	   // expected to be either eFMsam or eFMsamAll
					 bool bPEProc);		   // true if processing paired ends
int ReportSAMread(tsReadHit *pReadHit,	// single ended read or if pPairReadHit non-null then 1st of paired end reads
						tsReadHit *pPairReadHit); // if non-null then pair of pReadHit


inline UINT32
AdjStartLoci(tsSegLoci *pSeg)
{
if(pSeg->Strand == '+')
	return((UINT32)pSeg->MatchLoci + pSeg->TrimLeft);
else
	return((UINT32)pSeg->MatchLoci + pSeg->TrimRight);
}

inline UINT32
AdjEndLoci(tsSegLoci *pSeg)
{
if(pSeg->Strand == '+')
	return((UINT32)pSeg->MatchLoci + pSeg->MatchLen + pSeg->TrimRight - 1);
else
	return((UINT32)pSeg->MatchLoci  + pSeg->MatchLen +  pSeg->TrimLeft - 1);
}

inline UINT32
AdjHitLen(tsSegLoci *pSeg)
{
return((UINT32)pSeg->MatchLen - pSeg->TrimLeft - pSeg->TrimRight);
}

inline UINT32
AdjAlignStartLoci(tsHitLoci *pHit)
{
tsSegLoci *pSeg = &pHit->Seg[0];
if(pSeg->Strand == '+')
	return((UINT32)pSeg->MatchLoci + pSeg->TrimLeft);
else
	return((UINT32)pSeg->MatchLoci + pSeg->TrimRight);
}

inline UINT32
AdjAlignEndLoci(tsHitLoci *pHit)
{
tsSegLoci *pSeg;
if(pHit->FlgInDel || pHit->FlgSplice)
	pSeg = &pHit->Seg[1];
else
	pSeg = &pHit->Seg[0];
if(pSeg->Strand == '+')
	return((UINT32)pSeg->MatchLoci + pSeg->MatchLen + pSeg->TrimRight - 1);
else
	return((UINT32)pSeg->MatchLoci  + pSeg->MatchLen +  pSeg->TrimLeft - 1);
}

inline UINT32
AdjAlignHitLen(tsHitLoci *pHit)
{
UINT32 HitLen;
tsSegLoci *pSeg = &pHit->Seg[0];
HitLen = (UINT32)pSeg->MatchLen - pSeg->TrimLeft - pSeg->TrimRight;
if(pHit->FlgInDel || pHit->FlgSplice)
	{
	pSeg = &pHit->Seg[1];
	HitLen += (UINT32)pSeg->MatchLen - pSeg->TrimLeft - pSeg->TrimRight;
	}
return(HitLen);
}

inline int
AdjAlignMismatches(tsHitLoci *pHit)
{
int Mismatches;
tsSegLoci *pSeg = &pHit->Seg[0];
Mismatches = pSeg->TrimMismatches;
if(pHit->FlgInDel || pHit->FlgSplice)
	{
	pSeg = &pHit->Seg[1];
	Mismatches += pSeg->TrimMismatches;
	}
return(Mismatches);
}

// AutoTrimFlanks
// Autotrim back aligned read flanks until there are at least MinFlankExacts exactly matching bases in the flanks
// Intent is that this will be useful for delimiting RNAseq reads covering exon boundaries
// Autotrimmed aligned reads must be at least 50% of their untrimmed length or they will be discarded; exception is that if paired end processing then
// triming of these reads is limited so that at least 1/3rd of the read is retained as a central core
int
AutoTrimFlanks(int MinFlankExacts)
{
tsReadHit *pReadHit;
UINT32 SeqIdx;
UINT32 Idx;
int MinTrimmedLen;
UINT8 *pSeq;

m_ElimPlusTrimed = 0;
m_ElimMinusTrimed = 0;
if(MinFlankExacts > 0)	// do  3' and 5' autotrim? Note that currently can't trim multiseg hits
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Starting 5' and 3' flank sequence autotrim processing...");
	etSeqBase *pHitSeq;
	pReadHit = NULL;
	int ExactLen;
	int LeftOfs;
	int RightOfs;
	UINT32 MatchLen;
	int TrimMismatches;
	UINT8 ReadSeq[cMaxFastQSeqLen+1];
	UINT8 TargSeq[cMaxFastQSeqLen+1];

	while((pReadHit = IterReads(pReadHit))!=NULL)
		{
		pReadHit->HitLoci.FlagTR = 0;
		if(pReadHit->NumHits != 1 || pReadHit->HitLoci.FlagSegs == 1)
			continue;
		MatchLen = pReadHit->HitLoci.Hit.Seg[0].MatchLen;
		if(MatchLen != pReadHit->ReadLen)
			{
			pReadHit->NumHits = 4;
			if(pReadHit->HitLoci.Hit.Seg[0].Strand == '+')
				m_ElimPlusTrimed += 1;
			else
				m_ElimMinusTrimed += 1;
			continue;
			}

		MinTrimmedLen = (MatchLen+1)/2;
		if(MinTrimmedLen < 15)
			MinTrimmedLen = 15;

				// copy read into ReadSeq masking any hi-order phred scores (in bits 4..7) and repeat mask (bit 3) out
		pHitSeq = &pReadHit->Read[pReadHit->DescrLen+1];
		pSeq = ReadSeq;
		for(SeqIdx = 0; SeqIdx < MatchLen; SeqIdx++)
			*pSeq++ = *pHitSeq++ & 0x07;

		if(m_bIsSOLiD)
			{
			UINT32 Loci = AdjStartLoci(&pReadHit->HitLoci.Hit.Seg[0]);
			if(pReadHit->HitLoci.Hit.Seg[0].Strand == '+')
				Loci += 1;
			if(m_pSfxArray->GetColorspaceSeq(pReadHit->HitLoci.Hit.Seg[0].ChromID,
									Loci,
									TargSeq,MatchLen) == 0) // get colorspace sequence
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: GetColorspaceSeq() for chrom %d, Loci %d, matchlen %d failed",
										pReadHit->HitLoci.Hit.Seg[0].ChromID,Loci,MatchLen);
				Reset(false);
				return(eBSFerrMem);
				}

			if(pReadHit->HitLoci.Hit.Seg[0].Strand == '-')
				CSeqTrans::ReverseSeq(MatchLen,TargSeq);

			// convert target assembly sequence read into colorspace
			pSeq = ReadSeq;
			UINT8 PrvBase = *pSeq;
			for(SeqIdx = 1; SeqIdx <= MatchLen; SeqIdx++,pSeq++)
				{
				*pSeq = SOLiDmap[PrvBase][pSeq[1]];
				PrvBase = pSeq[1];
				}
			MatchLen -= 1;
			}
		else
			{
			// get basespace sequence
			m_pSfxArray->GetSeq(pReadHit->HitLoci.Hit.Seg[0].ChromID,(UINT32)(UINT64)pReadHit->HitLoci.Hit.Seg[0].MatchLoci,TargSeq,(UINT32)MatchLen);
			if(pReadHit->HitLoci.Hit.Seg[0].Strand == '-')
				CSeqTrans::ReverseComplement(MatchLen,TargSeq);
			}

		// trim from 5' towards 3'
		pSeq = ReadSeq;
		pHitSeq = TargSeq;
		ExactLen = 0;
		TrimMismatches = 0;
		int PEmincore;
		if(m_PEproc == ePEdefault)
			PEmincore = MatchLen;
		else
			PEmincore = MatchLen / 3;
		for(Idx = 0; Idx <= (MatchLen-(UINT32)MinTrimmedLen) && Idx < (UINT32)PEmincore; Idx++,pSeq++,pHitSeq++)
			{
			if(*pSeq != *pHitSeq)
				{
				ExactLen = 0;
				TrimMismatches += 1;
				continue;
				}
			ExactLen += 1;
			if(ExactLen == MinFlankExacts)
				break;
			}

		if(m_PEproc == ePEdefault)
			{
			// if can't trim to a 5' flank of at least MinFlankExacts then this read is to be sloughed
			if((Idx + MinTrimmedLen) > MatchLen || ExactLen < MinFlankExacts)
				{
				pReadHit->NumHits = 4;
				if(pReadHit->HitLoci.Hit.Seg[0].Strand == '+')
					m_ElimPlusTrimed += 1;
				else
					m_ElimMinusTrimed += 1;
				continue;
				}
			}
		LeftOfs = Idx - (MinFlankExacts - 1);

		// trim from 3' towards 5'
		pHitSeq = &TargSeq[MatchLen-1];
		pSeq = &ReadSeq[MatchLen-1];
		ExactLen = 0;
		if(m_PEproc == ePEdefault)
			PEmincore = 0;
		else
			PEmincore = (MatchLen * 2) / 3;

		for(Idx = MatchLen-1; Idx >= (UINT32)(LeftOfs+MinTrimmedLen) && Idx > (UINT32)PEmincore; Idx--,pSeq--,pHitSeq--)
			{
			if(*pSeq != *pHitSeq)
				{
				ExactLen = 0;
				TrimMismatches += 1;
				continue;
				}
			ExactLen += 1;
			if(ExactLen == MinFlankExacts)
				break;
			}

		if(m_PEproc == ePEdefault)
			{
			// if can't trim to a 3' flank of at least MinFlankExacts then this read is to be sloughed
			if(ExactLen != MinFlankExacts || Idx < (UINT32)(LeftOfs + MinTrimmedLen))
				{
				pReadHit->NumHits = 4;
				if(pReadHit->HitLoci.Hit.Seg[0].Strand == '+')
					m_ElimPlusTrimed += 1;
				else
					m_ElimMinusTrimed += 1;
				continue;
				}
			}
		RightOfs = Idx + MinFlankExacts;

		// left and right offset in the read at which the exact matching flanks start is now known
		if(m_bIsSOLiD)
			{
			MatchLen += 1;
			RightOfs += 1;
			}

		pReadHit->HitLoci.Hit.Seg[0].TrimLeft = LeftOfs;
		pReadHit->HitLoci.Hit.Seg[0].TrimRight = MatchLen - RightOfs;
		if(LeftOfs || (MatchLen - RightOfs))
			{
			pReadHit->HitLoci.Hit.Seg[0].TrimMismatches = pReadHit->HitLoci.Hit.Seg[0].Mismatches - TrimMismatches;
			pReadHit->HitLoci.FlagTR = 1;
			}
		else
			pReadHit->HitLoci.FlagTR = 0;
		}

	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Finished 5' and 3' flank sequence autotriming, %d plus strand and %d minus strand aligned reads removed",m_ElimPlusTrimed,m_ElimMinusTrimed);
	}
return(eBSFSuccess);
}

//
int
NumUniqueAlignedReads()
{
tsReadHit *pReadHit = NULL;
int NumUniques = 0;
while((pReadHit = IterReads(pReadHit))!=NULL)
	{
	if(pReadHit->NumHits == 1)
		NumUniques += 1;
	}
return(NumUniques);
}

int
DedupeNonuniqueReads(void)
{
int NumSubDups;

tsReadHit *pReadHit1;
tsReadHit *pReadHitMark;
tsReadHit *pReadHit = NULL;

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Deduping aligned reads which after substitutions are no longer unique");

NumSubDups = 0;
while((pReadHit = IterSortedReads(pReadHit))!=NULL)
	{
	if(pReadHit->NumHits != 1)		// only interested in reads with a single hits
		continue;

	pReadHit1 = pReadHit;			// start iterating forward checking for multiple probe hits onto same locus
	pReadHitMark = pReadHit;
	while((pReadHit1 = IterSortedReads(pReadHit1)) != NULL)
		{
		if(pReadHit1->NumHits != 1)	// only interested in reads with a single hits
			break;

		if(	pReadHit->HitLoci.Hit.Seg[0].ChromID == pReadHit1->HitLoci.Hit.Seg[0].ChromID && // iterated probe hitting same locus as original probe?
			AdjStartLoci(&pReadHit->HitLoci.Hit.Seg[0]) == AdjStartLoci(&pReadHit1->HitLoci.Hit.Seg[0]) &&
			pReadHit->HitLoci.Hit.Seg[0].Strand == pReadHit1->HitLoci.Hit.Seg[0].Strand)
			{
			// the iterated probe will be of equal or lower level than original probe
			// simply treat iterated probe as though it had multiple matches
			pReadHit1->NumHits = 3;
			pReadHitMark = pReadHit1;
			NumSubDups += 1;
			}
		else
			break;
		}
	pReadHit = pReadHitMark;
	}
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Deduping completed, removed %d non-unique reads",NumSubDups);
return(eBSFSuccess);
}


//
// PCR results in differential read duplications with some sequence templates being many fold duplicated relative to others
// Differential artifact reduction is very crude!
// Each unique loci to which a read is aligned is iterated, then the number of unique read alignment sites up/down stream within WinLen bases is counted and this count is then used
// to limit the number of reads attributed to the loci currently being iterated.
// The limit is set to be a function of the maximum of the up/downstream unique aligned loci within WinLen...
int
ReducePCRduplicates(int WinLen)
{
int Rslt;
int NumSubDups;
int CurChromID;
int CurLen;
int CurStart;
UINT8 CurStrand;
int UpUniques;
int DnUniques;
int LimitDups;
int PropWin;

tsReadHit *pReadHit1;
tsReadHit *pReadHitMark;
tsReadHit *pReadHit = NULL;

// sort reads by match loci
if((Rslt=SortReadHits(eRSMHitMatch,false)) < eBSFSuccess)
	{
	Reset(false);
	return(Rslt);
	}

NumSubDups = 0;
while((pReadHit = IterSortedReads(pReadHit))!=NULL)
	{
	if(pReadHit->NumHits != 1)		// only interested in reads with a unique hits
		continue;

	if(WinLen > 0)
		{
		UpUniques = NumUpUniques(pReadHit,WinLen,true);
		DnUniques = NumDnUniques(pReadHit,WinLen,true);
		LimitDups = max(UpUniques,DnUniques);
		PropWin = (int)(((double)LimitDups/WinLen) * 100.0);
		if(PropWin < 5)
			LimitDups = 1;
		else
			if(PropWin <= 10)
				LimitDups = 2;
			else
				if(PropWin <= 20)
					LimitDups = 3;
				else
					if(PropWin <= 40)
						LimitDups = 4;
					else
						if(PropWin <= 60)
							LimitDups = 5;
						else
							if(PropWin <= 80)
								LimitDups = 10;
							else
								LimitDups = 50;
		}
	else
		LimitDups = 0;

	pReadHit1 = pReadHit;			// start iterating forward checking for multiple probe hits onto same locus
	pReadHitMark = pReadHit;
	CurChromID = pReadHit->HitLoci.Hit.Seg[0].ChromID;
	CurStart = AdjStartLoci(&pReadHit->HitLoci.Hit.Seg[0]);
	CurLen = AdjHitLen(&pReadHit->HitLoci.Hit.Seg[0]);
	CurStrand = pReadHit->HitLoci.Hit.Seg[0].Strand;
	while((pReadHit1 = IterSortedReads(pReadHit1)) != NULL)
		{
		if(pReadHit1->NumHits != 1)	// only interested in reads with a unique hits
			continue;

		if(CurChromID == pReadHit1->HitLoci.Hit.Seg[0].ChromID && // iterated probe hitting same locus as original probe?
			CurStart == AdjStartLoci(&pReadHit1->HitLoci.Hit.Seg[0]) &&
			CurStrand == pReadHit1->HitLoci.Hit.Seg[0].Strand)
			{
			if(CurLen != AdjHitLen(&pReadHit1->HitLoci.Hit.Seg[0]))
				continue;
			if(LimitDups > 0)
				{
				LimitDups -= 1;
				continue;
				}

			pReadHit1->NumHits = 3;
			pReadHitMark = pReadHit1;
			NumSubDups += 1;
			}
		else
			break;
		}
	pReadHit = pReadHitMark;
	}
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Removed %d potential PCR artefact reads",NumSubDups);
return(eBSFSuccess);
}


int
RemoveOrphanSpliceJuncts(int SpliceJunctLen)
{
int Idx;
if(SpliceJunctLen > 0)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Filtering out any orphan splice junction reads");
	int NumSpliceJuncs = 0;
	int	NumSpliceAccepted = 0;
	int	NumSpliceNotAccepted = 0;
	tsSegJuncts *pSegJuncts = NULL;
	tsSegJuncts *pJunct;
	tsSegJuncts *pNxtJunct;
	tsReadHit *pCurHit = NULL;
	tsReadHit *pReadHit = NULL;
	while((pReadHit = IterReads(pReadHit))!=NULL)
		{
		if(pReadHit->NumHits != 1 || pReadHit->HitLoci.Hit.FlgSplice == 0)
			continue;
		pCurHit = pReadHit;
		NumSpliceJuncs += 1;
		}
	if(NumSpliceJuncs > 1)
		{
		// allocate for this number of splice junctions, then sort and dedupe
		pSegJuncts = new tsSegJuncts[NumSpliceJuncs];
		if(pSegJuncts == NULL)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: unable to allocate memory (%d bytes) for splice junction processing",NumSpliceJuncs * sizeof(tsSegJuncts));
			Reset(false);
			return(eBSFerrMem);
			}
		pJunct = pSegJuncts;
		pReadHit = NULL;
		while((pReadHit = IterReads(pReadHit))!=NULL)
			{
			if(pReadHit->NumHits != 1 || pReadHit->HitLoci.Hit.FlgSplice == 0)
				continue;
			pJunct->pRead = pReadHit;
			pJunct->ChromID = pReadHit->HitLoci.Hit.Seg[0].ChromID;
			pJunct->Starts = AdjEndLoci(&pReadHit->HitLoci.Hit.Seg[0]);
			pJunct->Ends = AdjStartLoci(&pReadHit->HitLoci.Hit.Seg[1]);
			pJunct->Cnt = 1;
			pJunct += 1;
			}
		// now sort ascending by chrom, start, end
		mtqsort.qsort(pSegJuncts,NumSpliceJuncs,sizeof(tsSegJuncts),SortSegJuncts);
		// iterate and determine multiplicity of junctions
		pJunct = pSegJuncts;
		pNxtJunct = &pSegJuncts[1];
		for(Idx = 0; Idx < (NumSpliceJuncs-1); Idx++,pJunct++,pNxtJunct++)
			{
			if(pJunct->ChromID == pNxtJunct->ChromID &&
			   (pJunct->Starts <= (pNxtJunct->Starts + 3) && pJunct->Starts >= (pNxtJunct->Starts - 3)) &&
			   (pJunct->Ends <= (pNxtJunct->Ends + 3) && pJunct->Ends >= (pNxtJunct->Ends - 3)))
				{
				pJunct->pRead->HitLoci.Hit.FlgNonOrphan = 1;
				pNxtJunct->pRead->HitLoci.Hit.FlgNonOrphan = 1;
				}
			}
		// junctions not supported by at least two reads are to be treated as simply unaligned
		pJunct = pSegJuncts;
		for(Idx = 0; Idx < NumSpliceJuncs; Idx++,pJunct++)
			{
			if(pJunct->pRead->HitLoci.Hit.FlgNonOrphan != 1)
				{
				pJunct->pRead->NumHits = 0;	// treat as unaligned
				pJunct->pRead->LowHitInstances = 0;
				NumSpliceNotAccepted += 1;
				}
			else
				NumSpliceAccepted += 1;
			}
		delete pSegJuncts;
		}
	else
		if(pCurHit != NULL)
			{
			pCurHit->NumHits = 0;	// treat as unaligned
			pCurHit->LowHitInstances = 0;
			}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"From %d reads with putative splice sites %d orphans were removed", NumSpliceJuncs,NumSpliceNotAccepted);
	}
return(eBSFSuccess);
}

int
RemoveOrphanMicroInDels(int microInDelLen)
{
int Idx;
int NumInDelJuncs = 0;
int	NumInDelsAccepted = 0;
int	NumInDelsNotAccepted = 0;

tsSegJuncts *pSegJuncts = NULL;
tsSegJuncts *pJunct;
tsSegJuncts *pNxtJunct;
tsReadHit *pCurHit = NULL;
tsReadHit *pReadHit = NULL;

if(microInDelLen > 0)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Filtering out any orphan microIndel reads");

	while((pReadHit = IterReads(pReadHit))!=NULL)
		{
		if(pReadHit->NumHits != 1 || pReadHit->HitLoci.Hit.FlgInDel == 0)
			continue;
		pCurHit = pReadHit;
		NumInDelJuncs += 1;
		}
	if(NumInDelJuncs > 1)
		{
		// allocate for this number of InDel junctions, then sort and dedupe
		pSegJuncts = new tsSegJuncts[NumInDelJuncs];
		if(pSegJuncts == NULL)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: unable to allocate memory (%d bytes) for microInDel processing",NumInDelJuncs * sizeof(tsSegJuncts));
			Reset(false);
			return(eBSFerrMem);
			}
		pJunct = pSegJuncts;
		pReadHit = NULL;
		while((pReadHit = IterReads(pReadHit))!=NULL)
			{
			if(pReadHit->NumHits != 1 || pReadHit->HitLoci.Hit.FlgInDel == 0)
				continue;
			pJunct->pRead = pReadHit;
			pJunct->ChromID = pReadHit->HitLoci.Hit.Seg[0].ChromID;
			pJunct->Starts = AdjEndLoci(&pReadHit->HitLoci.Hit.Seg[0]);
			pJunct->Ends = AdjStartLoci(&pReadHit->HitLoci.Hit.Seg[1]);
			pJunct->Cnt = 1;
			pJunct += 1;
			}
		// now sort ascending by chrom, start, end
		mtqsort.qsort(pSegJuncts,NumInDelJuncs,sizeof(tsSegJuncts),SortSegJuncts);
		// iterate and determine multiplicity of junctions
		pJunct = pSegJuncts;
		pNxtJunct = &pSegJuncts[1];
		for(Idx = 0; Idx < (NumInDelJuncs-1); Idx++,pJunct++,pNxtJunct++)
			{
			if(pJunct->ChromID == pNxtJunct->ChromID &&
			   (pJunct->Starts <= (pNxtJunct->Starts + 3) && pJunct->Starts >= (pNxtJunct->Starts - 3)) &&
			   (pJunct->Ends <= (pNxtJunct->Ends + 3) && pJunct->Ends >= (pNxtJunct->Ends - 3)))				{
				pJunct->pRead->HitLoci.Hit.FlgNonOrphan = 1;
				pNxtJunct->pRead->HitLoci.Hit.FlgNonOrphan = 1;
				}
			}
		// InDels not supported by at least two reads are to be treated as simply unaligned
		pJunct = pSegJuncts;
		for(Idx = 0; Idx < NumInDelJuncs; Idx++,pJunct++)
			{
			if(pJunct->pRead->HitLoci.Hit.FlgNonOrphan != 1)
				{
				pJunct->pRead->NumHits = 0;	// treat as unaligned
				pJunct->pRead->LowHitInstances = 0;
				NumInDelsNotAccepted += 1;
				}
			else
				NumInDelsAccepted += 1;
			}
		delete pSegJuncts;
		}
	else
		if(pCurHit != NULL)
			{
			pCurHit->NumHits = 0;	// treat as unaligned
			pCurHit->LowHitInstances = 0;
			}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"From %d reads with putative microIndels %d orphans were removed", NumInDelJuncs,NumInDelsNotAccepted);
	}
return(eBSFSuccess);
}

bool					// true if chrom is accepted, false if chrom not accepted
AcceptThisChromID(UINT32 ChromID)
{
static tBSFEntryID PrevTargEntry = -1;
static tBSFEntryID ExcludeTargEntryID = -1;
int IncChromIdx;
int ExclChromIdx;
char szChromName[128];
bool bProcChrom = false;
int MatchesFiltOut = 0;

if(m_NumExcludeChroms || m_NumIncludeChroms)
	return(false);

#ifdef _WIN32
RegexpMatch mc;
#else
regmatch_t mc;
int RegErr;					// regular expression parsing error
char szRegErr[128];			// to hold RegErr as textual representation ==> regerror();
#endif

if(ChromID != (UINT32)PrevTargEntry)
	{
	m_pSfxArray->GetIdentName(ChromID,sizeof(szChromName),szChromName);
	PrevTargEntry = ChromID;
	ExcludeTargEntryID = (tBSFEntryID)-1;
	}
else
	{
	if(ChromID == (UINT32)ExcludeTargEntryID)
		return(false);

	// check if to be excluded
	bProcChrom = true;
	for(ExclChromIdx = 0; ExclChromIdx < m_NumExcludeChroms; ExclChromIdx++)
		{
#ifdef _WIN32
		if(m_ExcludeChromsRE[ExclChromIdx]->Match(szChromName,&mc))
#else
		if(!regexec(&m_ExcludeChromsRE[ExclChromIdx],szChromName,1,&mc,0))
#endif
			{
			bProcChrom = false;
			break;
			}
		}

	// to be included?
	if(bProcChrom && m_NumIncludeChroms > 0)
		{
		bProcChrom = false;
		for(IncChromIdx = 0; IncChromIdx < m_NumIncludeChroms; IncChromIdx++)
			{
#ifdef _WIN32
			if(m_IncludeChromsRE[IncChromIdx]->Match(szChromName,&mc))
#else
			if(!regexec(&m_IncludeChromsRE[IncChromIdx],szChromName,1,&mc,0))
#endif
				{
				bProcChrom = true;
				break;
				}
			}
		}


	if(!bProcChrom)
		{
		ExcludeTargEntryID = ChromID;
		return(false);
		}
	else
		ExcludeTargEntryID = -1;
	}
return(true);
}

int				// > 0: acceped with return value the fragment (insert) size, -1: not paired end alignment, -2: PE alignment to filtered chrom, -3: fragment < PairMinLen, -4: fragment > PairMaxLen
AcceptProvPE(int PairMinLen,  // only accept paired reads with a combined sequence length of at least this
			 int PairMaxLen,  // only accept paired reads with a combined sequence length of no more than this
			 tsReadHit *pFwdReadHit,
			 tsReadHit *pRevReadHit)
{
int SeqFragLen;

UINT32 FwdChrom;
UINT8 FwdStrand;
UINT32 FwdProbeHitLen;
UINT32 FwdStartLoci;
UINT32 FwdEndLoci;

UINT32 RevChrom;
UINT8 RevStrand;
UINT32 RevProbeHitLen;
UINT32 RevStartLoci;
UINT32 RevEndLoci;

if(!(pFwdReadHit->NumHits == 1 && pRevReadHit->NumHits == 1))
	return(-1);


FwdChrom = pFwdReadHit->HitLoci.Hit.Seg[0].ChromID;
FwdStrand = pFwdReadHit->HitLoci.Hit.Seg[0].Strand;
FwdProbeHitLen = AdjHitLen(&pFwdReadHit->HitLoci.Hit.Seg[0]);
FwdStartLoci = AdjStartLoci(&pFwdReadHit->HitLoci.Hit.Seg[0]);
if(pFwdReadHit->HitLoci.Hit.FlgInDel || pFwdReadHit->HitLoci.Hit.FlgSplice)
	{
	FwdEndLoci = AdjEndLoci(&pFwdReadHit->HitLoci.Hit.Seg[1]);
	FwdProbeHitLen += AdjHitLen(&pFwdReadHit->HitLoci.Hit.Seg[1]);
	}
else
	FwdEndLoci = AdjEndLoci(&pFwdReadHit->HitLoci.Hit.Seg[0]);
RevChrom = pRevReadHit->HitLoci.Hit.Seg[0].ChromID;
RevStrand = pRevReadHit->HitLoci.Hit.Seg[0].Strand;
RevProbeHitLen = AdjHitLen(&pRevReadHit->HitLoci.Hit.Seg[0]);
RevStartLoci = AdjStartLoci(&pRevReadHit->HitLoci.Hit.Seg[0]);
if(pRevReadHit->HitLoci.Hit.FlgInDel || pRevReadHit->HitLoci.Hit.FlgSplice)
	{
	RevEndLoci = AdjEndLoci(&pRevReadHit->HitLoci.Hit.Seg[1]);
	RevProbeHitLen += AdjHitLen(&pRevReadHit->HitLoci.Hit.Seg[1]);
	}
else
	RevEndLoci = AdjEndLoci(&pRevReadHit->HitLoci.Hit.Seg[0]);

if(FwdChrom != RevChrom)				// pair ends must be on same chromsome
	return(-1);

if(FwdStrand == RevStrand)				// and complementary strands
	return(-1);

// ensure chrom is to be retained
if(!AcceptThisChromID(FwdChrom))
	return(-2);							// can't accept because alignments to filtered chromsome


// accepted chrom and strand
// now check if distance also accepted
// if fwd is on '+' then distance = RevEndLoci - FwdStartLoci
// if fwd is on '-' then distance = RevEndLoci - FwdStartLoci
if(FwdStrand == '+')
	SeqFragLen = (int)RevEndLoci - (int)FwdStartLoci;
else
	SeqFragLen = (int)FwdEndLoci - (int)RevStartLoci;

if(SeqFragLen < PairMinLen)	
	return(-3);
if(SeqFragLen > PairMaxLen)
	return(-4);

// can accept
return(SeqFragLen);
}

//ProcessPairedEnds
// Matches read pairs and if one read is aligned but partner is not due to mailtihit loci then
// attempts to find a unique loci for that multihit read within the expected approximate pair distance range
int
ProcessPairedEnds(etPEproc PEproc, // paired reads alignment processing mode
				  int MinEditDist, // accepted alignments must be at least this Hamming away from other putative alignments
				  int PairMinLen,  // only accept paired reads with a combined sequence length of at least this
				  int PairMaxLen,  // only accept paired reads with a combined sequence length of no more than this
				  int MaxSubs)	   // aligned reads can have at most this many subs
{
int Rslt;
#ifdef USEOLDCODE
char szChromName[128];
#endif
UINT32 PrevChromID;
int SeqFragLen;
UINT32 PairReadIdx;
tsReadHit *pFwdReadHit;
tsReadHit *pRevReadHit;

int NumPaired = 0;
int NegPairs = 0;
int UnderLenPairs = 0;
int OverLenPairs = 0;
int LongestSeqFragLen = 0;
int OverPairMaxLen = 0;

bool bPartnerPaired;
int PartnerUnpaired = 0;
int PartnerPaired = 0;
int UnalignedPairs = 0;
int UniquePairCnt = 0;
int NumFilteredByChrom = 0;

int AcceptedNumPaired = 0;

UINT8 ReadSeq[2048];

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Generating paired reads index over %d paired reads", m_NumReadsLoaded/2);
etReadsSortMode PrevSort = m_CurReadsSortMode;
SortReadHits(eRSMPairReadID,false);

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Iterating putative paired reads for orphan ends");

if(m_pLenDist != NULL)
	{
	delete m_pLenDist;
	m_pLenDist = NULL;
	}
if((m_pLenDist = new int[cPairMaxLen+1])==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to allocate %d bytes memory for paired read sequence length distributions",
								sizeof(int) * (cPairMaxLen+1));
	Reset(false);
	return(eBSFerrMem);
	}
memset(m_pLenDist,0,sizeof(int) * (cPairMaxLen+1));

tsHitLoci HitLoci;
UINT8 *pHitSeq;
UINT8 *pSeq;
UINT32 SeqIdx;
bool b3primeExtend;
bool bAntisense;

m_szLineBuffIdx = 0;
PrevChromID = -1;
m_PrevSAMTargEntry = 0;
for(PairReadIdx=0; PairReadIdx < m_NumReadsLoaded;PairReadIdx+=2)
	{
	pFwdReadHit = m_ppReadHitsIdx[PairReadIdx];
	pRevReadHit = m_ppReadHitsIdx[PairReadIdx+1];

	// even if both ends have been uniquely aligned it could be that these alignments can't be accepted - may be to different chroms, or overlength etc
	if(pFwdReadHit->NumHits == 1 && pRevReadHit->NumHits == 1)
		{
		SeqFragLen = AcceptProvPE(PairMinLen,PairMaxLen,pFwdReadHit,pRevReadHit);	// would these be accepted as a PE alignment?
		if(SeqFragLen > 0)
			{
			// this paired end alignment has been accepted
			LongestSeqFragLen = max(LongestSeqFragLen,SeqFragLen);
			m_pLenDist[SeqFragLen] += 1;
			AcceptedNumPaired += 1;
			continue;
			}

		// unable to accept, try finding a better pairing using one of the uniquely aligned ends as an anchor
		switch(SeqFragLen) {
			case -2:			// both ends were to filtered chrom so can't use either end as an anchor
				NumFilteredByChrom += 1;
				pFwdReadHit->NumHits = 0;
				pRevReadHit->NumHits = 0;
				pFwdReadHit->LowHitInstances = 0;
				pRevReadHit->LowHitInstances = 0;
				continue;
			default:			// worth exploring for alignments using either 5' or 3' as an anchor 
				break;
			}
		// first try using the 5' alignment as an anchor, if that doesn't provide a pair then try using the 3' as the anchor
		bPartnerPaired = false;
		pHitSeq = &pRevReadHit->Read[pRevReadHit->DescrLen+1];
		pSeq = ReadSeq;
		for(SeqIdx = 0; SeqIdx < pRevReadHit->ReadLen; SeqIdx++)
			*pSeq++ = *pHitSeq++ & 0x07;

		// AlignPartnerRead
		// Have been able to unquely align one read out of a pair, now need to align the other read
		//		if PE1 was to sense strand then expect PE2 on the antisense strand downstream towards the 3' end of targeted chrom:		b3primeExtend=true,bAntisense=true
		//		if PE1 was to antisense strand then expect PE2 on the sense strand upstream towards the 5' end of targeted chrom:		b3primeExtend=false,bAntisense=false
		b3primeExtend = pFwdReadHit->HitLoci.Hit.Seg[0].Strand == '+' ? true : false;
		bAntisense = pFwdReadHit->HitLoci.Hit.Seg[0].Strand == '+' ? true : false;

		Rslt = m_pSfxArray->AlignPairedRead(b3primeExtend,bAntisense,
					pFwdReadHit->HitLoci.Hit.Seg[0].ChromID,	  // accepted aligned read was on this chromosome
					AdjStartLoci(&pFwdReadHit->HitLoci.Hit.Seg[0]),	  // accepted aligned read started at this loci
					AdjEndLoci(&pFwdReadHit->HitLoci.Hit.Seg[0]),		  // and ending at this loci
					PairMinLen,			// expecting partner to align at least this distance away from accepted aligned read
					PairMaxLen,			// but no more than this distance away
					MaxSubs >= 0 ? MaxSubs : pRevReadHit->ReadLen/10,					// any accepted alignment can have at most this many mismatches
					MinEditDist,					// and must be at least this Hamming away from the next best putative alignment
					pRevReadHit->ReadLen,		  // length of read excluding any eBaseEOS
					ReadSeq,	  // pts to 5' start of read sequence
					&HitLoci);	  // where to return any paired read alignment loci
		if(Rslt == 1)
			{
			pRevReadHit->HitLoci.Hit = HitLoci;
			pRevReadHit->NumHits = 1;
			pRevReadHit->LowMMCnt = HitLoci.Seg[0].Mismatches;
			pRevReadHit->LowHitInstances = 1;
			bPartnerPaired = true;
			}
		else  // need to try using the 3' end as the anchor
			{
			pHitSeq = &pFwdReadHit->Read[pFwdReadHit->DescrLen+1];
			pSeq = ReadSeq;
			for(SeqIdx = 0; SeqIdx < pFwdReadHit->ReadLen; SeqIdx++)
				*pSeq++ = *pHitSeq++ & 0x07;
			// AlignPartnerRead
			// Have been able to unquely align one read out of a pair, now need to align the other read
			//		if PE2 was to sense strand then expect PE1 on the antisense strand downstream towards the 3' end of targeted chrom:		b3primeExtend=true,bAntisense=true
			//		if PE2 was to antisense strand then expect PE1 on the sense strand upstream towards the 5' end of targeted chrom:		b3primeExtend=false,bAntisense=false
			b3primeExtend = pRevReadHit->HitLoci.Hit.Seg[0].Strand == '+' ? true : false;
			bAntisense = pRevReadHit->HitLoci.Hit.Seg[0].Strand == '+' ? true : false;

			Rslt = m_pSfxArray->AlignPairedRead(b3primeExtend,bAntisense,
						pRevReadHit->HitLoci.Hit.Seg[0].ChromID,	  // accepted aligned read was on this chromosome
						AdjStartLoci(&pRevReadHit->HitLoci.Hit.Seg[0]),	  // accepted aligned read started at this loci
						AdjEndLoci(&pRevReadHit->HitLoci.Hit.Seg[0]),		  // and ending at this loci
						PairMinLen,			// expecting partner to align at least this distance away from accepted aligned read
						PairMaxLen,		// but no more than this distance away
						MaxSubs >= 0 ? MaxSubs : pFwdReadHit->ReadLen/10,			// any accepted alignment can have at most this many mismatches
						MinEditDist,					// and must be at least this Hamming away from the next best putative alignment
						pFwdReadHit->ReadLen,			// length of read excluding any eBaseEOS
						ReadSeq,	  // pts to 5' start of read sequence
						&HitLoci);	  // where to return any paired read alignment loci
			if(Rslt == 1)
				{
				pFwdReadHit->HitLoci.Hit = HitLoci;
				pFwdReadHit->LowMMCnt = HitLoci.Seg[0].Mismatches;
				pFwdReadHit->NumHits = 1;
				pFwdReadHit->LowHitInstances = 1;
				bPartnerPaired = true;
				}
			}
		if(bPartnerPaired == true)
			{
			SeqFragLen = AcceptProvPE(PairMinLen,PairMaxLen,pFwdReadHit,pRevReadHit);	// would these be accepted as a PE alignment?
			if(SeqFragLen > 0)
				{
				// this paired end alignment has been accepted
				LongestSeqFragLen = max(LongestSeqFragLen,SeqFragLen);
				m_pLenDist[SeqFragLen] += 1;
				AcceptedNumPaired += 1;
				continue;
				}
			}

		// can't find an accepted paired end alignment using anchors
		PartnerUnpaired += 1;
		pFwdReadHit->NumHits = 0;
		pRevReadHit->NumHits = 0;
		pFwdReadHit->LowHitInstances = 0;
		pRevReadHit->LowHitInstances = 0;
		continue;
		}

	if(PEproc == ePEorphan)		// try and recovered orphaned ends?
		{
		// if aligned on fwd read but unable to uniquely align with the partner read on rev...
		bPartnerPaired = false;
		if(pFwdReadHit->NumHits == 1 && pRevReadHit->LowHitInstances > 1)
			{
			PartnerUnpaired += 1;
			pHitSeq = &pRevReadHit->Read[pRevReadHit->DescrLen+1];
			pSeq = ReadSeq;
			for(SeqIdx = 0; SeqIdx < pRevReadHit->ReadLen; SeqIdx++)
				*pSeq++ = *pHitSeq++ & 0x07;
					// AlignPartnerRead
		// Have been able to unquely align one read out of a pair, now need to align the other read
		//		if PE1 was to sense strand then expect PE2 on the antisense strand downstream towards the 3' end of targeted chrom:		b3primeExtend=true,bAntisense=true
		//		if PE1 was to antisense strand then expect PE2 on the sense strand upstream towards the 5' end of targeted chrom:		b3primeExtend=false,bAntisense=false
		b3primeExtend = pFwdReadHit->HitLoci.Hit.Seg[0].Strand == '+' ? true : false;
		bAntisense = pFwdReadHit->HitLoci.Hit.Seg[0].Strand == '+' ? true : false;

		Rslt = m_pSfxArray->AlignPairedRead(b3primeExtend,bAntisense,
					pFwdReadHit->HitLoci.Hit.Seg[0].ChromID,	  // accepted aligned read was on this chromosome
					AdjStartLoci(&pFwdReadHit->HitLoci.Hit.Seg[0]),	  // accepted aligned read started at this loci
					AdjEndLoci(&pFwdReadHit->HitLoci.Hit.Seg[0]),		  // and ending at this loci
					PairMinLen,			// expecting partner to align at least this distance away from accepted aligned read
					PairMaxLen,			// but no more than this distance away
					MaxSubs >= 0 ? MaxSubs : pRevReadHit->ReadLen/10,					// any accepted alignment can have at most this many mismatches
					MinEditDist,					// and must be at least this Hamming away from the next best putative alignment
					pRevReadHit->ReadLen,		  // length of read excluding any eBaseEOS
					ReadSeq,	  // pts to 5' start of read sequence
					&HitLoci);	  // where to return any paired read alignment loci
			if(Rslt == 1)
				{
				pRevReadHit->HitLoci.Hit = HitLoci;
				pRevReadHit->NumHits = 1;
				pRevReadHit->LowMMCnt = HitLoci.Seg[0].Mismatches;
				pRevReadHit->LowHitInstances = 1;
				PartnerPaired += 1;
				bPartnerPaired = true;
				}
			}
		else
			{
			// if aligned on rev read but unable to on fwd...
			if(pFwdReadHit->LowHitInstances > 1 && pRevReadHit->NumHits == 1)
				{
				PartnerUnpaired += 1;
				pHitSeq = &pFwdReadHit->Read[pFwdReadHit->DescrLen+1];
				pSeq = ReadSeq;
				for(SeqIdx = 0; SeqIdx < pFwdReadHit->ReadLen; SeqIdx++)
					*pSeq++ = *pHitSeq++ & 0x07;
							// AlignPartnerRead
			// Have been able to unquely align one read out of a pair, now need to align the other read
			//		if PE2 was to sense strand then expect PE1 on the antisense strand downstream towards the 3' end of targeted chrom:		b3primeExtend=true,bAntisense=true
			//		if PE2 was to antisense strand then expect PE1 on the sense strand upstream towards the 5' end of targeted chrom:		b3primeExtend=false,bAntisense=false
			b3primeExtend = pRevReadHit->HitLoci.Hit.Seg[0].Strand == '+' ? true : false;
			bAntisense = pRevReadHit->HitLoci.Hit.Seg[0].Strand == '+' ? true : false;

			Rslt = m_pSfxArray->AlignPairedRead(b3primeExtend,bAntisense,
						pRevReadHit->HitLoci.Hit.Seg[0].ChromID,	  // accepted aligned read was on this chromosome
						AdjStartLoci(&pRevReadHit->HitLoci.Hit.Seg[0]),	  // accepted aligned read started at this loci
						AdjEndLoci(&pRevReadHit->HitLoci.Hit.Seg[0]),		  // and ending at this loci
						PairMinLen,			// expecting partner to align at least this distance away from accepted aligned read
						PairMaxLen,		// but no more than this distance away
						MaxSubs >= 0 ? MaxSubs : pFwdReadHit->ReadLen/10,			// any accepted alignment can have at most this many mismatches
						MinEditDist,					// and must be at least this Hamming away from the next best putative alignment
						pFwdReadHit->ReadLen,			// length of read excluding any eBaseEOS
						ReadSeq,	  // pts to 5' start of read sequence
						&HitLoci);	  // where to return any paired read alignment loci
				if(Rslt == 1)
					{
					pFwdReadHit->HitLoci.Hit = HitLoci;
					pFwdReadHit->LowMMCnt = HitLoci.Seg[0].Mismatches;
					pFwdReadHit->NumHits = 1;
					pFwdReadHit->LowHitInstances = 1;
					PartnerPaired += 1;
					bPartnerPaired = true;
					}
				}
			}
		}

	
	if(pFwdReadHit->NumHits == 1 && pRevReadHit->NumHits == 1)	// if provisionally accepted paired ends
		{
		SeqFragLen = AcceptProvPE(PairMinLen,PairMaxLen,pFwdReadHit,pRevReadHit);
		if(SeqFragLen <= 0)			// negative if unable to accept this paired end alignment
			{
			switch(SeqFragLen) {
				case -2:
					NumFilteredByChrom += 1;
					break;
				case -3:
					UnderLenPairs += 1;
					break;
				case -4:
					OverLenPairs += 1;
					break;
				default:
					break;
				}
			pFwdReadHit->NumHits = 0;
			pRevReadHit->NumHits = 0;
			pFwdReadHit->LowHitInstances = 0;
			pRevReadHit->LowHitInstances = 0;
			continue;
			}

		// this paired end alignment has been accepted
		LongestSeqFragLen = max(LongestSeqFragLen,SeqFragLen);
		m_pLenDist[SeqFragLen] += 1;
		AcceptedNumPaired += 1;
		continue;
		}

	// if neither end was uniquely aligned then 
	if(!(pFwdReadHit->NumHits == 1 || pRevReadHit->NumHits == 1))
		UnalignedPairs += 1;

	pFwdReadHit->NumHits = 0;
	pRevReadHit->NumHits = 0;
	pFwdReadHit->LowHitInstances = 0;
	pRevReadHit->LowHitInstances = 0;
	}

gDiagnostics.DiagOut(eDLInfo,gszProcName,"From %d putative pairs there were %d accepted (%d from recovered orphans)",
					 m_NumReadsLoaded/2,AcceptedNumPaired,PartnerPaired);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"%d putative pairs unrecoverable as still orphan partnered",PartnerUnpaired - PartnerPaired);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"%d under length, %d over length pairs not accepted",UnderLenPairs,OverLenPairs);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"%d aligned pairs filtered out by chromosome",NumFilteredByChrom);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"%d putative pairs have neither end uniquely aligned",UnalignedPairs);

if(m_hStatsFile != -1)
	{
	char szLineBuff[cMaxReadLen*2];
	int BuffIdx = 0;
	for(PairReadIdx = 0; PairReadIdx <= (UINT32)LongestSeqFragLen; PairReadIdx++)
		{
		BuffIdx += sprintf(&szLineBuff[BuffIdx],"%d,%d\n",PairReadIdx,m_pLenDist[PairReadIdx]);
		if(BuffIdx + 100 > sizeof(szLineBuff))
			{
			CUtility::SafeWrite(m_hStatsFile,szLineBuff,BuffIdx);
			BuffIdx = 0;
			}
		}
	if(BuffIdx)
		{
		CUtility::SafeWrite(m_hStatsFile,szLineBuff,BuffIdx);
		BuffIdx = 0;
		}
	}
SortReadHits(PrevSort,false);
return(eBSFSuccess);
}


int
ReportAlignStats(void)
{
char szChromName[128];
int NumUniques = 0;
int NumPlusHits = 0;
int NumNoMatches = 0;
int NumMultiMatches = 0;
int NumHamming = 0;
tsReadHit *pReadHit = NULL;
bool bSimReads = false;
UINT32 NumReads1EdgeAligned = 0;
UINT32 NumReads2EdgeAligned = 0;
UINT32 NumReadsMisaligned = 0;
UINT32 NumIndels = 0;
UINT32 NumSpliced = 0;
UINT32 PrevTargEntry = 0;
UINT32 NumTrimmed = 0;

while((pReadHit = IterReads(pReadHit))!=NULL)
	{
	switch(pReadHit->NumHits) {
		case 0:
			if(pReadHit->LowHitInstances == 0) // no accepted hits simply because of no hit instances?
				NumNoMatches += 1;
			else
				{
				if(pReadHit->LowHitInstances > 1) // no accepted hits because of too many hit instances?
					NumMultiMatches+= 1;
				else
					NumHamming += 1;		  // only one hit instance, not accepted because of insufficient Hamming differential
				}
			break;

		case 1:								  // accepted hit, accumulate strand count
			NumUniques += 1;
			if(pReadHit->HitLoci.Hit.Seg[0].Strand == '+')
				NumPlusHits += 1;
			if(pReadHit->HitLoci.Hit.FlgInDel)
				NumIndels += 1;
			if(pReadHit->HitLoci.Hit.FlgSplice)
				NumSpliced += 1;
			if(pReadHit->HitLoci.FlagTR)
				NumTrimmed += 1;
			pReadHit->HitLoci.FlagIA = 0;
			pReadHit->HitLoci.FlagCA = 0;
			if(bSimReads || NumUniques == 1)				  // check if simulated reads containing loci
				{
				bool bRandReadSeq;
				int x1;
				char szxChrom[100];
				char szSimType[100];
				int xStart;
				int xEnd;
				int xLen;
				char xStrand;
				int xErrs;
				int Its;
				bRandReadSeq = false;
				Its = sscanf((char *)pReadHit->Read,"%[^|]|usimreads|%d|%[^|]|%d|%d|%d|%c|%d",szSimType,&x1,szxChrom,&xStart,&xEnd,&xLen,&xStrand,&xErrs);
				if(Its >= 6)
					{
					bSimReads = true;
					if(!stricmp(szSimType,"lcl"))
						bRandReadSeq = false;
					else
						bRandReadSeq = true;
					}
				else
					bSimReads = false;


				if(pReadHit->HitLoci.Hit.Seg[0].ChromID != (UINT32)PrevTargEntry)
					{
					m_pSfxArray->GetIdentName(pReadHit->HitLoci.Hit.Seg[0].ChromID,sizeof(szChromName),szChromName);
					PrevTargEntry = pReadHit->HitLoci.Hit.Seg[0].ChromID;
					}

				if(!bSimReads)
					break;

				int LeftOfs;
				int RightOfs;

				// the determination as to if a read has been correctly aligned is a little crude but will generally be correct
				// the crudeness arises because a read may not have been segmented during the alignment process although it originated from a microInDel or
				// splice junction so only one of the edges will be correct. This could have been because there were insufficient mismatches in a flank
				// to have been worth the cost of exploring as a potential segmented alignment.
				// Another complication is auto-edge trimming resulting in alignments with edges not coincident with the source simulated read loci.
				// The flow here is to classify the alignments into three groups:
				// a)	both edges are coincident with the source simulated reads edge loci
				// b)   one edge only is coincident
				// c)   neither edge is coincident
				LeftOfs = (int32)pReadHit->HitLoci.Hit.Seg[0].MatchLoci;
				if(pReadHit->HitLoci.FlagSegs)
					RightOfs = (int32)pReadHit->HitLoci.Hit.Seg[1].MatchLoci + pReadHit->HitLoci.Hit.Seg[1].MatchLen - 1;
				else
					RightOfs = LeftOfs + pReadHit->HitLoci.Hit.Seg[0].MatchLen - 1;

				if(LeftOfs == xStart || RightOfs == xEnd)
					{
					if(LeftOfs != xStart || RightOfs != xEnd)
						NumReads1EdgeAligned += 1;
					else
						NumReads2EdgeAligned += 1;
					pReadHit->HitLoci.FlagCA = 1;
					}
				else
					{
					NumReadsMisaligned += 1;
					pReadHit->HitLoci.FlagIA = 1;
					}
				}

			break;

		default:							 // these will be the deduped (NumHits == 3) or trim eliminated reads (NumHits == 4) or orphan splice junctions (NumHits == 5)
			break;
		}
	}

gDiagnostics.DiagOut(eDLInfo,gszProcName,"From %d source reads there are %d accepted aligned reads, %d on '+' strand, %d on '-' strand", m_NumReadsLoaded,NumUniques,NumPlusHits,NumUniques-NumPlusHits);
if(bSimReads)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"There are %d (%d 2 edge, %d 1 edge) high confidence aligned simulated reads with %d misaligned",NumReads2EdgeAligned + NumReads1EdgeAligned,NumReads2EdgeAligned,NumReads1EdgeAligned,NumReadsMisaligned);
	}
if(NumIndels)
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Of the accepted aligned reads, %d contained microInDels", NumIndels);
if(NumSpliced)
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Of the accepted aligned reads, %d contained splice junctions", NumSpliced);

gDiagnostics.DiagOut(eDLInfo,gszProcName,"A further %d multiloci aligned reads could not accepted as hits because they were unresolvable",NumMultiMatches);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"A further %d aligned reads were not accepted as hits because of insufficient Hamming edit distance",NumHamming);

gDiagnostics.DiagOut(eDLInfo,gszProcName,"A further %d '+' and %d '-' strand aligned reads not accepted because of flank trimming (%d were trimmed) requirements",m_ElimPlusTrimed,m_ElimMinusTrimed,NumTrimmed);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Unable to align %d source reads of which %d contained excessive number of indeterminate 'N' bases",NumNoMatches,m_NumSloughedNs);
return(eBSFSuccess);
}

int
ReportNoneAligned(void)
{
int ReadLen;
int SeqOfs;
int	NxtFastaCol;
int NumCols;
tsReadHit *pReadHit;
UINT32 SeqIdx;
etSeqBase Sequence[cMaxFastQSeqLen+1];	// to hold sequence (sans quality scores) for current read
UINT8 *pSeqVal;
etSeqBase *pSeq;

int NumNoMatches = 0;
int NumMultiMatches = 0;
int NumHamming = 0;

int LineLen = 0;
// user interested in the non-alignable reads?
// these only include those which had no alignment at all
if(m_hNoneAlignFile != -1)
	{
	pReadHit = NULL;
	while((pReadHit = IterSortedReads(pReadHit))!=NULL)
		{
		if(!(pReadHit->NumHits == 0 && pReadHit->LowHitInstances == 0))
			continue;
		ReadLen = pReadHit->ReadLen;
		pSeqVal = &pReadHit->Read[pReadHit->DescrLen+1];
		pSeq = Sequence;
		for(SeqIdx = 0; SeqIdx < pReadHit->ReadLen; SeqIdx++,pSeq++,pSeqVal++)
			*pSeq = (*pSeqVal & 0x07);

		LineLen += sprintf(&m_pszLineBuff[LineLen],">lcl|nonealign %s %d|%d|%d\n",pReadHit->Read,pReadHit->ReadID,pReadHit->NumReads,pReadHit->ReadLen);
		if((LineLen + 5000) > cAllocLineBuffSize)
			{
			CUtility::SafeWrite(m_hNoneAlignFile,m_pszLineBuff,LineLen);
			LineLen = 0;
			}
		SeqOfs = 0;
		NxtFastaCol = 0;
		while(ReadLen)
			{
			NumCols = ReadLen > 70 ? 70 : ReadLen;
			if((NumCols + NxtFastaCol) > 70)
				NumCols = 70 - NxtFastaCol;
			CSeqTrans::MapSeq2Ascii(&Sequence[SeqOfs],NumCols,&m_pszLineBuff[LineLen]);
			LineLen += NumCols;
			NxtFastaCol += NumCols;
			SeqOfs += NumCols;
			ReadLen -= NumCols;
			if(!ReadLen || NxtFastaCol >= 70)
				{
				LineLen += sprintf(&m_pszLineBuff[LineLen],"\n");
				NxtFastaCol = 0;
				}

			if((LineLen + 5000) > cAllocLineBuffSize)
				{
				CUtility::SafeWrite(m_hNoneAlignFile,m_pszLineBuff,LineLen);
				LineLen = 0;
				}
			}
		}
	if(LineLen)
		CUtility::SafeWrite(m_hNoneAlignFile,m_pszLineBuff,LineLen);
#ifdef _WIN32
	_commit(m_hNoneAlignFile);
#else
	fsync(m_hNoneAlignFile);
#endif
	close(m_hNoneAlignFile);
	m_hNoneAlignFile = -1;
	}
return(eBSFSuccess);
}

int
ReportMultiAlign(void)
{
int ReadLen;
int SeqOfs;
int	NxtFastaCol;
int NumCols;
tsReadHit *pReadHit;
UINT32 SeqIdx;
etSeqBase Sequence[cMaxFastQSeqLen+1];	// to hold sequence (sans quality scores) for current read
UINT8 *pSeqVal;
etSeqBase *pSeq;
int LineLen = 0;

if(m_hMultiAlignFile != -1)
	{
	pReadHit = NULL;
	while((pReadHit = IterSortedReads(pReadHit))!=NULL)
		{
		if(!(pReadHit->NumHits == 0 && pReadHit->LowHitInstances > 1))
			continue;

		ReadLen = pReadHit->ReadLen;
		pSeqVal = &pReadHit->Read[pReadHit->DescrLen+1];
		pSeq = Sequence;
		for(SeqIdx = 0; SeqIdx < pReadHit->ReadLen; SeqIdx++,pSeq++,pSeqVal++)
			*pSeq = (*pSeqVal & 0x07);

		LineLen += sprintf(&m_pszLineBuff[LineLen],">lcl|multialign %s %d|%d|%d\n",pReadHit->Read,pReadHit->ReadID,pReadHit->NumReads,pReadHit->ReadLen);
		if((LineLen + 5000) > cAllocLineBuffSize)
			{
			CUtility::SafeWrite(m_hMultiAlignFile,m_pszLineBuff,LineLen);
			LineLen = 0;
			}
		SeqOfs = 0;
		NxtFastaCol = 0;
		while(ReadLen)
			{
			NumCols = ReadLen > 70 ? 70 : ReadLen;
			if((NumCols + NxtFastaCol) > 70)
				NumCols = 70 - NxtFastaCol;
			CSeqTrans::MapSeq2Ascii(&Sequence[SeqOfs],NumCols,&m_pszLineBuff[LineLen]);
			LineLen += NumCols;
			NxtFastaCol += NumCols;
			SeqOfs += NumCols;
			ReadLen -= NumCols;
			if(!ReadLen || NxtFastaCol >= 70)
				{
				LineLen += sprintf(&m_pszLineBuff[LineLen],"\n");
				NxtFastaCol = 0;
				}

			if((LineLen + 5000) > cAllocLineBuffSize)
				{
				CUtility::SafeWrite(m_hMultiAlignFile,m_pszLineBuff,LineLen);
				LineLen = 0;
				}
			}
		}
	if(LineLen)
		CUtility::SafeWrite(m_hMultiAlignFile,m_pszLineBuff,LineLen);
#ifdef _WIN32
	_commit(m_hMultiAlignFile);
#else
	fsync(m_hMultiAlignFile);
#endif
	close(m_hMultiAlignFile);
	m_hMultiAlignFile = -1;
	}
return(eBSFSuccess);
}



int
FiltByChroms(void)
{
tBSFEntryID PrevTargEntry;
tBSFEntryID ExcludeTargEntryID;
int IncChromIdx;
int ExclChromIdx;
char szChromName[128];
bool bProcChrom = false;
int MatchesFiltOut = 0;
tsReadHit *pReadHit;

#ifdef _WIN32
RegexpMatch mc;
#else
regmatch_t mc;
int RegErr;					// regular expression parsing error
char szRegErr[128];			// to hold RegErr as textual representation ==> regerror();
#endif

if(m_NumExcludeChroms || m_NumIncludeChroms)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Now filtering matches by chromosome");
	PrevTargEntry = 0;
	pReadHit = NULL;
	while((pReadHit = IterSortedReads(pReadHit))!=NULL)
		{
		if(pReadHit->NumHits == 1)
			{
			if(pReadHit->HitLoci.Hit.Seg[0].ChromID != (UINT32)PrevTargEntry)
				{
				m_pSfxArray->GetIdentName(pReadHit->HitLoci.Hit.Seg[0].ChromID,sizeof(szChromName),szChromName);
				PrevTargEntry = pReadHit->HitLoci.Hit.Seg[0].ChromID;
				ExcludeTargEntryID = (tBSFEntryID)-1;
				}
			else
				{
				if(pReadHit->HitLoci.Hit.Seg[0].ChromID == (UINT32)ExcludeTargEntryID)
					{
					if(pReadHit->NumHits == 1)
						MatchesFiltOut += 1;
					pReadHit->NumHits = 0;
					}
				continue;
				}

			// to be included?
			bProcChrom = false;
			for(IncChromIdx = 0; IncChromIdx < m_NumIncludeChroms; IncChromIdx++)
				{
#ifdef _WIN32
				if(m_IncludeChromsRE[IncChromIdx]->Match(szChromName,&mc))
#else
				if(!regexec(&m_IncludeChromsRE[IncChromIdx],szChromName,1,&mc,0))
#endif
					{
					bProcChrom = true;
					break;
					}
				}

			// if not explicitly included then check if to be excluded?
			if(!bProcChrom && !m_NumIncludeChroms)
				{
				bProcChrom = true;
				for(ExclChromIdx = 0; ExclChromIdx < m_NumExcludeChroms; ExclChromIdx++)
					{
#ifdef _WIN32
					if(m_ExcludeChromsRE[ExclChromIdx]->Match(szChromName,&mc))
#else
					if(!regexec(&m_ExcludeChromsRE[ExclChromIdx],szChromName,1,&mc,0))
#endif
						{
						bProcChrom = false;
						break;
						}
					}
				}

			if(!bProcChrom)
				{
				ExcludeTargEntryID = pReadHit->HitLoci.Hit.Seg[0].ChromID;
				if(pReadHit->NumHits == 1)
					MatchesFiltOut += 1;
				pReadHit->NumHits = 0;
				}
			else
				ExcludeTargEntryID = -1;
			}
		}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Filtering by chromosome completed - removed %d  matches",MatchesFiltOut);
	}
return(eBSFSuccess);
}

// remove hits not aligned into a priority region
int
FiltByPriorityRegions(void)
{
char szPriorityChromName[100];
int PriorityChromID;

UINT32 MatchesFiltOut = 0;
UINT32 MatchesFiltIn = 0;

tsReadHit *pReadHit;
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Now filtering matches by prioritorised regions");
pReadHit = NULL;
while((pReadHit = IterSortedReads(pReadHit))!=NULL)
	{
	if(pReadHit->NumHits == 1)
		{
		// check if hit loci within region designated as being a priority exact matching region
		if(m_pSfxArray->GetIdentName(pReadHit->HitLoci.Hit.Seg[0].ChromID,sizeof(szPriorityChromName),szPriorityChromName)!=eBSFSuccess)
			{
			MatchesFiltOut += 1;
			pReadHit->NumHits = 0;
			pReadHit->HitLoci.Hit.Seg[0].ChromID = 0;
			pReadHit->HitLoci.Hit.Seg[1].ChromID = 0;
			continue;
			}
		if((PriorityChromID = m_pPriorityRegionBED->LocateChromIDbyName(szPriorityChromName)) < 1)
			{
			MatchesFiltOut += 1;
			pReadHit->NumHits = 0;
			pReadHit->HitLoci.Hit.Seg[0].ChromID = 0;
			pReadHit->HitLoci.Hit.Seg[1].ChromID = 0;
			continue;
			}

		if(!m_pPriorityRegionBED->InAnyFeature(PriorityChromID,(int)pReadHit->HitLoci.Hit.Seg[0].MatchLoci,
										(int)(pReadHit->HitLoci.Hit.Seg[0].MatchLoci + pReadHit->HitLoci.Hit.Seg[0].MatchLen-1)))
			{
			pReadHit->NumHits = 0;
			MatchesFiltOut += 1;
			pReadHit->HitLoci.Hit.Seg[0].ChromID = 0;
			pReadHit->HitLoci.Hit.Seg[1].ChromID = 0;
			}
		else
			MatchesFiltIn += 1;
		}
	}
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Filtering by prioritorised regions completed - retained %u, removed %u  matches",MatchesFiltIn,MatchesFiltOut);
return(eBSFSuccess);
}


int
WriteBasicCountStats(void)
{
int Idx;
int SeqOfs;
char szLineBuff[cMaxReadLen * 8];
int BuffIdx;
int PhredBand;

if(m_hStatsFile > 0 && m_MaxAlignLen > 0)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Writing out basic count stats to file");

	// report multiple hit distribution if MLMode not simply the default
	BuffIdx = 0;
	if(m_MLMode > eMLdefault)
		{
		BuffIdx = sprintf(szLineBuff,"\"Multihit distribution\",");
		for(Idx=0; Idx < m_MaxMLmatches; Idx++)
			{
			BuffIdx += sprintf(&szLineBuff[BuffIdx],",%d",Idx+1);
			if((BuffIdx + 512) > sizeof(szLineBuff))
				{
				CUtility::SafeWrite(m_hStatsFile,szLineBuff,BuffIdx);
				BuffIdx = 0;
				}
			}
		BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n,\"Instances\"");
		for(Idx=0; Idx < m_MaxMLmatches; Idx++)
			{
			BuffIdx += sprintf(&szLineBuff[BuffIdx],",%d",m_MultiHitDist[Idx]);
			if((BuffIdx + 512) > sizeof(szLineBuff))
				{
				CUtility::SafeWrite(m_hStatsFile,szLineBuff,BuffIdx);
				BuffIdx = 0;
				}
			}
		BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n");
		}

	BuffIdx += sprintf(&szLineBuff[BuffIdx],"\"Phred Score Instances\",");
	for(SeqOfs = 0; SeqOfs < m_MaxAlignLen; SeqOfs++)
		{
		BuffIdx += sprintf(&szLineBuff[BuffIdx],",%d",SeqOfs+1);
		if((BuffIdx + 512) > sizeof(szLineBuff))
			{
			CUtility::SafeWrite(m_hStatsFile,szLineBuff,BuffIdx);
			BuffIdx = 0;
			}
		}

	for(PhredBand = 0; PhredBand <= 3; PhredBand++)
		{
		switch(PhredBand) {
			case 0:
				BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n,\"Phred 0..9\"");
				break;
			case 1:
				BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n,\"Phred 10..19\"");
				break;
			case 2:
				BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n,\"Phred 20..29\"");
				break;
			case 3:
				BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n,\"Phred 30+\"");
				break;
			}

		for(SeqOfs = 0; SeqOfs < m_MaxAlignLen; SeqOfs++)
			{
			BuffIdx += sprintf(&szLineBuff[BuffIdx],",%d",m_AlignQSubDist[PhredBand][SeqOfs].QInsts);
			if((BuffIdx + 512) > sizeof(szLineBuff))
				{
				CUtility::SafeWrite(m_hStatsFile,szLineBuff,BuffIdx);
				BuffIdx = 0;
				}
			}
		}

	BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n\n\"Aligner Induced Subs\",");
	for(SeqOfs = 0; SeqOfs < m_MaxAlignLen; SeqOfs++)
		{
		BuffIdx += sprintf(&szLineBuff[BuffIdx],",%d",SeqOfs+1);
		if((BuffIdx + 512) > sizeof(szLineBuff))
			{
			CUtility::SafeWrite(m_hStatsFile,szLineBuff,BuffIdx);
			BuffIdx = 0;
			}
		}

	for(PhredBand = 0; PhredBand <= 3; PhredBand++)
		{
		switch(PhredBand) {
			case 0:
				BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n,\"Phred 0..8\"");
				break;
			case 1:
				BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n,\"Phred 9..19\"");
				break;
			case 2:
				BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n,\"Phred 20..29\"");
				break;
			case 3:
				BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n,\"Phred 30+\"");
				break;
			}

		for(SeqOfs = 0; SeqOfs < m_MaxAlignLen; SeqOfs++)
			{
			BuffIdx += sprintf(&szLineBuff[BuffIdx],",%d",m_AlignQSubDist[PhredBand][SeqOfs].Subs);
			if((BuffIdx + 512) > sizeof(szLineBuff))
				{
				CUtility::SafeWrite(m_hStatsFile,szLineBuff,BuffIdx);
				BuffIdx = 0;
				}
			}
		}

	BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n\n\"Multiple substitutions\",");
	for(SeqOfs = 0; SeqOfs < m_MaxAlignLen; SeqOfs++)
		{
		BuffIdx += sprintf(&szLineBuff[BuffIdx],",%d",SeqOfs);
		if((BuffIdx + 512) > sizeof(szLineBuff))
			{
			CUtility::SafeWrite(m_hStatsFile,szLineBuff,BuffIdx);
			BuffIdx = 0;
			}
		}
	BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n,\"Instances\"");
	for(SeqOfs = 0; SeqOfs < m_MaxAlignLen; SeqOfs++)
		{
		BuffIdx += sprintf(&szLineBuff[BuffIdx],",%d",m_AlignMSubDist[SeqOfs]);
		if((BuffIdx + 512) > sizeof(szLineBuff))
			{
			CUtility::SafeWrite(m_hStatsFile,szLineBuff,BuffIdx);
			BuffIdx = 0;
			}
		}
	BuffIdx += sprintf(&szLineBuff[BuffIdx],"\n");
	CUtility::SafeWrite(m_hStatsFile,szLineBuff,BuffIdx);
	BuffIdx = 0;
	}
return(eBSFSuccess);
}


int
CreateOrTruncResultFiles(void)
{
int LineLen;
char szChromName[128];

// create/truncate all output reporting files
#ifdef _WIN32
m_hOutFile = open(m_pszOutFile,O_CREATETRUNC );
#else
if((m_hOutFile = open(m_pszOutFile,O_RDWR | O_CREAT,S_IREAD | S_IWRITE))!=-1)
    if(ftruncate(m_hOutFile,0)!=0)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to truncate %s - %s",m_pszOutFile,strerror(errno));
			return(eBSFerrCreateFile);
			}
#endif

if(m_hOutFile < 0)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: unable to create/truncate output file '%s'",m_pszOutFile);
	return(eBSFerrCreateFile);
	}
if((m_pszLineBuff = new char [cAllocLineBuffSize])==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: unable to allocate memory (%d bytes) for output line buffer",cAllocLineBuffSize);
	return(eBSFerrMem);
	}
if(m_FMode == eFMbed && m_MLMode == eMLall)
	{
	LineLen = sprintf(m_pszLineBuff,"track type=bed name=\"%s\" description=\"%s\"\n",m_pszTrackTitle,m_pszTrackTitle);
	CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,LineLen);
	LineLen = 0;
	}
else
	if((m_FMode == eFMsam || m_FMode == eFMsamAll) && m_MLMode == eMLall)
		{
		int NumChroms = m_pSfxArray->GetNumEntries();
		int ChromID;
		UINT32 ChromSeqLen;
			// firstly is the header with the sequence chromosome directory
		m_szLineBuffIdx = sprintf(m_pszLineBuff,"@HD\tVN:1.0\tS0:unknown");

		for(ChromID = 1; ChromID <= NumChroms; ChromID++)
			{
			m_pSfxArray->GetIdentName(ChromID,sizeof(szChromName),szChromName);
			ChromSeqLen=m_pSfxArray->GetSeqLen(ChromID);
			m_szLineBuffIdx += sprintf(&m_pszLineBuff[m_szLineBuffIdx],"\n@SQ\tAS:%s\tSN:%s\tLN:%u",m_szTargSpecies,szChromName,ChromSeqLen);
			if(m_szLineBuffIdx > cAllocLineBuffSize/2)
				{
				CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,m_szLineBuffIdx);
				m_szLineBuffIdx = 0;
				}
			}
		m_szLineBuffIdx += sprintf(&m_pszLineBuff[m_szLineBuffIdx],"\n@PG\tID:%s\tVN:%s\n",gszProcName,cpszProgVer);
		CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,m_szLineBuffIdx);
		LineLen = 0;
		}
m_szLineBuffIdx = 0;

// If BED output then separate BEDs for InDels and splice junctions
if(m_microInDelLen && m_FMode == eFMbed)
	{
	strcpy(m_szIndRsltsFile,m_pszOutFile);
	strcat(m_szIndRsltsFile,".ind");
#ifdef _WIN32
	m_hIndOutFile = open(m_szIndRsltsFile,O_CREATETRUNC );
#else
	if((m_hIndOutFile = open(m_szIndRsltsFile,O_RDWR | O_CREAT,S_IREAD | S_IWRITE))!=-1)
		if(ftruncate(m_hIndOutFile,0)!=0)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to truncate microInDel file %s - %s",m_szIndRsltsFile,strerror(errno));
			return(eBSFerrCreateFile);
			}
#endif
	if(m_hIndOutFile < 0)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: unable to create/truncate microInDel output file '%s'",m_szIndRsltsFile);
		return(eBSFerrCreateFile);
		}
	}

if(m_pszSitePrefsFile != NULL && m_pszSitePrefsFile[0] != '\0')
	{
#ifdef _WIN32
	m_hSitePrefsFile = open(m_pszSitePrefsFile,O_CREATETRUNC );
#else
	if((m_hSitePrefsFile = open(m_pszSitePrefsFile,O_RDWR | O_CREAT,S_IREAD | S_IWRITE))!=-1)
	   if(ftruncate(m_hSitePrefsFile,0)!=0)
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to truncate %s - %s",m_pszSitePrefsFile,strerror(errno));
				return(eBSFerrCreateFile);
				}
#endif

	if(m_hSitePrefsFile < 0)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: unable to create/truncate site preferencing file '%s'",m_pszSitePrefsFile);
		return(eBSFerrCreateFile);
		}
	}
else
	m_hSitePrefsFile = -1;

if(m_SpliceJunctLen && m_FMode == eFMbed)
	{
	strcpy(m_szJctRsltsFile,m_pszOutFile);
	strcat(m_szJctRsltsFile,".jct");
#ifdef _WIN32
	m_hJctOutFile = open(m_szJctRsltsFile,O_CREATETRUNC );
#else
	if((m_hJctOutFile = open(m_szJctRsltsFile,O_RDWR | O_CREAT,S_IREAD | S_IWRITE))!=-1)
		if(ftruncate(m_hJctOutFile,0)!=0)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to truncate  splice junct  %s - %s",m_szJctRsltsFile,strerror(errno));
			return(eBSFerrCreateFile);
			}
#endif
	if(m_hJctOutFile < 0)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: unable to create/truncate splice junct output file '%s'",m_szJctRsltsFile);
		return(eBSFerrCreateFile);
		}
	}

if(m_pszSNPRsltsFile != NULL && m_pszSNPRsltsFile[0] != '\0' && m_MinSNPreads > 0 && m_FMode <= eFMsam)
	{
#ifdef _WIN32
	m_hSNPfile = open(m_pszSNPRsltsFile,O_CREATETRUNC );
#else
	if((m_hSNPfile = open(m_pszSNPRsltsFile,O_RDWR | O_CREAT,S_IREAD | S_IWRITE))!=-1)
		if(ftruncate(m_hSNPfile,0)!=0)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to truncate SNP file  %s - %s",m_pszSNPRsltsFile,strerror(errno));
			return(eBSFerrCreateFile);
			}
#endif
	if(m_hSNPfile < 0)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: unable to create/truncate SNP output file '%s'",m_pszSNPRsltsFile);
		return(eBSFerrCreateFile);
		}

	if(m_pszSNPCentroidFile != NULL && m_pszSNPCentroidFile[0] != '\0')
		{
#ifdef _WIN32
		m_hSNPCentsfile = open(m_pszSNPCentroidFile,O_CREATETRUNC );
#else
		if((m_hSNPCentsfile = open(m_pszSNPCentroidFile,O_RDWR | O_CREAT,S_IREAD | S_IWRITE))!=-1)
			if(ftruncate(m_hSNPCentsfile,0)!=0)
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to truncate SNP file  %s - %s",m_pszSNPCentroidFile,strerror(errno));
				return(eBSFerrCreateFile);
				}
#endif
		if(m_hSNPCentsfile < 0)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: unable to create/truncate SNP output file '%s'",m_pszSNPCentroidFile);
			return(eBSFerrCreateFile);
			}
		}
	else
		m_hSNPCentsfile = -1;
	}
else
	{
	m_hSNPfile = -1;
	m_hSNPCentsfile = -1;
	};

// none-aligned fasta reads file to be also generated?
if(m_pszNoneAlignFile != NULL && m_pszNoneAlignFile[0] != '\0')
	{
#ifdef _WIN32
	m_hNoneAlignFile = open(m_pszNoneAlignFile,O_CREATETRUNC );
#else
	if((m_hNoneAlignFile = open(m_pszNoneAlignFile,O_RDWR | O_CREAT,S_IREAD | S_IWRITE))!=-1)
		if(ftruncate(m_hNoneAlignFile,0)!=0)
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to truncate stats %s - %s",m_pszNoneAlignFile,strerror(errno));
				return(eBSFerrCreateFile);
				}
#endif

	if(m_hNoneAlignFile < 0)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: unable to create/truncate output stats file '%s'",m_pszNoneAlignFile);
		return(eBSFerrCreateFile);
		}
	}
else
	m_hNoneAlignFile = -1;


// multialigned fasta reads file to be also generated?
if(m_pszMultiAlignFile != NULL && m_pszMultiAlignFile[0] != '\0')
	{
#ifdef _WIN32
	m_hMultiAlignFile = open(m_pszMultiAlignFile,O_CREATETRUNC );
#else
	if((m_hMultiAlignFile = open(m_pszMultiAlignFile,O_RDWR | O_CREAT,S_IREAD | S_IWRITE))!=-1)
		if(ftruncate(m_hMultiAlignFile,0)!=0)
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to truncate multiple alignment file %s - %s",m_pszMultiAlignFile,strerror(errno));
				return(eBSFerrCreateFile);
				}
#endif

	if(m_hMultiAlignFile < 0)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: unable to create/truncate multiple alignment file '%s'",m_pszMultiAlignFile);
		return(eBSFerrCreateFile);
		}
	}
else
	m_hMultiAlignFile = -1;

// substitution stats to be also generated? Note that these can't be generated for InDels or splice junctions
if(m_pszStatsFile != NULL && m_pszStatsFile[0] != '\0')
	{
#ifdef _WIN32
	m_hStatsFile = open(m_pszStatsFile,O_CREATETRUNC );
#else
	if((m_hStatsFile = open(m_pszStatsFile,O_RDWR | O_CREAT,S_IREAD | S_IWRITE))!=-1)
		if(ftruncate(m_hStatsFile,0)!=0)
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to truncate stats %s - %s",m_pszStatsFile,strerror(errno));
				return(eBSFerrCreateFile);
				}
#endif

	if(m_hStatsFile < 0)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: unable to create/truncate output stats file '%s'",m_pszStatsFile);
		return(eBSFerrCreateFile);
		}
	}
else
	m_hStatsFile = -1;

return(eBSFSuccess);
}

int
CompileChromRegExprs(int	NumIncludeChroms,	// number of chromosome regular expressions to include
		char **ppszIncludeChroms,		// array of include chromosome regular expressions
		int	NumExcludeChroms,			// number of chromosome expressions to exclude
		char **ppszExcludeChroms)		// array of exclude chromosome regular expressions
{
int Idx;

#ifndef _WIN32
int RegErr;				// regular expression parsing error
char szRegErr[128];			// to hold RegErr as textual representation ==> regerror();
#endif

#ifdef _WIN32
try {
	for(Idx=0;Idx < NumIncludeChroms;Idx++)
		{
		m_IncludeChromsRE[Idx] = new Regexp();
		m_IncludeChromsRE[Idx]->Parse(ppszIncludeChroms[Idx],false);	// note case insensitive
		}
	}
catch(...)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to process include regexpr chrom '%s'",ppszIncludeChroms[Idx]);
	return(eBSFerrMem);
	}
try {
	for(Idx=0;Idx < NumExcludeChroms;Idx++)
		{
		m_ExcludeChromsRE[Idx] = new Regexp();
		m_ExcludeChromsRE[Idx]->Parse(ppszExcludeChroms[Idx],false);	// note case insensitive
		}
	}
catch(...)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to process exclude regexpr chrom '%s'",ppszExcludeChroms[Idx]);
	return(eBSFerrMem);
	}

#else
for(Idx=0;Idx < NumIncludeChroms;Idx++)
	{

	RegErr=regcomp(&m_IncludeChromsRE[Idx],ppszIncludeChroms[Idx],REG_EXTENDED | REG_ICASE);	// note case insensitive
	if(RegErr)
		{
		regerror(RegErr,&m_IncludeChromsRE[Idx],szRegErr,sizeof(szRegErr));
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to process include chrom '%s' error: %s",ppszIncludeChroms[Idx],szRegErr);
		return(eBSFerrMem);
		}
	}
for(Idx=0;Idx < NumExcludeChroms;Idx++)
	{
	RegErr = regcomp(&m_ExcludeChromsRE[Idx],ppszExcludeChroms[Idx],REG_EXTENDED | REG_ICASE);	// note case insensitive
	if(RegErr)
		{
		regerror(RegErr,&m_ExcludeChromsRE[Idx],szRegErr,sizeof(szRegErr));
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to process exclude chrom '%s' error: %s",ppszExcludeChroms[Idx],szRegErr);
		return(eBSFerrMem);
		}
	}
#endif
return(eBSFSuccess);
}


int
InitiateLoadingReads()
{
// initiate loading the reads
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Loading reads from file...");

m_ThreadLoadReadsRslt = -1;
#ifdef _WIN32
m_hThreadLoadReads = (HANDLE)_beginthreadex(NULL,0x0fffff,LoadReadFilesThread,&m_ThreadLoadReadsRslt,0,&m_ThreadLoadReadsID);
#else
int ThreadRslt =	pthread_create (&m_ThreadLoadReadsID , NULL , LoadReadFilesThread , &m_ThreadLoadReadsRslt );
#endif

// wait a few seconds, if major problems with loading reads then should show very quickly
#ifdef _WIN32
if(WAIT_TIMEOUT != WaitForSingleObject(m_hThreadLoadReads, 5000))
	{
	CloseHandle(m_hThreadLoadReads);
	m_hThreadLoadReads = NULL;
	return(m_ThreadLoadReadsRslt);
	}
#else
struct timespec ts;
int JoinRlt;
clock_gettime(CLOCK_REALTIME, &ts);
ts.tv_sec += 5;
if((JoinRlt = pthread_timedjoin_np(m_ThreadLoadReadsID, NULL, &ts)) == 0)
	{
	m_ThreadLoadReadsID = 0;
	return(m_ThreadLoadReadsRslt);
	}
#endif
return(eBSFSuccess);
}

int
Process(etPMode PMode,					// processing mode
		etFQMethod Quality,				// quality scoring for fastq sequence files
		bool bSOLiD,					// if true then processing in colorspace
		bool bBisulfite,				// if true then process for bisulfite methylation patterning
		etPEproc PEproc,				// paired reads alignment processing mode
		int PairMinLen,					// accept paired end alignments with apparent length of at least this (default = 50)
		int PairMaxLen,					// accept paired end alignments with apparent length of at most this (default = 500)
		eALStrand AlignStrand,		    // align to watson, crick or both
		int microInDelLen,				// microInDel length maximum
		int SpliceJunctLen,				// minimum splice junction length when aligning RNAseq reads
		int MinSNPreads,				// must be at least this number of reads covering any loci before processing for a SNP at this loci
		double QValue,					// QValue controlling FDR (Benjamini–Hochberg) SNP prediction
		int PCRartefactWinLen,			// PCR differential amplification artifact reduction window length to use
		etMLMode MLMode,				// multimatch loci reads processing mode
		int MaxMLmatches,				// accept at most this number of multimached alignments for any read
		bool bClampMaxMLmatches,		// accept as if MaxMLmatches even if more than this number of MaxMLmatches multimached alignments
		int MaxNs,					    // allow at most this number of indeterminate eBaseNs in read before deeming as nonalignable
		int MinEditDist,				// any matches must have at least this edit distance to the next best match
		int MaxSubs,					// maximum number of substitutions allowed or 1/10th of individual read length
		int Trim5,						// trim this number of bases from 5' end of reads when loading the reads
		int Trim3,						// trim this number of bases from 3' end of reads when loading the reads
		int MinFlankExacts,				// trim matched reads on 5' and 3' flanks until at least this number of exactly matching bases in flanks
		etFMode FMode,					// output format mode
		int SitePrefsOfs,				// offset read start sites when processing  octamer preferencing, range -100..100
		int NumThreads,					// number of worker threads to use
		char *pszTrackTitle,			// track title if output format is UCSC BED
		int NumPE1InputFiles,			// number of input PE1 or single ended file specs
		char *pszPE1InputFiles[],		// names of input files (wildcards allowed unless processing paired ends) containing raw reads
		int NumPE2InputFiles,			// number of input PE2 file specs
		char *pszPE2InputFiles[],		// optional raw paired reads are in these files
		char *pszPriorityRegionFile,	// optional exact match priority BED file contains prioritised region loci
		bool bFiltPriorityRegions,		// if priority regions requested then can also request that only alignments into these regions be reported
		char *pszOutFile,				// where to write alignments
		char *pszSNPFile,				// Output SNPs (CSV format) to this file (default is to output file name with '.snp' appended)
		char *pszSNPCentroidFile,		// Output SNP centorids (CSV format) to this file (default is for no centroid processing)
		char *pszSfxFile,				// target as suffix array
		char *pszStatsFile,				// aligner induced substitutions stats file
		char *pszMultiAlignFile,		// file to contain reads which are aligned to multiple locations
		char *pszNoneAlignFile,			// file to contain reads which were non-alignable
		char *pszSitePrefsFile,			// file to contain aligned reads octamer preferencing
		char *pszHammFile,				// Hamming edit distance file
		int	NumIncludeChroms,			// number of chromosome regular expressions to include
		char **ppszIncludeChroms,		// array of include chromosome regular expressions
		int	NumExcludeChroms,			// number of chromosome expressions to exclude
		char **ppszExcludeChroms)		// array of exclude chromosome regular expressions

{
int Rslt;
int Idx;
int BuffLen = 0;
int BuffOfs = 0;
int SeqIdx;
Init();


m_pszTrackTitle = pszTrackTitle;

m_pszHammFile = pszHammFile;
m_pszOutFile = pszOutFile;
m_pszSNPRsltsFile = pszSNPFile;
m_pszSNPCentroidFile = pszSNPCentroidFile;
m_NumPE2InputFiles = NumPE2InputFiles;

m_ppszPE2InputFiles = pszPE2InputFiles;
m_pszMultiAlignFile = pszMultiAlignFile;
m_pszNoneAlignFile = pszNoneAlignFile;
m_pszStatsFile = pszStatsFile;
m_pszSitePrefsFile = pszSitePrefsFile;

m_NumPE1InputFiles = NumPE1InputFiles;
m_ppszPE1InputFiles = pszPE1InputFiles;
m_bFiltPriorityRegions = bFiltPriorityRegions;

m_PMode = PMode;
m_FMode = FMode;
m_PEproc = PEproc;
m_QMethod = Quality;
m_NumThreads = NumThreads;
m_bBisulfite = bBisulfite;
m_MaxMLmatches = MaxMLmatches;
m_bClampMaxMLmatches = bClampMaxMLmatches;
m_MLMode = MLMode;
m_MaxNs = MaxNs;
m_AlignStrand = AlignStrand;
m_microInDelLen = microInDelLen;
m_SpliceJunctLen = SpliceJunctLen;
m_MinSNPreads = MinSNPreads;
m_QValue = QValue;

m_Trim5 = Trim5;						// trim this number of bases from 5' end of reads when loading the reads
m_Trim3 = Trim3;						// trim this number of bases from 3' end of reads when loading the reads

m_SitePrefsOfs = SitePrefsOfs;			// offset read start sites when processing  octamer preferencing, range -100..100


m_NumIncludeChroms = NumIncludeChroms;
m_NumExcludeChroms = NumExcludeChroms;

if(CreateMutexes()!=eBSFSuccess)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Failed to create thread synchronisation mutexes");
	Reset(false);
	return(cBSFSyncObjErr);
	}

mtqsort.SetMaxThreads(NumThreads);

// load the hammings if user has specified the file path
if(pszHammFile != NULL && pszHammFile[0] != '\0')
	{
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Loading Hamming edit distances from file '%s'",pszHammFile);
	if((Rslt = LoadHammings(pszHammFile)) < eBSFSuccess)
		{
		Reset(false);
		return(Rslt);
		}
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Loading Hamming edit distances completed");
	}

// compile include/exclude chromosome regexpr if user has specified alignments to be filtered by chrom
if(NumIncludeChroms > 0 || m_NumExcludeChroms > 0)
	if((Rslt = CompileChromRegExprs(NumIncludeChroms,ppszIncludeChroms,NumExcludeChroms,ppszExcludeChroms)) != eBSFSuccess)
		{
		Reset(false);
		return(Rslt);
		}

// if specified then load exact match priority regions from BED file
if(pszPriorityRegionFile != NULL && pszPriorityRegionFile[0] != '\0')
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Loading exact match priority regions BED file '%s'", pszPriorityRegionFile);
	if((m_pPriorityRegionBED = new CBEDfile()) == NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to instantiate CBEDfile");
		Reset(false);
		return(eBSFerrObj);
		}
	if((Rslt=m_pPriorityRegionBED->Open(pszPriorityRegionFile))!=eBSFSuccess)
		{
		while(m_pSfxArray->NumErrMsgs())
			gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pPriorityRegionBED->GetErrMsg());
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open priority regions BED file '%s'",pszPriorityRegionFile);
		Reset(false);
		return(Rslt);
		}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Exact match priority regions BED file '%s' loaded", pszPriorityRegionFile);
	}


// open bioseq file containing suffix array for targeted assembly to align reads against
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Loading suffix array file '%s'", pszSfxFile);
if((m_pSfxArray = new CSfxArrayV3()) == NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to instantiate CSfxArrayV2");
	Reset(false);
	return(eBSFerrObj);
	}
if((Rslt=m_pSfxArray->Open(pszSfxFile,false,bBisulfite,bSOLiD))!=eBSFSuccess)
	{
	while(m_pSfxArray->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pSfxArray->GetErrMsg());
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open input bioseq suffix array file '%s'",pszSfxFile);
	Reset(false);
	return(Rslt);
	}

// report to user some sfx array metadata as conformation the targeted assembly is correct
strcpy(m_szTargSpecies,m_pSfxArray->GetDatasetName());
m_bIsSOLiD = m_pSfxArray->IsSOLiD();
tsSfxHeaderV3 SfxHeader;
m_pSfxArray->GetSfxHeader(&SfxHeader);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Genome Assembly Name: '%s' Descr: '%s' Title: '%s' Version: %d",
					 m_szTargSpecies,SfxHeader.szDescription,SfxHeader.szTitle,SfxHeader.Version);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Assembly has blocks: %d, max block size: %llu",SfxHeader.NumSfxBlocks,SfxHeader.SfxBlockSize);

// restrict the max core iterations according to the requested sensitivity
int MaxIter;
switch(PMode) {
	case ePMdefault:			// default processing mode
		MaxIter = cDfltSensCoreIters;
		break;
	case ePMMoreSens:			// more sensitive - slower
		MaxIter = cMoreSensCoreIters;
		break;
	case ePMUltraSens:			// ultra sensitive - much slower
		MaxIter = cUltraSensCoreIters;
		break;
	case ePMLessSens:			// less sensitive - quicker
	default:
		MaxIter = cMinSensCoreIters;
	}
m_pSfxArray->SetMaxIter(MaxIter);

// reads are loaded asynchronously to the alignment processing
if((Rslt=InitiateLoadingReads()) < eBSFSuccess)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Failed to load reads");
	Reset(false);
	return(Rslt);
	}

// if user wants to utilise reads aligning to multiple loci then need to make an initial alloc for holding these..
if(m_MLMode > eMLrand && m_MLMode != eMLall)
	{
	size_t memreq = (size_t)sizeof(tsReadHit) * cAllocMultihits;

#ifdef _WIN32
	m_pMultiHits = (tsReadHit *) malloc(memreq);	// initial and perhaps the only allocation

	if(m_pMultiHits == NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadReads: Memory allocation of %lld bytes - %s",(INT64)memreq,strerror(errno));
		Reset(false);
		return(eBSFerrMem);
		}
#else
	// gnu malloc is still in the 32bit world and can't handle more than 2GB allocations
	m_pMultiHits = (tsReadHit *)mmap(NULL,memreq, PROT_READ |  PROT_WRITE,MAP_PRIVATE | MAP_ANONYMOUS, -1,0);
	if(m_pMultiHits == MAP_FAILED)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadReads: Memory allocation of %lld bytes through mmap()  failed - %s",(INT64)memreq,strerror(errno));
		m_pMultiHits = NULL;
		Reset(false);
		return(eBSFerrMem);
		}
#endif
	m_AllocdMultiHits = cAllocMultihits;
	m_AllocdMultiHitsMem = memreq;
	m_NumMultiHits = 0;
	m_NumUniqueMultiHits = 0;
	m_NumProvMultiAligned = 0;
	}

// reasonably confident that there will be some results to report so create/trunc all required result files
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Creating/truncating result files..");
if((Rslt=CreateOrTruncResultFiles())!=eBSFSuccess)
	{
	// problems.. need to ensure all background threads (at this stage should only be the reads loading or sfx loading thread) are cleanly terminated
	m_TermBackgoundThreads = 1;	// need to immediately self-terminate?
	m_pSfxArray->Reset(false);
#ifdef _WIN32
	if(m_hThreadLoadReads != NULL)
		{
		while(WAIT_TIMEOUT == WaitForSingleObject(m_hThreadLoadReads, 5000))
			{
			gDiagnostics.DiagOut(eDLInfo,gszProcName,"Progress: waiting for reads load thread to terminate");
			}
		CloseHandle(m_hThreadLoadReads);
		}
#else
	if(m_ThreadLoadReadsID != 0)
		{
		struct timespec ts;
		int JoinRlt;
		clock_gettime(CLOCK_REALTIME, &ts);
		ts.tv_sec += 5;
		while((JoinRlt = pthread_timedjoin_np(m_ThreadLoadReadsID, NULL, &ts)) != 0)
			{
			gDiagnostics.DiagOut(eDLInfo,gszProcName,"Progress: waiting for reads load thread to terminate");
			ts.tv_sec += 60;
			}
		}
#endif
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Progress: reads load thread terminated");
	Reset(false);
	return(Rslt);
	}
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Creating/truncating result files completed");

// locate all read matches
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Aligning in %s...",bSOLiD ? "colorspace" : "basespace");
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Aligning for %s cored matches...",bBisulfite ? "bisulfite" : "normal");
Rslt = LocateCoredApprox(MinEditDist,MaxSubs);

if(Rslt < eBSFSuccess)
	{
	Reset(false);
	return(Rslt);
	}


// if autodetermining max subs that were allowed from actual reads then let user know what the average read length was
size_t TotReadsLen = 0;
tsReadHit *pReadHit;
int AvReadsLen;
int MinReadsLen = -1;
int MaxReadsLen = 0;
pReadHit = m_pReadHits;
for(Idx = 0; Idx < (int)m_NumReadsLoaded; Idx++)
	{
	TotReadsLen += pReadHit->ReadLen;
	if(MinReadsLen > pReadHit->ReadLen || MinReadsLen == -1)
		MinReadsLen = pReadHit->ReadLen;
	if(MaxReadsLen < pReadHit->ReadLen)
		MaxReadsLen = pReadHit->ReadLen;
	pReadHit = (tsReadHit *)((UINT8 *)pReadHit + sizeof(tsReadHit) + pReadHit->ReadLen + pReadHit->DescrLen);
	}
AvReadsLen = (int)(TotReadsLen/m_NumReadsLoaded);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Average length of all reads was: %d (min: %d, max: %d)",AvReadsLen,MinReadsLen,MaxReadsLen);
m_MaxReadsLen = MaxReadsLen;
m_MinReadsLen = MinReadsLen;
m_AvReadsLen = AvReadsLen;

if(MaxSubs == -1)
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Typical allowed aligner induced substitutions was: %d (min: %d, max: %d)",AvReadsLen/10,MinReadsLen/10,MaxReadsLen/10);

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Provisionally accepted %d aligned reads (%d uniquely, %d aligning to multiloci) aligning to a total of %d loci", m_TotAcceptedAsAligned,m_TotAcceptedAsUniqueAligned,m_TotAcceptedAsMultiAligned,m_TotLociAligned);

if(m_MLMode == eMLall)		// no further processing required if multimatch loci reporting
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Unable to accept %d aligned reads because of insufficient Hamming distance",m_TotNotAcceptedDelta);
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Unable to align %d source reads of which %d contained excessive number of indeterminate 'N' bases",m_TotNonAligned+m_NumSloughedNs,m_NumSloughedNs);
	Reset(true);
	return(Rslt);
	}

if(PEproc != ePEdefault)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Paired end association and partner alignment processing started..");
	if((Rslt=ProcessPairedEnds(PEproc,MinEditDist,PairMinLen,PairMaxLen,MaxSubs)) < eBSFSuccess)
		{
		Reset(false);
		return(Rslt);
		}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Paired end association and partner alignment processing completed..");
#ifdef USEOLDCODE
	Reset(true);
	return(eBSFSuccess);
#endif
	}

// try and assign multimatch read loci?
if(PEproc == ePEdefault && m_MLMode > eMLrand)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Multialignment processing started..");
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Sorting %d reads by ReadID...",m_NumReadsLoaded);
	Rslt = SortReadHits(eRSMReadID,false);
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Sorting %d reads completed",m_NumReadsLoaded);
	if((Rslt = AssignMultiMatches()) < eBSFSuccess)
		{
		Reset(false);
		return(Rslt);
		}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Multialignment processing completed");
	}


// if requested then attempt to reduce the number of  PCR differential amplification artefacts (reads stacking to same loci)
if(PEproc == ePEdefault && PCRartefactWinLen >= 0)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Processing to reduce PCR differential amplification artefacts processing started..");
	if((Rslt=SortReadHits(eRSMHitMatch,false)) < eBSFSuccess)
		{
		Reset(false);
		return(Rslt);
		}
	if((Rslt=ReducePCRduplicates(PCRartefactWinLen)) < eBSFSuccess)
		{
		Reset(false);
		return(Rslt);
		}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"PCR differential amplification artefacts processing completed");
	}

// autotrim aligned reads flanks
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Sorting aligned reads by ascending loci...");
if((Rslt=SortReadHits(eRSMHitMatch,false)) < eBSFSuccess)
	{
	Reset(false);
	return(Rslt);
	}
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Sorting completed");

if(MinFlankExacts > 0)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Autotrim aligned read flank processing started..");
	if((Rslt=AutoTrimFlanks(MinFlankExacts)) < eBSFSuccess)
		{
		Reset(false);
		return(Rslt);
		}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Autotrim aligned read flank processing completed");
	}

// if splice junctions being processed then check for orphans and remove these
if(PEproc == ePEdefault && SpliceJunctLen > 0)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Removal of orphan splice junction processing started..");
	if((Rslt=RemoveOrphanSpliceJuncts(SpliceJunctLen)) < eBSFSuccess)
		{
		Reset(false);
		return(Rslt);
		}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Removal of orphan splice junction processing completed");
	}

// if processing for microInDels then need to check for orphans and remove these
if(PEproc == ePEdefault && microInDelLen > 0)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Removal of orphan microInDels processing started..");
	if((Rslt=RemoveOrphanMicroInDels(microInDelLen)) < eBSFSuccess)
		{
		Reset(false);
		return(Rslt);
		}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Removal of orphan microInDels processing completed");
	}

// report basic stats
if((Rslt=ReportAlignStats()) < eBSFSuccess)
	{
	Reset(false);
	return(Rslt);
	}

BuffLen = 0;
BuffOfs = 0;
SeqIdx;

// now start reporting the alignment results....

// user interested in the nonaligned?
if(m_hNoneAlignFile != -1)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Reporting of non-aligned reads started..");
	if((Rslt=ReportNoneAligned())<eBSFSuccess)
		{
		Reset(false);
		return(Rslt);
		}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Reporting of non-aligned reads completed");
	}

// user interested in the multialigned?
// these only include those reads which would otherwise have been accepted but aligned to multiple loci
if(PEproc == ePEdefault && m_hMultiAlignFile != -1)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Reporting of multialigned reads started..");
	if((Rslt=ReportMultiAlign()) < eBSFSuccess)
		{
		Reset(false);
		return(Rslt);
		}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Reporting of multialigned reads completed");
	}

// now apply any chromosome filtering that user has specified
// assumes that reads have been sorted by ascending hit count,chrom, loci, strand
if(NumExcludeChroms || NumIncludeChroms)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Filtering aligned reads by chromosome started..");
	if((Rslt=FiltByChroms())<eBSFSuccess)
		{
		Reset(false);
		return(Rslt);
		}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Filtering aligned reads by chromosome completed");
	}

// apply priority region filtering if was requested
if(m_pPriorityRegionBED != NULL && m_bFiltPriorityRegions)
	FiltByPriorityRegions();

if(m_hSitePrefsFile != -1)
	ProcessSiteProbabilites(m_SitePrefsOfs);

// now time to write out the read hits
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Reporting of aligned result set started...");
if(FMode >= eFMsam)
	Rslt = WriteSAMReadHits(FMode,PEproc == ePEdefault ? false : true);
else
	Rslt = WriteReadHits(PEproc == ePEdefault ? false : true);
if(Rslt<eBSFSuccess)
	{
	Reset(false);
	return(Rslt);
	}
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Reporting of aligned result set completed");

if(Rslt >= eBSFSuccess && m_hStatsFile > 0 && m_MaxAlignLen > 0)
	Rslt = WriteBasicCountStats();

if(Rslt >= eBSFSuccess && m_hSitePrefsFile > 0)
	Rslt = WriteSitePrefs();

if(Rslt >= eBSFSuccess && MinSNPreads > 0 && m_hSNPfile != -1)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Processing for SNPs and writing out SNPs to file '%s",m_pszSNPRsltsFile);
	Rslt = ProcessSNPs();			// track title if output format is to be UCSC BED, will have '_SNPs' appended
	if(Rslt >= eBSFSuccess)
		gDiagnostics.DiagOut(eDLInfo,gszProcName,"SNP processing completed with %d putative SNPs discovered",m_TotNumSNPs);
	}
Reset(Rslt >= eBSFSuccess ? true : false);
return(Rslt);
}



int
RunClusteringThreads(int NumThreads)
{
int ThreadIdx;
UINT32 ClusterStartIdx;
tsClusterThreadPars ClusterThreads[cMaxWorkerThreads];

ClusterStartIdx = 0;
memset(ClusterThreads,0,sizeof(ClusterThreads));
for(ThreadIdx = 0; ThreadIdx < NumThreads; ThreadIdx++)
	{
	ClusterThreads[ThreadIdx].ThreadIdx = ThreadIdx + 1;
#ifdef _WIN32
	ClusterThreads[ThreadIdx].threadHandle = (HANDLE)_beginthreadex(NULL,0x0fffff,AssignMultiMatchesThread,&ClusterThreads[ThreadIdx],0,&ClusterThreads[ThreadIdx].threadID);
#else
	ClusterThreads[ThreadIdx].threadRslt =	pthread_create (&ClusterThreads[ThreadIdx].threadID , NULL , AssignMultiMatchesThread , &ClusterThreads[ThreadIdx] );
#endif
	}

for(ThreadIdx = 0; ThreadIdx < NumThreads; ThreadIdx++)
	{
#ifdef _WIN32
	while(WAIT_TIMEOUT == WaitForSingleObject( ClusterThreads[ThreadIdx].threadHandle, 60000))
		{
		}
	CloseHandle( ClusterThreads[ThreadIdx].threadHandle);
#else
	struct timespec ts;
	int JoinRlt;
	clock_gettime(CLOCK_REALTIME, &ts);
	ts.tv_sec += 60;
	while((JoinRlt = pthread_timedjoin_np(ClusterThreads[ThreadIdx].threadID, NULL, &ts)) != 0)
		{
		ts.tv_sec += 60;
		}
#endif
	}
return(eBSFSuccess);
}

UINT32 m_CurClusterFrom = 0;

// GetClusterStartEnd
// Clustering threads call this function to obtain the next from, until inclusive indexes into m_pMultiHits[] to be clustered
// Returns number of
int												// returns 0 if finished clustering or cnt of multihits to be processed by this thread
GetClusterStartEnd(UINT32 *pMatchFrom,			// cluster from this inclusive index
					UINT32 *pMatchUntil)		// until this inclusive index
{
int Rslt;
UINT32 NumLeft2Cluster;
UINT32 Num4Thread;
AcquireSerialise();
NumLeft2Cluster = m_NumMultiHits - m_CurClusterFrom;
if(NumLeft2Cluster > 0)
	{
	if(NumLeft2Cluster < 100)	// if < 100 yet to be processed then give it all to the one thread
		Num4Thread = NumLeft2Cluster;
	else
		{
		Num4Thread = min(2000,m_NumThreads + (NumLeft2Cluster / (UINT32)m_NumThreads));
		Num4Thread = min(Num4Thread,NumLeft2Cluster);
		}

	*pMatchFrom = m_CurClusterFrom;
	*pMatchUntil = m_CurClusterFrom + Num4Thread - 1;
	m_CurClusterFrom = min(1 + *pMatchUntil,m_NumMultiHits);
	Rslt = Num4Thread;
	}
else
	Rslt = 0;
ReleaseSerialise();
return(Rslt);
}

#ifdef _WIN32
unsigned __stdcall AssignMultiMatchesThread(void * pThreadPars)
#else
void *AssignMultiMatchesThread(void * pThreadPars)
#endif
{
tsClusterThreadPars *pPars = (tsClusterThreadPars *)pThreadPars; // makes it easier not having to deal with casts!
int Rslt;
UINT32 MatchFrom;
UINT32 MatchUntil;
UINT32 HitIdx;
UINT32 Score;
UINT32 ClustHitIdx;
tsReadHit *pCurHit;
tsReadHit *pClustHit;
tsReadHit *pPrevProcCurHit;
int Overlap;
UINT32 ClustEndLoci;

while((Rslt = GetClusterStartEnd(&MatchFrom,&MatchUntil)) > 0)
	{
	pCurHit = &m_pMultiHits[MatchFrom];
	pPrevProcCurHit = NULL;
	for(HitIdx=MatchFrom;HitIdx <= MatchUntil; HitIdx++,pCurHit++)
		{
		if(!pCurHit->HitLoci.FlagMH)			// only interested in assigning reads which align to multiple hit loci
			continue;							// reads which map to a single hit loci do not require processing

		if(pPrevProcCurHit != NULL &&
					AdjStartLoci(&pPrevProcCurHit->HitLoci.Hit.Seg[0]) == AdjStartLoci(&pCurHit->HitLoci.Hit.Seg[0]) &&
					AdjHitLen(&pPrevProcCurHit->HitLoci.Hit.Seg[0]) == AdjHitLen(&pCurHit->HitLoci.Hit.Seg[0]) &&
					pPrevProcCurHit->HitLoci.Hit.Seg[0].Strand == pCurHit->HitLoci.Hit.Seg[0].Strand &&
					pPrevProcCurHit->HitLoci.Hit.Seg[0].ChromID == pCurHit->HitLoci.Hit.Seg[0].ChromID)
			{
			pCurHit->HitLoci.Hit.Score = pPrevProcCurHit->HitLoci.Hit.Score;
			continue;
			}

		pPrevProcCurHit = NULL;
		pCurHit->HitLoci.Hit.Score = 0;
		pClustHit = pCurHit;
		ClustHitIdx = HitIdx;
		while(ClustHitIdx-- > 0)				// checking for clustering upstream of current hit loci
			{
			pClustHit -= 1;

			// can't cluster with reads on a different chrom!
			if(pClustHit->HitLoci.Hit.Seg[0].ChromID != pCurHit->HitLoci.Hit.Seg[0].ChromID)
				break;

			// can't cluster if much too far away
			if((AdjStartLoci(&pCurHit->HitLoci.Hit.Seg[0]) - AdjStartLoci(&pClustHit->HitLoci.Hit.Seg[0])) >= (int)m_MaxReadsLen)
				break;
			// only cluster if >= cClustMultiOverLap
			ClustEndLoci = AdjEndLoci(&pClustHit->HitLoci.Hit.Seg[0]);
			if((int)ClustEndLoci < (AdjStartLoci(&pCurHit->HitLoci.Hit.Seg[0]) + cClustMultiOverLap))
				continue;
			Overlap = min(AdjHitLen(&pCurHit->HitLoci.Hit.Seg[0]),(int)ClustEndLoci - AdjStartLoci(&pCurHit->HitLoci.Hit.Seg[0]));

			if((m_MLMode == eMLuniq && pClustHit->HitLoci.FlagMH) ||
				(pCurHit->HitLoci.Hit.Score & cUniqueClustFlg && (pCurHit->HitLoci.Hit.Score & ~cUniqueClustFlg) >= 0x01fff))
				continue;

			if(pClustHit->HitLoci.Hit.Seg[0].Strand == pCurHit->HitLoci.Hit.Seg[0].Strand && pClustHit->ReadID != pCurHit->ReadID)
				{
				if(!pClustHit->HitLoci.FlagMH)	// clustering to a unique aligned reads has much higher priority than to other multialigned reads
					{
					Score = 1 + (Overlap * cClustUniqueScore)/cClustScaleFact;
					if(pCurHit->HitLoci.Hit.Score & cUniqueClustFlg)
						Score += pCurHit->HitLoci.Hit.Score & ~cUniqueClustFlg;
					if(Score > 0x01fff)			// clamp upstream scores to be no more than 0x01fff so still room for dnstream scores
						Score = 0x01fff;
					pCurHit->HitLoci.Hit.Score = (UINT16)(Score | cUniqueClustFlg);	// flag that this score is because now clustering to uniquely aligned reads
					if(Score == 0x01fff)
						break;					// this is a good candidate loci
					}
				else							// never seen a uniquely aligned so still clustering to other non-unique aligned reads
					{
					if(!(pCurHit->HitLoci.Hit.Score & cUniqueClustFlg))
						{
						Score = 1 + (Overlap * cClustMultiScore)/cClustScaleFact;
						Score += pCurHit->HitLoci.Hit.Score & ~cUniqueClustFlg;
						if(Score > 0x01fff)			// clamp upstream scores to be no more than 0x01fff so still room for dnstream scores
							Score = 0x01fff;
						pCurHit->HitLoci.Hit.Score = Score;
						}
					}
				}
			}

		// now cluster downstream
		pClustHit = pCurHit;
		ClustHitIdx = HitIdx;
		while(++ClustHitIdx < m_NumMultiHits)				// checking for clustering downstream of current hit loci
			{
			pClustHit += 1;
			// can't cluster with reads on a different chrom!
			if(pClustHit->HitLoci.Hit.Seg[0].ChromID != pCurHit->HitLoci.Hit.Seg[0].ChromID)
				break;

			// can't score if no overlap of at least cClustMultiOverLap
			ClustEndLoci = AdjEndLoci(&pCurHit->HitLoci.Hit.Seg[0]);
			if(AdjStartLoci(&pClustHit->HitLoci.Hit.Seg[0]) > (ClustEndLoci - (UINT32)cClustMultiOverLap))
				break;

			Overlap = min(AdjHitLen(&pClustHit->HitLoci.Hit.Seg[0]),(int)ClustEndLoci - AdjStartLoci(&pClustHit->HitLoci.Hit.Seg[0]));

			if((m_MLMode == eMLuniq && pClustHit->HitLoci.FlagMH) ||
				(pCurHit->HitLoci.Hit.Score & cUniqueClustFlg && (pCurHit->HitLoci.Hit.Score & ~cUniqueClustFlg) >= 0x03fff))
				continue;

			if(pClustHit->HitLoci.Hit.Seg[0].Strand == pCurHit->HitLoci.Hit.Seg[0].Strand && pClustHit->ReadID != pCurHit->ReadID)
				{
				if(!pClustHit->HitLoci.FlagMH)	// clustering to a unique aligned reads has much higher priority than to other multialigned reads
					{
					Score = 1 + (Overlap * cClustUniqueScore)/cClustScaleFact;
					if(pCurHit->HitLoci.Hit.Score & cUniqueClustFlg)
						Score += pCurHit->HitLoci.Hit.Score & ~cUniqueClustFlg;
					if(Score > 0x3fff)
						Score = 0x3fff;
					pCurHit->HitLoci.Hit.Score = (UINT16)(Score | cUniqueClustFlg);
					if(Score == 0x3fff)
						break;
					}
				else
					{
					if(!(pCurHit->HitLoci.Hit.Score & cUniqueClustFlg))
						{
						Score = 1 + (Overlap * cClustMultiScore)/cClustScaleFact;
						Score += pCurHit->HitLoci.Hit.Score & ~cUniqueClustFlg;
						if(Score > 0x3fff)
							Score = 0x3fff;
						pCurHit->HitLoci.Hit.Score = (UINT16)Score;
						}
					}
				}
			}
		pPrevProcCurHit = pCurHit;
		}
	}
pPars->Rslt = 1;
#ifdef _WIN32
_endthreadex(0);
return(eBSFSuccess);
#else
pthread_exit(NULL);
#endif
}

// AssignMultiMatches
// Use clustering (within a sliding window) to determine which matching loci should be assigned to those reads with multiple hits
// This is multipass clustering process as need to cluster multimatches with uniquely matched before clustering with other multimatched.
int
AssignMultiMatches(void) // false to cluster with uniques, true to cluster with multimatches
{
UINT32 HitIdx;
UINT32 ClustHitIdx;
UINT32 Distance;
int NumAssigned;
int NumUnlocated;
tsReadHit *pCurHit;
tsReadHit *pClustHit;

int ClusterUniqueAssigned;
int ClusterAllAssigned;

if(m_MLMode <= eMLrand)		// nothing to do?
	return(0);

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Assigning %d reads which aligned to multiple loci to a single loci",m_NumProvMultiAligned);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Sorting...");
mtqsort.qsort(m_pMultiHits,m_NumMultiHits,sizeof(tsReadHit),SortMultiHits);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Sorting completed, now clustering...");

RunClusteringThreads(m_NumThreads);

// sort now by ascending ReadID and descending scores
// and assign the read match with the highest score to that read
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Assigning...");
mtqsort.qsort(m_pMultiHits,m_NumMultiHits,sizeof(tsReadHit),SortMultiHitReadIDs);
UINT32 CurReadID = 0;
UINT32 BestScore;
UINT32 NxtBestScore;

tsReadHit *pAssign2Read;
NumAssigned = 0;
NumUnlocated = 0;
ClusterUniqueAssigned = 0;
ClusterAllAssigned = 0;
pCurHit = m_pMultiHits;
for(HitIdx=0;HitIdx < m_NumMultiHits; HitIdx++,pCurHit++)
	{
	if(!pCurHit->HitLoci.FlagMH)	 // only interested in reads with multiple hits
		continue;
	if(CurReadID == pCurHit->ReadID) // only interested in the first for each read
		continue;
	CurReadID = pCurHit->ReadID;
	NumAssigned += 1;

	// only interested if best score for read is at least cMHminScore and that score is at least 2x next best score for read
	BestScore = (UINT32)(pCurHit->HitLoci.Hit.Score & ~cUniqueClustFlg);
	if(BestScore < cMHminScore)
		continue;

	if((pCurHit->HitLoci.Hit.Score & cUniqueClustFlg) == (pCurHit[1].HitLoci.Hit.Score & cUniqueClustFlg))
		{
		NxtBestScore = (UINT32)(pCurHit[1].HitLoci.Hit.Score & ~cUniqueClustFlg);
		if(BestScore < (NxtBestScore * 2))
			continue;
		}

	// accept this loci as the loci as being the putative read hit loci for this multihit
	pCurHit->HitLoci.FlagMHA = 1;
	if(pCurHit->HitLoci.Hit.Score & cUniqueClustFlg)
		{
		ClusterUniqueAssigned += 1;
		pCurHit->HitLoci.FlagHL = eHLclustunique;
		}
	else
		{
		ClusterAllAssigned += 1;
		pCurHit->HitLoci.FlagHL = eHLclustany;
		}
	}

// need to ensure that as a result of the assignments no assigned multialigned read is now actually an orphan
// orphans are those assigned as eHLclustany if within the window there are no other assigned multireads...
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Checking for orphans (unclustered) from %d putative assignments..",NumAssigned);
mtqsort.qsort(m_pMultiHits,m_NumMultiHits,sizeof(tsReadHit),SortMultiHits);
NumUnlocated = 0;
ClusterUniqueAssigned = 0;
ClusterAllAssigned = 0;
int PutativeAssignments = NumAssigned;
bool bAcceptMulti;
NumAssigned = 0;
pCurHit = m_pMultiHits;
for(HitIdx=0;HitIdx < m_NumMultiHits; HitIdx++,pCurHit++)
	{
	if(!pCurHit->HitLoci.FlagMHA)			// only interested in multihit reads which have been assigned to a single loci
		continue;

	bAcceptMulti = false;
	if(pCurHit->HitLoci.FlagHL == eHLclustany) // if was clustered with another multihit then ensure that the other multihit still in play..
		{
		pClustHit = pCurHit;
		ClustHitIdx = HitIdx;
		while(ClustHitIdx-- > 0)				// checking for clustering upstream of current hit loci
			{
			pClustHit -= 1;
			Distance = AdjStartLoci(&pCurHit->HitLoci.Hit.Seg[0]) - AdjStartLoci(&pClustHit->HitLoci.Hit.Seg[0]);
			if(Distance > (UINT32)(cClustMultiOverLap + (int)AdjHitLen(&pClustHit->HitLoci.Hit.Seg[0]))) // finish if much too far away
				break;
			if(pClustHit->HitLoci.Hit.Seg[0].ChromID != pCurHit->HitLoci.Hit.Seg[0].ChromID)
				break;							// can't cluster with reads on a different chrom!
			if(!pClustHit->HitLoci.FlagMH || pClustHit->HitLoci.FlagMHA == 1)
				{
				bAcceptMulti = true;
				break;
				}
			}

		if(!bAcceptMulti)
			{
			// now cluster downstream
			pClustHit = pCurHit;
			ClustHitIdx = HitIdx;
			while(++ClustHitIdx < m_NumMultiHits)				// checking for clustering downstream of current hit loci
				{
				pClustHit += 1;
				Distance = AdjStartLoci(&pClustHit->HitLoci.Hit.Seg[0]) - AdjStartLoci(&pCurHit->HitLoci.Hit.Seg[0]);
				if(Distance > (UINT32)(cClustMultiOverLap + (int)AdjHitLen(&pCurHit->HitLoci.Hit.Seg[0])))				// can't score if much too far away
					break;

				if(pClustHit->HitLoci.Hit.Seg[0].ChromID != pCurHit->HitLoci.Hit.Seg[0].ChromID)
					break;
				if(!pClustHit->HitLoci.FlagMH || pClustHit->HitLoci.FlagMHA == 1)
					{
					bAcceptMulti = true;
					break;
					}
				}
			}
		if(!bAcceptMulti)
			pCurHit->HitLoci.FlagMHA = 0;
		}
	else
		bAcceptMulti = true;

	if(bAcceptMulti == true)
		{
		if((pAssign2Read = LocateRead(pCurHit->ReadID))==NULL)
			{
			if(NumUnlocated++ < 10)
				gDiagnostics.DiagOut(eDLWarn,gszProcName,"A read (ReadID = %d) was not located in call to LocateRead()",pCurHit->ReadID);
			continue;
			}
		pAssign2Read->HitLoci = pCurHit->HitLoci;
		pAssign2Read->NumHits = 1;
		pAssign2Read->LowHitInstances = 1;
		if(pCurHit->HitLoci.FlagHL == eHLclustunique)
			ClusterUniqueAssigned += 1;
		else
			if(pCurHit->HitLoci.FlagHL == eHLclustany)
				ClusterAllAssigned += 1;
		NumAssigned += 1;
		}
	}

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Clustering completed, removed %d unclustered orphans from %d putative resulting in %d (%d clustered near unique, %d clustered near other multiloci reads) multihit reads accepted as assigned",
					 PutativeAssignments-NumAssigned,PutativeAssignments,NumAssigned,ClusterUniqueAssigned,ClusterAllAssigned);
return(0);
}


int
ReportSAMread(tsReadHit *pSEReadHit,	// single ended read or if pPairReadHit non-null then 1st of paired end reads
 			tsReadHit *pPEReadHit) // if non-null then pair of pReadHit

{
int HamDist;
bool bIsPE;

int NumReads;
tsReadHit *pReadHit;


char szSEQName[128];
char szPEQName[128];
char *pszSEQName;
char *pszPEQName;
char *pszQName;
char *pszRNext;

int SeqIdx;
etSeqBase Sequence[cMaxFastQSeqLen+1];	// to hold sequence (sans quality scores) for current read
char szQScores[cMaxFastQSeqLen+1];		// to hold quality scores for current read
int SumScores;
UINT8 *pSeqVal;
etSeqBase *pSeq;
char *pQScore;
char ExchScore;

int Flags;
int MAPQ;
char szCigar[200];
int GapLen;

int CigarIdx;
int Seg0RightTrimLen;
int Seg0LeftTrimLen;
int Seg0Hitlen;
int Seg1Hitlen;
int Seg1RightTrimLen;
int Seg1LeftTrimLen;

int SEStart;
int PEStart;
int SELen;
int PELen;
int PNext;
int TLen;

int LimitGapErrs;

if(pSEReadHit == NULL)
	return(eBSFerrInternal);

pReadHit = pSEReadHit;

strcpy(szSEQName,ReplaceTabs((char *)pSEReadHit->Read));
pszSEQName = szSEQName;
pszQName = pszSEQName;
if(pPEReadHit != NULL)
	{
	strcpy(szPEQName,ReplaceTabs((char *)pPEReadHit->Read));
	pszPEQName = szPEQName;
	if(!strcmp(pszPEQName,pszSEQName))
		pszRNext = (char *)"=";
	else
		pszRNext = pszPEQName;
	NumReads = 2;
	bIsPE = true;
	PNext = 0;
	SEStart = AdjAlignStartLoci(&pSEReadHit->HitLoci.Hit) + 1;
	PEStart = AdjAlignStartLoci(&pPEReadHit->HitLoci.Hit) + 1;
	SELen = AdjAlignHitLen(&pSEReadHit->HitLoci.Hit);
	PELen = AdjAlignHitLen(&pPEReadHit->HitLoci.Hit);

	if(SEStart <= PEStart)
		TLen = (PEStart - SEStart) + PELen;
	else
		TLen = (SEStart - PEStart) + SELen;
	}
else
	{
	szPEQName[0] = '\0';
	pszRNext = (char *)"*";
	pszPEQName = NULL;
	NumReads = 1;
	bIsPE = false;
	PNext = 0;
	TLen = 0;
	}

LimitGapErrs = 10;
while(NumReads--)
	{
	pSeqVal = &pReadHit->Read[pReadHit->DescrLen+1];
	pSeq = Sequence;
	pQScore = szQScores;
	SumScores = 0;
	for(SeqIdx = 0; SeqIdx < pReadHit->ReadLen; SeqIdx++,pSeq++,pQScore++,pSeqVal++)
		{
		*pSeq = (*pSeqVal & 0x07);		// not interested in any soft masking within a SAM sequence
		SumScores += (*pSeqVal >> 4) & 0x0f;	// any quality scores would be in bits 4..7
		*pQScore = (char)(33 + ((((*pSeqVal >> 4) & 0x0f) * 40))/15);
		}
	if(SumScores == 0)		// if there were no associated quality scores
		{
		szQScores[0] = '*';
		szQScores[1] = '\0';
		}
	else
		{
		*pQScore = '\0';
		if(pReadHit->NumHits == 1 && pReadHit->HitLoci.Hit.Seg[0].Strand != '+')	// sequence is reversed so quality scores also should be
			{
			pQScore -= 1;
			for(SeqIdx = 0; SeqIdx < (pReadHit->ReadLen/2); SeqIdx++,pQScore--)
				{
				ExchScore = szQScores[SeqIdx];
				szQScores[SeqIdx] = *pQScore;
				*pQScore = ExchScore;
				}
			}
		}

	if(pReadHit->NumHits == 1)
		{
		if(pReadHit->HitLoci.Hit.Seg[0].ChromID != (UINT32)m_PrevSAMTargEntry)
			{
			m_pSfxArray->GetIdentName(pReadHit->HitLoci.Hit.Seg[0].ChromID,sizeof(m_szSAMTargChromName),m_szSAMTargChromName);
			m_PrevSAMTargEntry = pReadHit->HitLoci.Hit.Seg[0].ChromID;
			}

		HamDist = LocateHamming(m_szSAMTargChromName,AdjStartLoci(&pReadHit->HitLoci.Hit.Seg[0]));
		Flags = pReadHit->HitLoci.Hit.Seg[0].Strand == '+' ? 0x00 : 0x010;

		if(bIsPE)						// if PE
			{
			Flags |= 0x03;				// assumes if PE then both have been mapped
			Flags |= NumReads == 1 ? 0x040 : 0x080;
			if(NumReads == 1)
				Flags |= pPEReadHit->HitLoci.Hit.Seg[0].Strand == '+' ? 0x00 : 0x020;
			}
		}
	else
		Flags = 0x04;			// flags as being unmapped


	if(pReadHit->NumHits != 1 || HamDist == 0 || (2 * pReadHit->LowMMCnt) >= HamDist)
		MAPQ = 255;
	else
		MAPQ = (int)(100.0 * log((double)HamDist - (2.0 * pReadHit->LowMMCnt)) / log(100.0));

	if(pReadHit->NumHits == 1)
		{
		CigarIdx = 0;
		Seg0RightTrimLen = pReadHit->HitLoci.Hit.Seg[0].TrimRight;
		Seg0LeftTrimLen = pReadHit->HitLoci.Hit.Seg[0].TrimLeft;
		Seg0Hitlen = AdjHitLen(&pReadHit->HitLoci.Hit.Seg[0]);
		Seg1Hitlen = 0;
		Seg1RightTrimLen = 0;
		Seg1LeftTrimLen = 0;

		CigarIdx = 0;

		if(pReadHit->HitLoci.Hit.Seg[0].Strand == '+')
			{
			if(Seg0LeftTrimLen != 0)
				CigarIdx = sprintf(szCigar,"%dS",Seg0LeftTrimLen);
			CigarIdx += sprintf(&szCigar[CigarIdx],"%dM",Seg0Hitlen);
			if(Seg0RightTrimLen > 0)
				CigarIdx += sprintf(&szCigar[CigarIdx],"%dS",Seg0RightTrimLen);
			}
		else
			{
			if(Seg0RightTrimLen != 0)
				CigarIdx = sprintf(szCigar,"%dS",Seg0RightTrimLen);
			CigarIdx += sprintf(&szCigar[CigarIdx],"%dM",Seg0Hitlen);
			if(Seg0LeftTrimLen > 0)
				CigarIdx += sprintf(&szCigar[CigarIdx],"%dS",Seg0LeftTrimLen);
			}

		if(pReadHit->HitLoci.FlagSegs != 0)
			{
			Seg1Hitlen = AdjHitLen(&pReadHit->HitLoci.Hit.Seg[1]);
			Seg1LeftTrimLen = pReadHit->HitLoci.Hit.Seg[1].TrimLeft;
			Seg1RightTrimLen = pReadHit->HitLoci.Hit.Seg[1].TrimRight;
			if(pReadHit->HitLoci.Hit.FlgSplice == 1)  // splice
				{
				GapLen = (int)pReadHit->HitLoci.Hit.Seg[1].MatchLoci - (int)(pReadHit->HitLoci.Hit.Seg[0].MatchLoci + pReadHit->HitLoci.Hit.Seg[0].MatchLen);
				CigarIdx += sprintf(&szCigar[CigarIdx],"%dN",GapLen);
				}
			else   // else if an InDel
				{
				if(pReadHit->HitLoci.Hit.FlgInsert)
					{
					GapLen = pReadHit->ReadLen -
								((pReadHit->HitLoci.Hit.Seg[0].MatchLen - pReadHit->HitLoci.Hit.Seg[0].TrimRight) +
								 (pReadHit->HitLoci.Hit.Seg[1].MatchLen  - pReadHit->HitLoci.Hit.Seg[1].TrimLeft));
					if(LimitGapErrs-- > 0 && GapLen <= 0)
						gDiagnostics.DiagOut(eDLInfo,gszProcName,"Check - an apparent insertion GapLen of %d",GapLen);
					CigarIdx += sprintf(&szCigar[CigarIdx],"%dI",GapLen);
					}
				else
					{
					GapLen = (int)pReadHit->HitLoci.Hit.Seg[1].MatchLoci -
						(int)(pReadHit->HitLoci.Hit.Seg[0].MatchLoci + pReadHit->HitLoci.Hit.Seg[0].MatchLen);
					if(LimitGapErrs-- > 0 && GapLen <= 0)
						gDiagnostics.DiagOut(eDLInfo,gszProcName,"Check - an apparent deletion GapLen of %d",GapLen);
					CigarIdx += sprintf(&szCigar[CigarIdx],"%dD",abs(GapLen));
					}
				}

			if(pReadHit->HitLoci.Hit.Seg[0].Strand == '+')
				{
				if(Seg1LeftTrimLen != 0)
					CigarIdx += sprintf(szCigar,"%dS",Seg1LeftTrimLen);
				CigarIdx += sprintf(&szCigar[CigarIdx],"%dM",Seg1Hitlen);
				if(Seg1RightTrimLen > 0)
					CigarIdx += sprintf(&szCigar[CigarIdx],"%dS",Seg1RightTrimLen);
				}
			else
				{
				if(Seg1RightTrimLen != 0)
					CigarIdx += sprintf(szCigar,"%dS",Seg1RightTrimLen);
				CigarIdx += sprintf(&szCigar[CigarIdx],"%dM",Seg1Hitlen);
				if(Seg1LeftTrimLen > 0)
					CigarIdx += sprintf(&szCigar[CigarIdx],"%dS",Seg1LeftTrimLen);
				}

			}

		if(bIsPE)
			{
			if(NumReads == 1)
				PNext = AdjStartLoci(&pPEReadHit->HitLoci.Hit.Seg[0])+1;
			else
				PNext = AdjStartLoci(&pSEReadHit->HitLoci.Hit.Seg[0])+1;
			}

		m_szLineBuffIdx+=sprintf(&m_pszLineBuff[m_szLineBuffIdx],"%s\t%d\t%s\t%d\t%d\t%s\t%s\t%d\t%d\t",
							pszQName,				// original read descriptor
							Flags,m_szSAMTargChromName,AdjStartLoci(&pReadHit->HitLoci.Hit.Seg[0])+1,MAPQ,szCigar,pszRNext,PNext,TLen);
		TLen *= -1;
		}
	else
		{
		m_szLineBuffIdx+=sprintf(&m_pszLineBuff[m_szLineBuffIdx],"%s\t%d\t%s\t%d\t%d\t%s\t%s\t0\t0\t",
							pszQName,				// original read descriptor
							Flags,"*",0,MAPQ,"*",pszRNext);
		}

	if(pReadHit->NumHits == 1 && pReadHit->HitLoci.Hit.Seg[0].Strand != '+')   // 1.1.6 seems that downstream applications are expecting the read sequences to be reverse complemented if sequence was mapped to Crick strand????
		CSeqTrans::ReverseComplement(pReadHit->ReadLen,Sequence);
	m_szLineBuffIdx+=sprintf(&m_pszLineBuff[m_szLineBuffIdx],"%s\t%s\n",CSeqTrans::MapSeq2Ascii(Sequence,pReadHit->ReadLen),szQScores);
	if(m_szLineBuffIdx + ((cMaxFastQSeqLen * 10) + 1024) > cAllocLineBuffSize)
		{
		CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,m_szLineBuffIdx);
		m_szLineBuffIdx = 0;
		}


	if(NumReads)
		{
		pReadHit = pPEReadHit;
		pszQName = pszPEQName;
		if(pszRNext[0] != '=')
			pszRNext = pszSEQName;
		}
	}

return(eBSFSuccess);
}



// Write results as SAMtools format
//
int
WriteSAMReadHits(etFMode SAMformat,	   // eFMsam or eFMsamAll
				bool bPEProc)		   // true if processing paired ends
{
int Rslt;
char szChromName[128];

tsReadHit *pReadHit;
tsReadHit *pPE2ReadHit;
tBSFEntryID PrevTargEntry;
int NumChroms;
UINT32 ChromSeqLen;
int ChromID;

if(bPEProc)
	SortReadHits(eRSMPEHitMatch,false);

NumChroms = m_pSfxArray->GetNumEntries();

// firstly is the header with the sequence chromosome directory
// it is probable that many of the chroms may not actually have any alignments but filtering these out could be costly 
m_szLineBuffIdx = sprintf(m_pszLineBuff,"@HD\tVN:1.0\tS0:unknown");

for(ChromID = 1; ChromID <= NumChroms; ChromID++)
	{
	m_pSfxArray->GetIdentName(ChromID,sizeof(szChromName),szChromName);
	ChromSeqLen=m_pSfxArray->GetSeqLen(ChromID);
	m_szLineBuffIdx += sprintf(&m_pszLineBuff[m_szLineBuffIdx],"\n@SQ\tAS:%s\tSN:%s\tLN:%u",m_szTargSpecies,szChromName,ChromSeqLen);
	if(m_szLineBuffIdx > cAllocLineBuffSize/2)
		{
		CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,m_szLineBuffIdx);
		m_szLineBuffIdx = 0;
		}
	}
m_szLineBuffIdx += sprintf(&m_pszLineBuff[m_szLineBuffIdx],"\n@PG\tID:%s\tVN:%s\n",gszProcName,cpszProgVer);
CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,m_szLineBuffIdx);
m_szLineBuffIdx = 0;

// now write out each alignment in SAM format
pReadHit = NULL;
pPE2ReadHit = NULL;
PrevTargEntry = 0;
m_PrevSAMTargEntry = 0;
while((pReadHit = IterSortedReads(pReadHit))!=NULL)
	{
	if(bPEProc)
		pPE2ReadHit = IterSortedReads(pReadHit);

	if(((pPE2ReadHit == NULL || pPE2ReadHit->NumHits == 1) && pReadHit->NumHits == 1) || SAMformat == eFMsamAll)
		{
		if((Rslt = ReportSAMread(pReadHit,pPE2ReadHit)) < eBSFSuccess)
			return(Rslt);
		// user may be interested in the distribution of the aligner induced substitutions, after any auto-trimming of flanks,
		// along the length of the reads and how this distribution relates to the quality scores
		if(m_hStatsFile != -1 && SAMformat != eFMsamAll)
			{
			WriteSubDist(pReadHit);
			if(pPE2ReadHit != NULL)
				WriteSubDist(pPE2ReadHit);
			}
		}
	if(bPEProc)
		pReadHit = pPE2ReadHit;
	}

m_szLineBuffIdx += sprintf(&m_pszLineBuff[m_szLineBuffIdx],"\0");
if(m_szLineBuffIdx)
	CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,m_szLineBuffIdx);

if(bPEProc)
	SortReadHits(eRSMHitMatch,false);
return(eBSFSuccess);
}


// ReplaceTabs
// Inplace replacement of any tabs with a single space char
char *
ReplaceTabs(char *pszTabTxt)
{
char Chr;
char *pTxt = pszTabTxt;
while(Chr = *pTxt++)
	if(Chr == '\t')
		pTxt[-1]=' ';
return(pszTabTxt);
}

int
AppendStr(char *pszBuff,	// write to this buffer
		  char LeadSep,		// if != '\0' then prefix with this separator (usually ',' or '\t')
		  char Quote,		// if != '\0' then quote string with this char (usually single or double quote char)
		  char *pStr,		// '\0' terminated string
		  char TrailSep)	// if != '\0' then suffix with this separator (usually ',' or '\t' or '\n')
{
int Len = 0;
if(LeadSep != '\0')
	{
	*pszBuff++ = LeadSep;
	Len += 1;
	}
if(Quote != '\0')
	{
	*pszBuff++ = Quote;
	Len += 1;
	}
while(*pStr)
	{
	*pszBuff++ = *pStr++;
	Len += 1;
	}
if(Quote != '\0')
	{
	*pszBuff++ = Quote;
	Len += 1;
	}
if(TrailSep != '\0')
	{
	*pszBuff++ = TrailSep;
	Len += 1;
	}
*pszBuff = '\0';
return(Len);
}

int
AppendChrs(char *pszBuff,	// write to this buffer
		  char LeadSep,		// if != '\0' then prefix with this separator (usually ',' or '\t')
		  char Quote,		// if != '\0' then quote chars with this char (usually single or double quote char)
		  int NumChrs,		// number of chars to append
		  char *Chrs,		// pts to chars to append
		  char TrailSep)	// if != '\0' then suffix with this separator (usually ',' or '\t' or '\n')
{
int Len = 0;
if(LeadSep != '\0')
	{
	*pszBuff++ = LeadSep;
	Len += 1;
	}
if(Quote != '\0')
	{
	*pszBuff++ = Quote;
	Len += 1;
	}
if(NumChrs)
	{
	while(NumChrs--)
		{
		*pszBuff++ = *Chrs++;
		Len += 1;
		}
	}
if(Quote != '\0')
	{
	*pszBuff++ = Quote;
	Len += 1;
	}
if(TrailSep != '\0')
	{
	*pszBuff++ = TrailSep;
	Len += 1;
	}
*pszBuff = '\0';
return(Len);
}


// very fast version of uitoa
int							// length written
AppendUInt(char *pszBuff,	// write to this buffer
		  char LeadSep,		// if > '\0' then prefix with this separator (usually ',' or '\t')
		  UINT32 Value,
		  char TrailSep)	// if > '\0' then suffix with this separator (usually ',' or '\t' or '\n')
{
int Len = 0;
char *pChr;
char *pMark;
char Tmp;
if(LeadSep != '\0')
	{
	*pszBuff++ = LeadSep;
	Len += 1;
	}

if(Value)
	{
	pChr = pszBuff;
	while(Value)
		{
		*pChr++ = '0' + (char)(Value%10);
		Value/=10;
		Len += 1;
		}
	pMark = pChr;
	*pChr-- = '\0';
	while(pszBuff < pChr)
		{
		Tmp = *pChr;
		*pChr-- = *pszBuff;
		*pszBuff++ = Tmp;
		}
	pszBuff = pMark;
	}
else
	{
	Len += 1;
	*pszBuff++ = '0';
	}
if(TrailSep)
	{
	Len += 1;
	*pszBuff++ = TrailSep;
	}
*pszBuff = '\0';
return(Len);
}

// user may be interested in the distribution of the aligner induced substitutions, after any auto-trimming of flanks,
// along the length of the reads and how this distribution relates to the quality scores
int
WriteSubDist(tsReadHit *pReadHit)
{
int QScoreIdx;
int NumMSubs;
int SeqIdx;
UINT8 *pSeqVal;
etSeqBase *pAssembSeq;
tsSegLoci *pSeg;

etSeqBase AssembSeq[cMaxFastQSeqLen+1];	// to hold targeted genome assembly sequence

if(m_hStatsFile == -1)
	return(eBSFSuccess);

if(pReadHit->HitLoci.FlagSegs!=0)		// if read was segmented because of InDel or splice junction then can't handle, simply slough
	return(eBSFSuccess);

pSeg = &pReadHit->HitLoci.Hit.Seg[0];
if(pSeg->ChromID == 0)
	return(eBSFSuccess);
if(pSeg->Strand == '\0')	// default strand to be sense if not specified
	pSeg->Strand = '+';

m_pSfxArray->GetSeq(pSeg->ChromID,AdjStartLoci(pSeg),AssembSeq,AdjHitLen(pSeg));	// get sequence for entry starting at offset and of length len
if(pSeg->Strand == '-')
	CSeqTrans::ReverseComplement(AdjHitLen(pSeg),AssembSeq);
		
if(m_MaxAlignLen < pReadHit->ReadLen)
	m_MaxAlignLen = pReadHit->ReadLen;

pSeqVal = &pReadHit->Read[pReadHit->DescrLen+1];
pSeqVal += pSeg->ReadOfs + pSeg->TrimLeft;
pAssembSeq = AssembSeq;
NumMSubs = 0;
for(SeqIdx = pSeg->ReadOfs + pSeg->TrimLeft; SeqIdx < (pReadHit->ReadLen - pSeg->TrimRight); SeqIdx++, pSeqVal++, pAssembSeq++)
	{
	QScoreIdx = (*pSeqVal >> 4) & 0x0f;
	// note that Phred scores were scaled to fit within 4bits (((Phred + 2)* 15)/40) by genreads
	if(QScoreIdx <= 3)		//Phred 0..8?
		QScoreIdx = 0;
	else
		if(QScoreIdx <= 7)	// Phred 9..19?
			QScoreIdx = 1;
		else
			if(QScoreIdx <= 11) // Phred 20..29?
				QScoreIdx = 2;
			else
				QScoreIdx = 3;	// Phred 30+
	m_AlignQSubDist[QScoreIdx][SeqIdx].QInsts += 1;
	if((*pSeqVal & 0x07) != (*pAssembSeq & 0x07))
		{
		m_AlignQSubDist[QScoreIdx][SeqIdx].Subs += 1;
		NumMSubs += 1;
		}
	}
if(m_MaxMSubDist < NumMSubs)
	m_MaxMSubDist = NumMSubs;
m_AlignMSubDist[NumMSubs] += 1;

return(eBSFSuccess);
}


int
WriteReadHits(bool bPEProc)		   // true if processing paired ends	
{
int HamDist;
const char *pszBsMap;
int LineLen;
char szChromName[128];
int SeqIdx;
etSeqBase ReadSeq[cMaxFastQSeqLen+1];	// to hold sequence (sans quality scores) for current read
etSeqBase AssembSeq[cMaxFastQSeqLen+1];	// to hold targeted genome assembly sequence

UINT8 *pSeqVal;
etSeqBase *pReadSeq;

tsReadHit *pReadHit;
tBSFEntryID PrevTargEntry;

m_MaxAlignLen = 0;

if(m_FMode == eFMbed)
	{
	LineLen = sprintf(m_pszLineBuff,"track type=bed name=\"%s\" description=\"%s\"\n",m_pszTrackTitle,m_pszTrackTitle);
	CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,LineLen);

	if(m_hJctOutFile != -1)
		{
		LineLen = sprintf(m_pszLineBuff,"track type=bed name=\"JCT_%s\" description=\"%s\"\n",m_pszTrackTitle,m_pszTrackTitle);
		CUtility::SafeWrite(m_hJctOutFile,m_pszLineBuff,LineLen);
		}

	if(m_hIndOutFile != -1)
		{
		LineLen = sprintf(m_pszLineBuff,"track type=bed name=\"IND_%s\" description=\"%s\"\n",m_pszTrackTitle,m_pszTrackTitle);
		CUtility::SafeWrite(m_hIndOutFile,m_pszLineBuff,LineLen);
		}
	LineLen = 0;
	}

pReadHit = NULL;
LineLen = 0;
PrevTargEntry = 0;
const char *pszAlignType;

bool bPrevInDelSeg = false;
bool bPrevJunctSeg = false;
bool bPrevAlignSeg = false;

while((pReadHit = IterSortedReads(pReadHit))!=NULL)
	{
	if(pReadHit->NumHits == 1)
		{
		if(pReadHit->HitLoci.Hit.FlgInDel)
			pszAlignType = "ari";
		else
			if(pReadHit->HitLoci.Hit.FlgSplice)
				pszAlignType = "arj";
			else
				pszAlignType = "ar";

		if(pReadHit->HitLoci.FlagIA == 1)
			{
			if(pReadHit->HitLoci.Hit.FlgInDel)
				pszAlignType = "iari";
			else
				if(pReadHit->HitLoci.Hit.FlgSplice)
					pszAlignType = "iarj";
				else
					pszAlignType = "iar";
			}
		else
			{
			if(pReadHit->HitLoci.Hit.FlgInDel)
				pszAlignType = "ari";
			else
				if(pReadHit->HitLoci.Hit.FlgSplice)
					pszAlignType = "arj";
				else
					pszAlignType = "ar";
			}

		tsSegLoci *pSeg;
		int SegIdx;

		pSeg = &pReadHit->HitLoci.Hit.Seg[0];
		if(pSeg->ChromID != (UINT32)PrevTargEntry)
			{
			m_pSfxArray->GetIdentName(pSeg->ChromID,sizeof(szChromName),szChromName);
			PrevTargEntry = pSeg->ChromID;
			}

		if(pSeg->Strand == '\0')	// default strand to be sense if not specified
			pSeg->Strand = '+';

		int Score = (int)min(1000.0,(999 * m_OctSitePrefs[pSeg->Strand == '+' ? 0 : 1][pReadHit->SiteIdx].RelScale));

		if(m_FMode == eFMbed)
			{
			if(pReadHit->HitLoci.FlagSegs==0)
				{
				if(bPrevInDelSeg || bPrevJunctSeg)
					{
					if(LineLen > 0)
						{
						CUtility::SafeWrite(bPrevInDelSeg ? m_hIndOutFile : m_hJctOutFile,m_pszLineBuff,LineLen);
						LineLen = 0;
						}
					bPrevInDelSeg = false;
					bPrevJunctSeg = false;
					}
				pSeg = &pReadHit->HitLoci.Hit.Seg[0];

				LineLen+=sprintf(&m_pszLineBuff[LineLen],"%s\t%d\t%d\t%s\t%d\t%c\n",
					szChromName,AdjStartLoci(pSeg),AdjEndLoci(pSeg) + 1,pszAlignType,Score,pSeg->Strand);
				bPrevAlignSeg = true;
				}
			else // segmented alignment
				{
				if(bPrevAlignSeg)
					{
					if(LineLen > 0)
						{
						CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,LineLen);
						LineLen = 0;
						}
					bPrevAlignSeg = false;
					}
				if(pReadHit->HitLoci.Hit.FlgInDel)
					{
					if(bPrevJunctSeg)
						{
						if(LineLen > 0)
							{
							CUtility::SafeWrite(m_hJctOutFile,m_pszLineBuff,LineLen);
							LineLen = 0;
							}
						bPrevJunctSeg = false;
						}
					bPrevInDelSeg = true;
					}
				else
					{
					if(bPrevInDelSeg)
						{
						if(LineLen > 0)
							{
							CUtility::SafeWrite(m_hIndOutFile,m_pszLineBuff,LineLen);
							LineLen = 0;
							}
						bPrevInDelSeg = false;
						}
					bPrevJunctSeg = true;
					}

			    int AjAlignStartLoci;
				int AjAlignEndLoci;

				AjAlignStartLoci = AdjAlignStartLoci(&pReadHit->HitLoci.Hit);
				AjAlignEndLoci = AdjAlignEndLoci(&pReadHit->HitLoci.Hit);
				LineLen+=sprintf(&m_pszLineBuff[LineLen],"%s\t%d\t%d\t%s\t%d\t%c\t%d\t%d\t0\t2\t%d,%d\t0,%d\n",
					szChromName,AjAlignStartLoci,AjAlignEndLoci+1,pszAlignType,Score,pSeg->Strand,AjAlignStartLoci,AjAlignEndLoci+1,
					       AdjHitLen(pSeg),AdjHitLen(&pSeg[1]),AdjStartLoci(&pSeg[1])-AdjStartLoci(pSeg));
				}

			if((cAllocLineBuffSize - LineLen) < 1000)
				{
				if(bPrevAlignSeg)
					{
					CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,LineLen);
					LineLen = 0;
					bPrevAlignSeg = false;
					}
				else
					{
					CUtility::SafeWrite(bPrevInDelSeg ? m_hIndOutFile : m_hJctOutFile,m_pszLineBuff,LineLen);
					LineLen = 0;
					bPrevInDelSeg = false;
					bPrevJunctSeg = false;
					}
				}
			continue;
			}

		if(!m_bIsSOLiD && m_FMode >= eFMread)
			{
			pSeqVal = &pReadHit->Read[pReadHit->DescrLen+1];
			pReadSeq = ReadSeq;
			for(SeqIdx = 0; SeqIdx < pReadHit->ReadLen; SeqIdx++,pReadSeq++,pSeqVal++)
				*pReadSeq = (*pSeqVal & 0x07);
			}
		bPrevAlignSeg = true;
		for(SegIdx = 0; SegIdx < 2; SegIdx++)
			{
			pSeg = &pReadHit->HitLoci.Hit.Seg[SegIdx];
			if(pSeg->ChromID == 0)
				continue;
			if(pSeg->Strand == '\0')	// default strand to be sense if not specified
				pSeg->Strand = '+';
			if(pSeg->ChromID != (UINT32)PrevTargEntry)
				{
				m_pSfxArray->GetIdentName(pSeg->ChromID,sizeof(szChromName),szChromName);
				PrevTargEntry = pSeg->ChromID;
				}

			HamDist = LocateHamming(szChromName,AdjStartLoci(pSeg));
			LineLen += AppendUInt(&m_pszLineBuff[LineLen],0,pReadHit->ReadID,',');
			LineLen += AppendStr(&m_pszLineBuff[LineLen],0,'"',(char *)pszAlignType,',');
			LineLen += AppendStr(&m_pszLineBuff[LineLen],0,'"',m_szTargSpecies,',');
			LineLen += AppendStr(&m_pszLineBuff[LineLen],0,'"',szChromName,',');

			LineLen += AppendUInt(&m_pszLineBuff[LineLen],0,AdjStartLoci(pSeg),',');
			LineLen += AppendUInt(&m_pszLineBuff[LineLen],0,AdjEndLoci(pSeg),',');
			LineLen += AppendUInt(&m_pszLineBuff[LineLen],0,AdjHitLen(pSeg),',');
			LineLen += AppendChrs(&m_pszLineBuff[LineLen],0,'"',1,(char *)&pSeg->Strand,',');
			LineLen += AppendUInt(&m_pszLineBuff[LineLen],0,Score,',');
			LineLen += AppendUInt(&m_pszLineBuff[LineLen],0,HamDist,'\0');

			if(m_bBisulfite) {
				switch(pReadHit->HitLoci.Hit.BisBase) {
					case eBaseT:
						pszBsMap = "TC:C";
						break;
					case eBaseA:
						pszBsMap = "AG:T";
						break;
					default:
						pszBsMap = "?:?";
					}
				}
			else
				pszBsMap = "N/A";

			LineLen += AppendUInt(&m_pszLineBuff[LineLen],',',pReadHit->NumReads,',');
			LineLen += AppendUInt(&m_pszLineBuff[LineLen],0,pSeg->TrimMismatches,',');
			LineLen += AppendStr(&m_pszLineBuff[LineLen],0,'"',(char *)pszBsMap,',');
			LineLen += AppendStr(&m_pszLineBuff[LineLen],0,'"',(char *)pReadHit->Read,'\0');

			if(m_FMode >= eFMread)
				LineLen += AppendStr(&m_pszLineBuff[LineLen],',','"',CSeqTrans::MapSeq2Ascii(&ReadSeq[pSeg->ReadOfs+pSeg->TrimLeft],AdjHitLen(pSeg)),0);
			if(m_FMode == eFMmatch || m_FMode == eFMreadmatch)
				{
				m_pSfxArray->GetSeq(pSeg->ChromID,AdjStartLoci(pSeg),AssembSeq,AdjHitLen(pSeg));	// get sequence for entry starting at offset and of length len
				if(pSeg->Strand == '-')
					CSeqTrans::ReverseComplement(AdjHitLen(pSeg),AssembSeq);
				LineLen += AppendStr(&m_pszLineBuff[LineLen],',','"',CSeqTrans::MapSeq2Ascii(AssembSeq,AdjHitLen(pSeg)),0);
				}

			LineLen += AppendStr(&m_pszLineBuff[LineLen],0,0,(char *)"\n",0);
			if(LineLen + ((cMaxFastQSeqLen * 2) + 1024) > cAllocLineBuffSize)
				{
				CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,LineLen);
				LineLen = 0;
				}
			}

		// user may be interested in the distribution of the aligner induced substitutions, after any auto-trimming of flanks,
		// along the length of the reads and how this distribution relates to the quality scores
		if(m_hStatsFile != -1)
			WriteSubDist(pReadHit);
		}
	}
if(LineLen)
	{
	if(bPrevAlignSeg)
		{
		CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,LineLen);
		LineLen = 0;
		bPrevAlignSeg = false;
		}
	else
		{
		CUtility::SafeWrite(bPrevInDelSeg ? m_hIndOutFile : m_hJctOutFile,m_pszLineBuff,LineLen);
		LineLen = 0;
		bPrevInDelSeg = false;
		bPrevJunctSeg = false;
		}
	}
return(eBSFSuccess);
}




int
WriteHitLoci(tsThreadMatchPars *pThreadPars,tsReadHit *pReadHit,int NumHits,tsHitLoci *pHits)
{
tsHitLoci *pHit;
tsSegLoci *pSeg;
int HamDist;
const char *pszBsMap;
char szChromName[128];
int SeqIdx;
etSeqBase ReadSeq[cMaxFastQSeqLen+1];	// to hold sequence (sans quality scores) for current read
etSeqBase AssembSeq[cMaxFastQSeqLen+1];	// to hold targeted genome assembly sequence

int ReadHitBuffIdx;						// index into output szReadHits
UINT8 *pSeqVal;
etSeqBase *pReadSeq;

tBSFEntryID PrevTargEntry;
//tsReadHit ReadHit;
UINT8 ReadHit[sizeof(tsReadHit) + cMaxDescrLen + cMaxFastQSeqLen + 10];
tsReadHit *pSAMHit;

m_MaxAlignLen = 0;
PrevTargEntry = 0;
const char *pszAlignType;
ReadHitBuffIdx = 0;
pHit = pHits;
if(m_FMode == eFMsam || m_FMode == eFMsamAll)
	{
	pSAMHit = (tsReadHit *)&ReadHit;
	memcpy(&ReadHit,pReadHit,sizeof(tsReadHit) + pReadHit->ReadLen + pReadHit->DescrLen);
	if(NumHits == 0)
		{
		pSAMHit->NumHits = 0;
		NumHits = 1;
		}
	else
		pSAMHit->NumHits = 1;

	}
for(int HitIdx = 0; HitIdx < NumHits; HitIdx++,pHit++)
	{
	if(!(m_FMode == eFMsam || m_FMode == eFMsamAll))
		{
		pszAlignType = "ar";

		pSeg = &pHit->Seg[0];
		if(pSeg->ChromID != (UINT32)PrevTargEntry)
			{
			m_pSfxArray->GetIdentName(pSeg->ChromID,sizeof(szChromName),szChromName);
			PrevTargEntry = pSeg->ChromID;
			}
		}
	else
		{
		if(pSAMHit->NumHits > 0)
			{
			memcpy(&pSAMHit->HitLoci.Hit,pHit,sizeof(tsHitLoci));
			pSAMHit->HitLoci.FlagSegs = (pHit->FlgInDel == 1 || pHit->FlgSplice == 1) ? 1 : 0;
			}
		else
			pSAMHit->HitLoci.FlagSegs = 0;

#ifdef _WIN32
		DWORD WaitRslt = WaitForSingleObject(m_hMtxMultiMatches,INFINITE);
#else
		pthread_mutex_lock(&m_hMtxMultiMatches);
#endif
		ReportSAMread(pSAMHit,NULL);
#ifdef _WIN32
		ReleaseMutex(m_hMtxMultiMatches);
#else
		pthread_mutex_unlock(&m_hMtxMultiMatches);
#endif
		continue;
		}

	if(m_FMode == eFMbed)
		{
		pThreadPars->OutBuffIdx +=sprintf((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],"%s\t%d\t%d\t%s\t%d\t%c\n",
			szChromName,AdjStartLoci(pSeg),AdjEndLoci(pSeg) + 1,pszAlignType,NumHits > 1000 ? 1000 : NumHits, pSeg->Strand);
		if((cReadHitBuffLen - pThreadPars->OutBuffIdx) < 500)
			{
#ifdef _WIN32
			WaitForSingleObject(m_hMtxMultiMatches,INFINITE);
#else
			pthread_mutex_lock(&m_hMtxMultiMatches);
#endif
			if((cAllocLineBuffSize - m_szLineBuffIdx) < (pThreadPars->OutBuffIdx+1000))
				{
				CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,m_szLineBuffIdx);
				m_szLineBuffIdx = 0;
				}
			memcpy(&m_pszLineBuff[m_szLineBuffIdx],pThreadPars->pszOutBuff,pThreadPars->OutBuffIdx);
			m_szLineBuffIdx += pThreadPars->OutBuffIdx;
#ifdef _WIN32
			ReleaseMutex(m_hMtxMultiMatches);
#else
			pthread_mutex_unlock(&m_hMtxMultiMatches);
#endif
			pThreadPars->OutBuffIdx = 0;
			}
		continue;
		}

	// reporting hits as CSV...
	if(!m_bIsSOLiD && m_FMode >= eFMread)
		{
		pSeqVal = &pReadHit->Read[pReadHit->DescrLen+1];
		pReadSeq = ReadSeq;
		for(SeqIdx = 0; SeqIdx < pReadHit->ReadLen; SeqIdx++,pReadSeq++,pSeqVal++)
			*pReadSeq = (*pSeqVal & 0x07);
		}


	HamDist = LocateHamming(szChromName,AdjStartLoci(pSeg));

	pThreadPars->OutBuffIdx += AppendUInt((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,pReadHit->ReadID,',');
	pThreadPars->OutBuffIdx += AppendStr((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,'"',(char *)pszAlignType,',');
	pThreadPars->OutBuffIdx += AppendStr((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,'"',m_szTargSpecies,',');
	pThreadPars->OutBuffIdx += AppendStr((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,'"',szChromName,',');

	pThreadPars->OutBuffIdx += AppendUInt((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,AdjStartLoci(pSeg),',');
	pThreadPars->OutBuffIdx += AppendUInt((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,AdjEndLoci(pSeg),',');
	pThreadPars->OutBuffIdx += AppendUInt((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,AdjHitLen(pSeg),',');
	pThreadPars->OutBuffIdx += AppendChrs((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,'"',1,(char *)&pSeg->Strand,',');
	pThreadPars->OutBuffIdx += AppendUInt((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,(int)m_FMode,',');
	pThreadPars->OutBuffIdx += AppendUInt((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,HamDist,'\0');

	if(m_bBisulfite) {
		switch(pReadHit->HitLoci.Hit.BisBase) {
			case eBaseT:
				pszBsMap = "TC:C";
				break;
			case eBaseA:
				pszBsMap = "AG:T";
				break;
			default:
				pszBsMap = "?:?";
			}
		}
	else
		pszBsMap = "N/A";

	pThreadPars->OutBuffIdx += AppendUInt((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],',',pReadHit->NumReads,',');
	pThreadPars->OutBuffIdx += AppendUInt((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,pSeg->TrimMismatches,',');
	pThreadPars->OutBuffIdx += AppendStr((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,'"',(char *)pszBsMap,',');
	pThreadPars->OutBuffIdx += AppendStr((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,'"',(char *)pReadHit->Read,'\0');

	if(m_FMode >= eFMread)
		pThreadPars->OutBuffIdx += AppendStr((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],',','"',CSeqTrans::MapSeq2Ascii(&ReadSeq[pSeg->ReadOfs + pSeg->TrimLeft],AdjHitLen(pSeg)),0);
	if(m_FMode == eFMmatch || m_FMode == eFMreadmatch)
		{
		m_pSfxArray->GetSeq(pSeg->ChromID,AdjStartLoci(pSeg),AssembSeq,AdjHitLen(pSeg));	// get sequence for entry starting at offset and of length len
		if(pSeg->Strand == '-')
			CSeqTrans::ReverseComplement(AdjHitLen(pSeg),AssembSeq);
		pThreadPars->OutBuffIdx += AppendStr((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],',','"',CSeqTrans::MapSeq2Ascii(AssembSeq,AdjHitLen(pSeg)),0);
		}

	pThreadPars->OutBuffIdx += AppendStr((char *)&pThreadPars->pszOutBuff[pThreadPars->OutBuffIdx],0,0,(char *)"\n",0);

	if((cReadHitBuffLen - pThreadPars->OutBuffIdx) < ((cMaxFastQSeqLen * 2) + 1024))
		{
#ifdef _WIN32
		WaitForSingleObject(m_hMtxMultiMatches,INFINITE);
#else
		pthread_mutex_lock(&m_hMtxMultiMatches);
#endif
		if((cAllocLineBuffSize - m_szLineBuffIdx) < (int)(pThreadPars->OutBuffIdx + ((cMaxFastQSeqLen * 2) + 1024)))
			{
			CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,m_szLineBuffIdx);
			m_szLineBuffIdx = 0;
			}
		memcpy(&m_pszLineBuff[m_szLineBuffIdx],pThreadPars->pszOutBuff,pThreadPars->OutBuffIdx);
		m_szLineBuffIdx += pThreadPars->OutBuffIdx;
#ifdef _WIN32
		ReleaseMutex(m_hMtxMultiMatches);
#else
		pthread_mutex_unlock(&m_hMtxMultiMatches);
#endif
		pThreadPars->OutBuffIdx = 0;
		}
	}
return(eBSFSuccess);
}


// ProcessSNPs
// Currently can't process for SNPs in InDels or splice junctions
// FDR: Benjamini–Hochberg
// QValue == acceptable FDR e.g. 0.05% or 0.01%
// PValue == 1.0 - Stats.Binomial(TotBasesInColumn,NumBasesInColMismatching+1,GlobalSeqErrRate);
// PValueIdx == sorted index of PValue and locus pairs, 1..k
// Generate PValues for all alignment columns meeting minimum constraints into an array of structures containing column loci and associated PValues
// Sort array of structures ascending on PValues
// Iterate array 1 to k and accept as SNPs those elements with PValues < (PValueIdx/k) * QValue


int
OutputSNPs(void)
{
double PValue;
double GlobalSeqErrRate;
double LocalSeqErrRate;
tsSNPcnts *pSNP;
UINT32 Loci;
int Idx;
int NumSNPs;
int TotBases;
char szChromName[cMaxDatasetSpeciesChrom+1];
int LineLen;
double Proportion;
double AdjPValue;
int RelRank;
tsLociPValues *pLociPValues;
size_t memreq;
tsSNPcnts *pSNPWinL;
tsSNPcnts *pSNPWinR;
UINT32 LocalBkgndRateWindow;
UINT32 LocalBkgndRateWinFlank;
UINT32 LocalTotMismatches;
UINT32 LocalTotMatches;
UINT32 LocTMM;
UINT32 LocTM;
CStats Stats;

UINT8 SNPFlanks[9];
UINT8 *pSNPFlank;
int SNPFlankIdx;
int SNPCentroidIdx;
UINT8 Base;
tsSNPCentroid *pCentroid;

if(m_pLociPValues == NULL)					// will be NULL first time in
	{
	memreq = cAllocLociPValues * sizeof(tsLociPValues);
#ifdef _WIN32
	m_pLociPValues = (tsLociPValues *) malloc((size_t)memreq);
	if(m_pLociPValues == NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"OutputSNPs: Memory allocation of %lld bytes failed",(INT64)memreq);
		return(eBSFerrMem);
		}
#else
	// gnu malloc is still in the 32bit world and can't handle more than 2GB allocations
	m_pLociPValues = (tsLociPValues *)mmap(NULL,(size_t)memreq, PROT_READ |  PROT_WRITE,MAP_PRIVATE | MAP_ANONYMOUS, -1,0);
	if(m_pLociPValues == MAP_FAILED)
		{
		m_pLociPValues = NULL;
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"OutputSNPs: Memory allocation of %lld bytes through mmap()  failed",(INT64)memreq,strerror(errno));
		return(eBSFerrMem);
		}
#endif
	m_AllocLociPValuesMem = memreq;
	m_NumLociPValues = 0;
	}

// NOTE: set a floor on the global (whole chromosome) sequencing error rate
GlobalSeqErrRate = max(cMinSeqErrRate,(double)m_pChromSNPs->TotMismatch / (double)(1 + m_pChromSNPs->TotMatch + m_pChromSNPs->TotMismatch));

LineLen = 0;
m_pSfxArray->GetIdentName(m_pChromSNPs->ChromID,sizeof(szChromName),szChromName);

pSNPWinR = &m_pChromSNPs->Cnts[0];
LocalBkgndRateWinFlank = cSNPBkgndRateWindow / 2;
LocalBkgndRateWindow = (LocalBkgndRateWinFlank * 2) + 1;
LocalTotMismatches = 0;
LocalTotMatches = 0;
for(Loci = 0; Loci < min(LocalBkgndRateWindow,m_pChromSNPs->ChromLen); Loci++,pSNPWinR++)
	{
	LocalTotMismatches += pSNPWinR->NumNonRefBases;
	LocalTotMatches += pSNPWinR->NumRefBases;
	}

pLociPValues = m_pLociPValues;
m_NumLociPValues = 0;
pSNP = &m_pChromSNPs->Cnts[0];
pSNPWinL = pSNP;
for(Loci = 0; Loci < m_pChromSNPs->ChromLen;Loci++, pSNP++)
	{
	// determine background expected error rate from window surrounding the current loci
	if(Loci > LocalBkgndRateWinFlank && (Loci + LocalBkgndRateWinFlank) < m_pChromSNPs->ChromLen)
		{
		// need to ensure that LocalTotMismatches and LocalTotMismatches will never underflow
		if(LocalTotMismatches >= pSNPWinL->NumNonRefBases)
			LocalTotMismatches -= pSNPWinL->NumNonRefBases;
		else
			LocalTotMismatches = 0;
		if(LocalTotMatches >= pSNPWinL->NumRefBases)
			LocalTotMatches -= pSNPWinL->NumRefBases;
		else
			LocalTotMatches = 0;
		LocalTotMismatches += pSNPWinR->NumNonRefBases;
		LocalTotMatches += pSNPWinR->NumRefBases;
		pSNPWinL += 1;
		pSNPWinR += 1;
		}

	TotBases = pSNP->NumNonRefBases + pSNP->NumRefBases;
	if(TotBases < m_MinSNPreads)
		continue;

	if(m_hSNPCentsfile != -1)
		{
		// get 4bases up/dn stream from loci with SNP and use these to inc centroid counts of from/to counts
		if(Loci >= cSNPCentfFlankLen && Loci < (m_pChromSNPs->ChromLen - cSNPCentfFlankLen))
			{
			m_pSfxArray->GetSeq(m_pChromSNPs->ChromID,Loci-(UINT32)cSNPCentfFlankLen,SNPFlanks,cSNPCentroidLen);
			pSNPFlank = &SNPFlanks[cSNPCentroidLen-1];
			SNPCentroidIdx = 0;
			for(SNPFlankIdx = 0; SNPFlankIdx < cSNPCentroidLen; SNPFlankIdx++,pSNPFlank--)
				{
				Base = *pSNPFlank & 0x07;
				if(Base > eBaseT)
					break;
				SNPCentroidIdx |= (Base << (SNPFlankIdx * 2));
				}
			if(SNPFlankIdx == cSNPCentroidLen)
				m_pSNPCentroids[SNPCentroidIdx].NumInsts += 1;
			}
		}


	if(pSNP->NumNonRefBases < cMinSNPreads)
		continue;
	Proportion = (double)pSNP->NumNonRefBases/TotBases;
	if(Proportion < cMinSNPproportion)	// needs to be at least cMinSNPproportion to explore as being SNP
		continue;

	// needing to allocate more memory? NOTE: allowing small safety margin of 10 tsLociPValues
	if(m_AllocLociPValuesMem  < (sizeof(tsLociPValues) * (m_NumLociPValues + 10)))
		{
		size_t memreq = m_AllocLociPValuesMem + (cAllocLociPValues * sizeof(tsLociPValues));
#ifdef _WIN32
		pLociPValues = (tsLociPValues *) realloc(m_pLociPValues,memreq);
		if(pLociPValues == NULL)
			{
#else
		pLociPValues = (tsLociPValues *)mremap(m_pLociPValues,m_AllocLociPValuesMem,memreq,MREMAP_MAYMOVE);
		if(pLociPValues == MAP_FAILED)
			{
#endif
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"OutputSNPs: Memory reallocation to %lld bytes failed - %s",memreq,strerror(errno));
			return(eBSFerrMem);
			}
		m_pLociPValues = pLociPValues;
		m_AllocLociPValuesMem = memreq;
		pLociPValues = &m_pLociPValues[m_NumLociPValues];
		}



	if(pSNP->NumNonRefBases <= LocalTotMismatches)
		LocTMM = LocalTotMismatches - pSNP->NumNonRefBases;
	else
		LocTMM = 0;

	if(pSNP->NumRefBases < LocalTotMatches)
		LocTM = LocalTotMatches - pSNP->NumRefBases;
	else
		LocTM = 0;


	if((LocTMM + LocTM) == 0)
		LocalSeqErrRate = GlobalSeqErrRate;
	else
		{
		LocalSeqErrRate = (double)LocTMM / (double)(LocTMM + LocTM);
		if(LocalSeqErrRate < GlobalSeqErrRate)
			LocalSeqErrRate = GlobalSeqErrRate;
		}
	if(LocalSeqErrRate > cMaxBkgdNoiseThres)	// don't bother attempting to call if the background is too noisy
		continue;

	PValue = 1.0 - Stats.Binomial(TotBases,pSNP->NumNonRefBases,LocalSeqErrRate);
	pLociPValues->PValue = PValue;
	pLociPValues->Loci = Loci;
	pLociPValues->Rank = 0;
	pLociPValues->LocalBkGndSubRate = LocalSeqErrRate;
	pLociPValues->LocalReads = LocTMM + LocTM;
	pLociPValues->LocalSubs = LocTMM;
	pLociPValues->NumReads = TotBases;
	pLociPValues->SNPcnts = *pSNP;
	pLociPValues->NumSubs = pSNP->NumNonRefBases;
	pLociPValues += 1;
	m_NumLociPValues += 1;
	}

if(m_NumLociPValues == 0)
	return(eBSFSuccess);
if(m_NumLociPValues > 1)
	mtqsort.qsort(m_pLociPValues,m_NumLociPValues,sizeof(tsLociPValues),SortLociPValues);
pLociPValues = m_pLociPValues;
NumSNPs = 0;
for(Idx = 0; Idx < (int)m_NumLociPValues; Idx++,pLociPValues++)
	{
	AdjPValue = ((Idx+1)/(double)m_NumLociPValues) * m_QValue;
	if(pLociPValues->PValue >= AdjPValue)
		break;
	NumSNPs += 1;
	pLociPValues->Rank = Idx + 1;
	}
m_NumLociPValues = NumSNPs;
if(m_NumLociPValues > 1)
	mtqsort.qsort(m_pLociPValues,m_NumLociPValues,sizeof(tsLociPValues),SortPValuesLoci);




pLociPValues = m_pLociPValues;
for(Idx = 0; Idx < (int)m_NumLociPValues; Idx++,pLociPValues++)
	{
	m_TotNumSNPs += 1;
	RelRank = max(1,999 - ((999 * pLociPValues->Rank) / m_NumLociPValues));
	if(m_FMode == eFMbed)
		{
		LineLen+=sprintf(&m_pszLineBuff[LineLen],"%s\t%d\t%d\tSNP_%d\t%d\t+\n",
				szChromName,pLociPValues->Loci,pLociPValues->Loci+1,m_TotNumSNPs,RelRank);
		}
	else
		{
		LineLen+=sprintf(&m_pszLineBuff[LineLen],"%d,\"SNP\",\"%s\",\"%s\",%d,%d,1,\"+\",%d,%f,%d,%d,\"%c\",%d,%d,%d,%d,%d,%f,%d,%d\n",
					m_TotNumSNPs,m_szTargSpecies,szChromName,pLociPValues->Loci,pLociPValues->Loci,RelRank,pLociPValues->PValue,
								pLociPValues->NumReads,pLociPValues->NumSubs,
								CSeqTrans::MapBase2Ascii(pLociPValues->SNPcnts.RefBase),
								pLociPValues->SNPcnts.NonRefBaseCnts[0],pLociPValues->SNPcnts.NonRefBaseCnts[1],pLociPValues->SNPcnts.NonRefBaseCnts[2],pLociPValues->SNPcnts.NonRefBaseCnts[3],pLociPValues->SNPcnts.NonRefBaseCnts[4],
								pLociPValues->LocalBkGndSubRate,pLociPValues->LocalReads,pLociPValues->LocalSubs);
		}
	if((LineLen + 2048) > cAllocLineBuffSize)
		{
		CUtility::SafeWrite(m_hSNPfile,m_pszLineBuff,LineLen);
		LineLen = 0;
		}

	if(m_hSNPCentsfile != -1)
		{
		// get 4bases up/dn stream from loci with SNP and use these to inc centroid counts of from/to counts
		if(pLociPValues->Loci >= cSNPCentfFlankLen && pLociPValues->Loci < (m_pChromSNPs->ChromLen - cSNPCentfFlankLen))
			{
			m_pSfxArray->GetSeq(m_pChromSNPs->ChromID,pLociPValues->Loci-(UINT32)cSNPCentfFlankLen,SNPFlanks,cSNPCentroidLen);
			pSNPFlank = &SNPFlanks[cSNPCentroidLen-1];
			SNPCentroidIdx = 0;
			for(SNPFlankIdx = 0; SNPFlankIdx < cSNPCentroidLen; SNPFlankIdx++,pSNPFlank--)
				{
				Base = *pSNPFlank & 0x07;
				if(Base > eBaseT)
					break;
				SNPCentroidIdx |= (Base << (SNPFlankIdx * 2));
				}
			if(SNPFlankIdx != cSNPCentroidLen)
				continue;

			pSNP = &m_pChromSNPs->Cnts[pLociPValues->Loci];
			pCentroid = &m_pSNPCentroids[SNPCentroidIdx];
			pCentroid->CentroidID = SNPCentroidIdx;
			pCentroid->RefBaseCnt += pSNP->NumRefBases;
			pCentroid->NonRefBaseCnts[0] += pSNP->NonRefBaseCnts[0];
			pCentroid->NonRefBaseCnts[1] += pSNP->NonRefBaseCnts[1];
			pCentroid->NonRefBaseCnts[2] += pSNP->NonRefBaseCnts[2];
			pCentroid->NonRefBaseCnts[3] += pSNP->NonRefBaseCnts[3];
			pCentroid->NonRefBaseCnts[4] += pSNP->NonRefBaseCnts[4];
			pCentroid->NumSNPs += 1;
			}
		}

	}
if(LineLen)
	CUtility::SafeWrite(m_hSNPfile,m_pszLineBuff,LineLen);
return(eBSFSuccess);
}


int
ProcessSNPs(void)
{
int Rslt;
int LineLen;

UINT32 SeqIdx;
etSeqBase ReadSeq[cMaxFastQSeqLen+1];	// to hold sequence (sans quality scores) for current read
etSeqBase AssembSeq[cMaxFastQSeqLen+1];	// to hold targeted genome assembly sequence

etSeqBase TargBases[3];
etSeqBase ReadBase;
tsSNPcnts *pSNP;
UINT8 *pSeqVal;
etSeqBase *pReadSeq;
etSeqBase *pAssembSeq;
tsSegLoci *pSeg;
tsReadHit *pReadHit;
tBSFEntryID PrevTargEntry;
UINT32 ChromLen;
UINT32 HitLoci;
UINT32 MatchLen;
UINT32 PrevMMChromID;
UINT32 PrevMMLoci;

if(m_FMode == eFMbed)
	{
	LineLen = sprintf(m_pszLineBuff,"track type=bed name=\"%s_SNPs\" description=\"%s SNPs\"\n",m_pszTrackTitle,m_pszTrackTitle);
	CUtility::SafeWrite(m_hSNPfile,m_pszLineBuff,LineLen);
	LineLen = 0;
	}
else			// else must be to a CSV
	{
	LineLen = sprintf(m_pszLineBuff,"\"SNP_ID\",\"ElType\",\"Species\",\"Chrom\",\"StartLoci\",\"EndLoci\",\"Len\",\"Strand\",\"Rank\",\"PValue\",\"Bases\",\"Mismatches\",\"RefBase\",\"MMBaseA\",\"MMBaseC\",\"MMBaseG\",\"MMBaseT\",\"MMBaseN\",\"BackgroundSubRate\",\"TotWinBases\",\"TotWinMismatches\"\n");
	CUtility::SafeWrite(m_hSNPfile,m_pszLineBuff,LineLen);
	LineLen = 0;
	}

if(m_hSNPCentsfile != -1)
	{
	if(m_pSNPCentroids == NULL)
		{
		int CentroidIdx;
		tsSNPCentroid *pCentroid;
		if((m_pSNPCentroids = new tsSNPCentroid[cSNPCentroidEls + 16])==NULL)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"ProcessSNPs: Memory allocation of %d SNP centroid elements failed",cSNPCentroidEls + 16);
			Reset(false);
			return(eBSFerrMem);
			}
		memset(m_pSNPCentroids,0,sizeof(tsSNPCentroid) * (cSNPCentroidEls+16));
		pCentroid = m_pSNPCentroids;
		for(CentroidIdx = 1; CentroidIdx <= cSNPCentroidEls; CentroidIdx++,pCentroid++)
			pCentroid->CentroidID = CentroidIdx;
		}
	}

pReadHit = NULL;
LineLen = 0;
PrevTargEntry = 0;

m_TotNumSNPs = 0;
while((pReadHit = IterSortedReads(pReadHit))!=NULL)
	{
	if(pReadHit->NumHits == 1)
		{
		if(pReadHit->HitLoci.Hit.FlgInDel || pReadHit->HitLoci.Hit.FlgSplice)
			continue;

		pSeg = &pReadHit->HitLoci.Hit.Seg[0];
		if(pSeg->ChromID != (UINT32)PrevTargEntry)
			{
			if(m_pChromSNPs != NULL)
				{
				// this is where the SNPs for the previously processed chrom need to saved off as new chrom is about to be processed
				if((Rslt=OutputSNPs())!=eBSFSuccess)
					{
					Reset(false);
					return(Rslt);
					}
				}

    		PrevTargEntry = pSeg->ChromID;
			ChromLen = m_pSfxArray->GetSeqLen(PrevTargEntry);
			if(m_pChromSNPs == NULL || (m_pChromSNPs != NULL && (ChromLen + 16) > m_pChromSNPs->AllocChromLen))
				{
				if(m_pChromSNPs != NULL)
					{
					delete m_pChromSNPs;
					m_pChromSNPs = NULL;
					}
				size_t AllocSize = sizeof(tsChromSNPs) + ((ChromLen + 16) * sizeof(tsSNPcnts));
				if((m_pChromSNPs = (tsChromSNPs *)new UINT8[AllocSize])==NULL)
					{
					gDiagnostics.DiagOut(eDLFatal,gszProcName,"ProcessSNPs: Memory allocation of %lld bytes - %s",(INT64)AllocSize,strerror(errno));
					Reset(false);
					return(eBSFerrMem);
					}
				m_pChromSNPs->AllocChromLen = ChromLen + 16;
				}
			memset(&m_pChromSNPs->Cnts,0,((ChromLen + 16) * sizeof(tsSNPcnts)));
			m_pChromSNPs->ChromLen = (UINT32)ChromLen;
			m_pChromSNPs->ChromID = pSeg->ChromID;
			m_pChromSNPs->TotMatch = 0;
			m_pChromSNPs->TotMismatch = 0;
			PrevTargEntry = m_pChromSNPs->ChromID;
			PrevMMChromID = 0;
			PrevMMLoci = -1;
			}

		// get target genome sequence
		if(m_bIsSOLiD)
			{
			MatchLen = AdjHitLen(pSeg);
			HitLoci = AdjStartLoci(pSeg);
			HitLoci += 1;
			MatchLen -= 1;
			m_pSfxArray->GetColorspaceSeq(pSeg->ChromID,
									HitLoci,
									AssembSeq,MatchLen);	// get colorspace sequence


			}
		else
			{
			// get target assembly sequence for entry starting at offset and of length len
			MatchLen = AdjHitLen(pSeg);
			HitLoci = AdjStartLoci(pSeg);
			m_pSfxArray->GetSeq(pSeg->ChromID,HitLoci,AssembSeq,MatchLen);
			pAssembSeq = AssembSeq;
			for(SeqIdx = 0; SeqIdx < MatchLen; SeqIdx++,pAssembSeq++)
				*pAssembSeq = *pAssembSeq & 0x07;
			}

			// get accepted aligned read sequence
		pSeqVal = &pReadHit->Read[pReadHit->DescrLen+1];
		pSeqVal += pSeg->ReadOfs + pSeg->TrimLeft;
		pReadSeq = ReadSeq;

		if(m_bIsSOLiD)
			{
			// convert read sequence into colorspace
			UINT8 PrvBase = *pSeqVal & 0x07;
			for(SeqIdx = 1; SeqIdx <= MatchLen; SeqIdx++,pReadSeq++,pSeqVal++)
				{
				*pReadSeq = SOLiDmap[PrvBase][pSeqVal[1] & 0x07];
				PrvBase = pSeqVal[1] & 0x07;
				}
			// reverse, not complement, sequence if hit was onto '-' strand
			if(pSeg->Strand == '-')
				CSeqTrans::ReverseSeq(MatchLen,ReadSeq);
			}
		else
			{
			for(SeqIdx = 0; SeqIdx < MatchLen; SeqIdx++,pReadSeq++,pSeqVal++)
				*pReadSeq = *pSeqVal & 0x07;
			if(pSeg->Strand == '-')
				CSeqTrans::ReverseComplement(MatchLen,ReadSeq);
			}

		// double check not about to update snp counts past the expected chrom length
		// truncate length as may be required
		if((HitLoci + MatchLen) > ChromLen)
			{
			if((MatchLen = (int)ChromLen - HitLoci) < 10)
				continue;
			}

		// now iterate read bases and if mismatch then update appropriate counts
		pSNP = &m_pChromSNPs->Cnts[HitLoci];
		pAssembSeq = &AssembSeq[0];
		pReadSeq = &ReadSeq[0];
		UINT32 Loci = HitLoci;
		bool bPairMM = false;
		int SeqMM = 0;
		for(SeqIdx = 0; SeqIdx < MatchLen; SeqIdx++, Loci++,pReadSeq++, pAssembSeq++,pSNP++)
			{
			if(*pAssembSeq >= eBaseN || (m_bIsSOLiD && *pReadSeq >= eBaseN) || *pReadSeq > eBaseN)
				{
				SeqMM += 1;
				continue;
				}

			if(m_bIsSOLiD)		// in colorspace, unpaired mismatches assumed to be sequencer errors and simply sloughed when identifying SNPs
				{
				if(Loci == 0)	// too problematic with SNPs in colorspace at the start of the target sequence, simply slough
					continue;

				if(!bPairMM && *pAssembSeq != *pReadSeq)
					{
					if(SeqIdx < (1+MatchLen))
						{
						if(pReadSeq[1] == pAssembSeq[1])
							{
							pSNP->NumRefBases += 1;
							m_pChromSNPs->TotMatch += 1;
							SeqMM += 1;
							continue;
							}
						}

					// get the previous target sequence base and use this + read colorspace space to derive the mismatch in basespace
					if(pSeg->ChromID != PrevMMChromID || Loci != PrevMMLoci)
						{
						PrevMMChromID = pSeg->ChromID;
						PrevMMLoci = Loci;
						m_pSfxArray->GetSeq(pSeg->ChromID,Loci-1,&TargBases[0],2);
						if(TargBases[0] > eBaseN)
							TargBases[0] = eBaseN;
						if(TargBases[1] > eBaseN)
							TargBases[1] = eBaseN;
						pSNP->RefBase = TargBases[1];
						}

					ReadBase = *pReadSeq;
					if(ReadBase > eBaseT)
						ReadBase = eBaseN;

					if(SeqMM == 0)
						ReadBase = SOLiDmap[TargBases[0]][ReadBase];
					else
						ReadBase = eBaseN;

					// sometimes it seems that a colorspace read may have had a sequencing error earlier in the read
					// or some mismatch such that the current loci mismatches in colorspace but matches in basespace
					// these strange bases are treated as though they are undefined and accrue counts as being eBaseN's
					if(ReadBase == pSNP->RefBase)
						ReadBase = eBaseN;
					if(pSNP->NonRefBaseCnts[ReadBase] < 0x0ffff)
						pSNP->NonRefBaseCnts[ReadBase] += 1;
					pSNP->NumNonRefBases += 1;
					m_pChromSNPs->TotMismatch += 1;
					bPairMM = true;
					SeqMM += 1;
					}
				else
					{
					pSNP->NumRefBases += 1;
					m_pChromSNPs->TotMatch += 1;
					bPairMM = false;
					SeqMM = 0;
					}
				}
			else				// in basespace any mismatch is counted as a NonRefCnt
				{
				ReadBase = *pReadSeq & 0x07;
				TargBases[0] = *pAssembSeq & 0x07;

				pSNP->RefBase = TargBases[0];
				if(TargBases[0] == ReadBase)
					{
					pSNP->NumRefBases += 1;
					m_pChromSNPs->TotMatch += 1;
					}
				else
					{
					if(ReadBase > eBaseT)
						ReadBase = eBaseN;

					if(pSNP->NonRefBaseCnts[ReadBase] < 0x0ffff)
						pSNP->NonRefBaseCnts[ReadBase] += 1;
					pSNP->NumNonRefBases += 1;
					m_pChromSNPs->TotMismatch += 1;
					}
				}
			}
		}
	}
if((Rslt=OutputSNPs())!=eBSFSuccess)
	{
	Reset(false);
	return(Rslt);
	}
if(m_hSNPfile != -1)
	{
#ifdef _WIN32
	_commit(m_hSNPfile);
#else
	fsync(m_hSNPfile);
#endif
	close(m_hSNPfile);
	m_hSNPfile = -1;
	}

if(m_hSNPCentsfile != -1)
	{
	// report on the SNP centroid distributions
	int SNPCentroidIdx;
	int CentroidSeq;
	UINT8 Bases[cSNPCentroidLen];
	int BaseIdx;
	tsSNPCentroid *pCentroid;
	char szCentroids[4096];
	int BuffIdx;

	BuffIdx = sprintf(szCentroids,"\"CentroidID\",\"Seq\",\"NumInsts\",\"NumSNPs\",\"RefBase\",\"RefBaseCnt\",\"BaseA\",\"BaseC\",\"BaseG\",\"BaseT\",\"BaseN\"\n");
	pCentroid = m_pSNPCentroids;
	for(SNPCentroidIdx = 0; SNPCentroidIdx < cSNPCentroidEls; SNPCentroidIdx++, pCentroid++)
		{
		CentroidSeq = SNPCentroidIdx;
		for(BaseIdx = cSNPCentroidLen-1; BaseIdx >= 0; BaseIdx--)
			{
			Bases[BaseIdx] = CentroidSeq & 0x03;
			CentroidSeq >>= 2;
			}

		BuffIdx += sprintf(&szCentroids[BuffIdx],"%d,\"%s\",%d,%d,\"%c\",%d,%d,%d,%d,%d,%d\n",
							SNPCentroidIdx+1,CSeqTrans::MapSeq2Ascii(Bases,cSNPCentroidLen),pCentroid->NumInsts,pCentroid->NumSNPs,CSeqTrans::MapBase2Ascii(Bases[cSNPCentfFlankLen]),
							pCentroid->RefBaseCnt,pCentroid->NonRefBaseCnts[0],pCentroid->NonRefBaseCnts[1],pCentroid->NonRefBaseCnts[2],pCentroid->NonRefBaseCnts[3],pCentroid->NonRefBaseCnts[4]);


		if(BuffIdx + 200 > sizeof(szCentroids))
			{
			CUtility::SafeWrite(m_hSNPCentsfile,szCentroids,BuffIdx);
			BuffIdx = 0;
			}
		}
	if(BuffIdx)
		CUtility::SafeWrite(m_hSNPCentsfile,szCentroids,BuffIdx);
	}

if(m_hSNPCentsfile != -1)
	{
#ifdef _WIN32
	_commit(m_hSNPCentsfile);
#else
	fsync(m_hSNPCentsfile);
#endif
	close(m_hSNPCentsfile);
	m_hSNPCentsfile = -1;
	}

if(m_pChromSNPs != NULL)
	{
	delete m_pChromSNPs;
	m_pChromSNPs = NULL;
	}
return(eBSFSuccess);
}

//--- the following function ProcessSiteProbabilites() is targeted for use in RNA-seq processing
// which should help in identifying differentially expressed transcripts
int
ProcessSiteProbabilites(int RelSiteStartOfs)	// offset the site octamer by this relative start offset (read start base == 0)
{
int LineLen;

int SeqIdx;
int SiteIdx;
etSeqBase AssembSeq[cMaxFastQSeqLen+1];	// to hold genome assembly sequence for current read loci

tsOctSitePrefs *pSitePrefs;
tsOctSitePrefs *pSitePref;
etSeqBase *pAssembSeq;
tsReadHit *pReadHit;
tsSegLoci *pSeg;
tBSFEntryID PrevTargEntry;
UINT32 HitLoci;
UINT32 PrevLoci;
UINT32 MatchLen;
UINT32 CurChromLen;

int TotOccs;
int TotSites;

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Processing for alignment site probabilities...");

TotOccs = 0;
TotSites = 0;
memset(m_OctSitePrefs,0,sizeof(m_OctSitePrefs));
pSitePrefs = m_OctSitePrefs[0];
pSitePref = m_OctSitePrefs[1];
for(SiteIdx = 0; SiteIdx < cNumOctamers; SiteIdx++,pSitePref++,pSitePrefs++)
	{
	pSitePref->Octamer = SiteIdx;
	pSitePrefs->Octamer = SiteIdx;
	}
pReadHit = NULL;
LineLen = 0;
PrevTargEntry = 0;
PrevLoci = -1;
CurChromLen = -1;
// iterate all accepted as aligned reads
// reads are assumed to have been sorted by chrom and start loci
while((pReadHit = IterSortedReads(pReadHit))!=NULL)
	{
	if(pReadHit->NumHits == 1)
		{
		if(pReadHit->HitLoci.Hit.FlgInDel || pReadHit->HitLoci.Hit.FlgSplice)
			continue;

		pSeg = &pReadHit->HitLoci.Hit.Seg[0];
		if(pSeg->ChromID != (UINT32)PrevTargEntry)
			{
    		PrevTargEntry = pSeg->ChromID;
			PrevLoci = -1;
			CurChromLen = m_pSfxArray->GetSeqLen(pSeg->ChromID);
			}

		// get target assembly sequence for entry starting at MatchLoci, offset by RelSiteStartOfs, and of octamer length
		MatchLen = pSeg->MatchLen;
		HitLoci = (UINT32)pSeg->MatchLoci;

		if(pSeg->Strand == '+')
			HitLoci += RelSiteStartOfs;
		else
			{
			HitLoci += pSeg->MatchLen - 1;
			HitLoci -= RelSiteStartOfs;
			HitLoci -= 7;
			}

		if(HitLoci < 0)						// force octamer to start/end within the chrom sequence
			HitLoci = 0;
		else
			if((HitLoci + 8) >= CurChromLen)
				HitLoci = CurChromLen - 9;

		m_pSfxArray->GetSeq(pSeg->ChromID,HitLoci,AssembSeq,8);
		pAssembSeq = AssembSeq;
		for(SeqIdx = 0; SeqIdx < 8; SeqIdx++,pAssembSeq++)
			*pAssembSeq = *pAssembSeq & 0x07;

		if(pSeg->Strand == '-')
			{
			pSitePrefs = m_OctSitePrefs[1];
			CSeqTrans::ReverseComplement(8,AssembSeq);
			}
		else
			pSitePrefs = m_OctSitePrefs[0];
		pAssembSeq = &AssembSeq[0];

        // generate site index
		SiteIdx = 0;
		for(SeqIdx = 0; SeqIdx < 8; SeqIdx++)
			{
			if(*pAssembSeq > eBaseT)
				break;
			SiteIdx <<= 2;
			SiteIdx |= *pAssembSeq++;
			}
		if(SeqIdx != 8)
			continue;
		pReadHit->SiteIdx = SiteIdx;
		pSitePref = &pSitePrefs[SiteIdx];

		pSitePref->NumOccs += 1;
		TotOccs += 1;
		if(HitLoci != PrevLoci)
			{
			pSitePref->NumSites += 1;
			PrevLoci = HitLoci;
			TotSites += 1;
			}
		}
	}

// now to generate the relative abundance scores
// firstly determine the mean number of read alignment occurrences for each octamer
// find the top 64 (~ 0.1%) with highest mean occurrences
// all octamers are then scaled to this mean of the top 0.1%
pSitePrefs = m_OctSitePrefs[0];
pSitePref = m_OctSitePrefs[1];
for(SiteIdx = 0; SiteIdx < cNumOctamers; SiteIdx++,pSitePrefs++,pSitePref++)
	{
	if(pSitePrefs->NumSites >= 1)
		pSitePrefs->RelScale = (double)pSitePrefs->NumOccs/pSitePrefs->NumSites;
	else
		pSitePrefs->RelScale = 0.0;
	if(pSitePref->NumSites >= 1)
		pSitePref->RelScale = (double)pSitePref->NumOccs/pSitePref->NumSites;
	else
		pSitePref->RelScale = 0;
	}

// now sort ascending  by RelScale so top 0.1% can be determined and their mean determined
mtqsort.qsort(m_OctSitePrefs[0],cNumOctamers,sizeof(tsOctSitePrefs),SortSiteRelScale);
mtqsort.qsort(m_OctSitePrefs[1],cNumOctamers,sizeof(tsOctSitePrefs),SortSiteRelScale);

double TopWatsonMean = 0.0;
double TopCrickMean = 0.0;
pSitePrefs = &m_OctSitePrefs[0][0x0ffc0];
pSitePref = &m_OctSitePrefs[1][0x0ffc0];
for(SiteIdx = 0x0ffc0; SiteIdx < cNumOctamers; SiteIdx++,pSitePrefs++,pSitePref++)
	{
	TopWatsonMean += pSitePrefs->RelScale;
	pSitePrefs->RelScale = 1.0;
	TopCrickMean +=	pSitePref->RelScale;
	pSitePref->RelScale = 1.0;
	}
TopWatsonMean /= 64;
TopCrickMean /= 64;

// top means known now set normalisation scale factors
pSitePrefs = m_OctSitePrefs[0];
pSitePref = m_OctSitePrefs[1];
for(SiteIdx = 0; SiteIdx < 0x0ffc0; SiteIdx++,pSitePrefs++,pSitePref++)
	{
	if(pSitePrefs->RelScale > 0.0)
		pSitePrefs->RelScale = max(0.0001,pSitePrefs->RelScale / TopWatsonMean);
	if(pSitePref->RelScale)
		pSitePref->RelScale = max(0.0001,pSitePref->RelScale / TopCrickMean);
	}

// restore m_OctSitePrefs to original octamer ascending order
mtqsort.qsort(m_OctSitePrefs[0],cNumOctamers,sizeof(tsOctSitePrefs),SortSiteRelOctamer);
mtqsort.qsort(m_OctSitePrefs[1],cNumOctamers,sizeof(tsOctSitePrefs),SortSiteRelOctamer);

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Completed alignment site probabilities");
return(eBSFSuccess);
}

// Report on site octamer site preferencing distribution

char *
Octamer2Txt(int Octamer)
{
static char szOctamer[0x09];	// to contain '\0' terminated octamer as nucleotide bases 'a'..'t'
char *pChr;
int Idx;
pChr = &szOctamer[8];
*pChr-- = '\0';
for(Idx = 0; Idx < 8; Idx++,pChr--)
	{
	switch(Octamer & 0x03) {
		case 0:
			*pChr = 'a';
			break;
		case 1:
			*pChr = 'c';
			break;
		case 2:
			*pChr = 'g';
			break;
		case 3:
			*pChr = 't';
			break;
		}
	Octamer >>= 2;
	}
return(szOctamer);
return(NULL);
}

int
WriteSitePrefs(void)
{
char szBuff[0x03fff];
int BuffIdx;
int SiteIdx;
tsOctSitePrefs *pSite;
BuffIdx = sprintf(szBuff,"\"Id\",\"Strand\",\"Octamer\",\"TotalHits\",\"UniqueLoci\",\"RelScale\"\n");
pSite = m_OctSitePrefs[0];
for(SiteIdx = 0; SiteIdx < 0x0ffff; SiteIdx++,pSite++)
	{
	BuffIdx += sprintf(&szBuff[BuffIdx],"%d,\"+\",\"%s\",%d,%d,%1.3f\n",SiteIdx+1,Octamer2Txt(pSite->Octamer),pSite->NumOccs,pSite->NumSites,pSite->RelScale);
	if(BuffIdx + 200 > sizeof(szBuff))
		{
		CUtility::SafeWrite(m_hSitePrefsFile,szBuff,BuffIdx);
		BuffIdx = 0;
		}
	}
pSite = m_OctSitePrefs[1];
for(SiteIdx = 0; SiteIdx < 0x0ffff; SiteIdx++,pSite++)
	{
	BuffIdx += sprintf(&szBuff[BuffIdx],"%d,\"-\",\"%s\",%d,%d,%1.3f\n",SiteIdx+1,Octamer2Txt(pSite->Octamer),pSite->NumOccs,pSite->NumSites,pSite->RelScale);
	if(BuffIdx + 200 > sizeof(szBuff))
		{
		CUtility::SafeWrite(m_hSitePrefsFile,szBuff,BuffIdx);
		BuffIdx = 0;
		}
	}

if(BuffIdx > 0)
	{
	CUtility::SafeWrite(m_hSitePrefsFile,szBuff,BuffIdx);
	BuffIdx = 0;
	}
return(eBSFSuccess);
}

int
LoadReads(char *pszRdsFile)	// file containing preprocessed reads (genreads output)
{
int Rslt;
size_t memreq;
int RdLen;
tsRawReadV5 *pReadV5;					// current preprocessed read being processed if V5
tsRawReadV6 *pReadV6;					// current preprocessed read being processed if V6

UINT8 *pReadBuff;						// alloc'd to buffer the preprocessed reads from disk
tsReadHit *pReadHit;					// current read hit
int BuffLen;
int BuffOfs;
char *pChr;
char Chr;
// check if file name contains any wildcard chars
pChr = pszRdsFile;
while(Chr = *pChr++)
	if(Chr == '*' || Chr == '?' || Chr == '[' || Chr == ']')
		return(eBSFerrNotBioseq);

#ifdef _WIN32
m_hInFile = open(pszRdsFile, O_READSEQ ); // file access is normally sequential..
#else
m_hInFile = open64(pszRdsFile, O_READSEQ ); // file access is normally sequential..
#endif

if(m_hInFile == -1)					// check if file open succeeded
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open %s - %s",pszRdsFile,strerror(errno));
	return(eBSFerrOpnFile);
	}

// expecting a preprocessed .rds file as input, header processing will confirm!
if((Rslt=Disk2Hdr(pszRdsFile))!=eBSFSuccess)
	{
	close(m_hInFile);
	m_hInFile = -1;
	return((teBSFrsltCodes)Rslt);
	}

if((pReadBuff = new UINT8 [cRdsBuffAlloc])==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadReads: Memory allocation of %d bytes - %s",cRdsBuffAlloc,strerror(errno));
	close(m_hInFile);
	m_hInFile = -1;
	return(eBSFerrMem);
	}

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Reads file '%s' generator version: %d",pszRdsFile,m_FileHdr.Version);

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Contains total of %d reads from %d source reads with duplicate sequences %s, PMode was %d, Quality was %d, %d bases 5' trimmed, %d bases 3' trimmed",
			m_FileHdr.NumRds,m_FileHdr.OrigNumReads,m_FileHdr.FlagsK ? "retained":"removed", m_FileHdr.PMode,m_FileHdr.QMode,m_FileHdr.Trim5,m_FileHdr.Trim3);
if(m_FileHdr.FlagsPR)
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Reads were processed as %s",m_FileHdr.FlagsPR ? "paired end reads" : "single end reads");

gDiagnostics.DiagOutMsgOnly(eDLInfo,"Reads were processed from %d files",m_FileHdr.NumFiles);
char *pszSrcFile = (char *)m_FileHdr.FileNames;
for(BuffOfs=0;BuffOfs<m_FileHdr.NumFiles;BuffOfs++)
	{
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Source file: '%s'",pszSrcFile);
	pszSrcFile += strlen(pszSrcFile) + 1;
	}

// ensure there is at least one read...
if(m_FileHdr.NumRds == 0 || m_FileHdr.TotReadsLen == 0)
	{
	gDiagnostics.DiagOut(eDLWarn,gszProcName,"Nothing to do, '%s' contains no reads...",pszRdsFile);
	delete pReadBuff;
	close(m_hInFile);
	m_hInFile = -1;
	return(eBSFerrOpnFile);
	}

// initial allocation of memory to hold all pre-processed reads plus a little safety margin (10000) bytes)
memreq = ((size_t)m_FileHdr.NumRds * sizeof(tsReadHit)) + (size_t)m_FileHdr.TotReadsLen + 10000;
AcquireSerialise();
AcquireLock(true);
#ifdef _WIN32
m_pReadHits = (tsReadHit *) malloc(memreq);	// initial and perhaps the only allocation

if(m_pReadHits == NULL)
	{
	ReleaseLock(true);
	ReleaseSerialise();
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadReads: Memory allocation of %lld bytes - %s",(INT64)memreq,strerror(errno));
	delete pReadBuff;
	close(m_hInFile);
	m_hInFile = -1;
	return(eBSFerrMem);
	}
#else
// gnu malloc is still in the 32bit world and can't handle more than 2GB allocations
m_pReadHits = (tsReadHit *)mmap(NULL,memreq, PROT_READ |  PROT_WRITE,MAP_PRIVATE | MAP_ANONYMOUS, -1,0);
if(m_pReadHits == MAP_FAILED)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadReads: Memory allocation of %lld bytes through mmap()  failed - %s",(INT64)memreq,strerror(errno));
	m_pReadHits = NULL;
	ReleaseLock(true);
	ReleaseSerialise();
	delete pReadBuff;
	close(m_hInFile);
	m_hInFile = -1;
	return(eBSFerrMem);
	}
#endif

m_AllocdReadHitsMem = memreq;
m_UsedReadHitsMem = 0;
m_FinalReadID = 0;
m_NumReadsLoaded = 0;
m_NumDescrReads = 0;
ReleaseLock(true);
ReleaseSerialise();

// iterate each read sequence starting from the first
lseek(m_hInFile,(long)m_FileHdr.RdsOfs,SEEK_SET);
BuffLen = 0;
BuffOfs = 0;

int SizeOfRawRead = m_FileHdr.Version == 5 ? sizeof(tsRawReadV5) : sizeof(tsRawReadV6);
int CurReadLen;
int CurDescrLen;

while((RdLen = read(m_hInFile,&pReadBuff[BuffLen],cRdsBuffAlloc - BuffLen)) > 0)
	{
	BuffLen += RdLen;
	BuffOfs = 0;
	while((BuffLen - BuffOfs) >=  SizeOfRawRead)
		{
		if(m_FileHdr.Version == 5)
			{
			pReadV5 = (tsRawReadV5 *)&pReadBuff[BuffOfs];
			CurDescrLen = (int)pReadV5->DescrLen;
			CurReadLen = (int)pReadV5->ReadLen;
			}
		else
			{
			pReadV6 = (tsRawReadV6 *)&pReadBuff[BuffOfs];
			CurDescrLen = (int)pReadV6->DescrLen;
			CurReadLen = (int)pReadV6->ReadLen;
			}

		if((int)(CurDescrLen + CurReadLen + SizeOfRawRead) > (BuffLen - BuffOfs))
			break;
		BuffOfs += CurDescrLen + CurReadLen + SizeOfRawRead;
			// pReadV5/V6 now pts at a read
			// shouldn't but is there a need to allocate more memory?
		if(m_UsedReadHitsMem + (sizeof(tsReadHit) + CurReadLen + CurDescrLen) >= (m_AllocdReadHitsMem - 5000))
			{
			AcquireSerialise();
			AcquireLock(true);
			memreq = m_AllocdReadHitsMem + ((sizeof(tsReadHit) + cDfltReadLen) * cReadsHitReAlloc);
			gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadReads: Needing memory re-allocation to %lld bytes from %lld",(INT64)m_AllocdReadHitsMem,(INT64)memreq);

#ifdef _WIN32
			pReadHit = (tsReadHit *) realloc(m_pReadHits,memreq);
#else
			pReadHit = (tsReadHit *)mremap(m_pReadHits,m_AllocdReadHitsMem,memreq,MREMAP_MAYMOVE);
			if(pReadHit == MAP_FAILED)
				pReadHit = NULL;
#endif
			if(pReadHit == NULL)
				{
				ReleaseLock(true);
				ReleaseSerialise();
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadReads: Memory re-allocation to %lld bytes - %s",(INT64)(m_AllocdReadHitsMem + ((sizeof(tsReadHit) + cDfltReadLen)*cReadsHitReAlloc)),strerror(errno));
				delete pReadBuff;
				close(m_hInFile);
				m_hInFile = -1;
				return(eBSFerrMem);
				}
			m_pReadHits = pReadHit;
			m_AllocdReadHitsMem = memreq;
			ReleaseLock(true);
			ReleaseSerialise();
			}

		pReadHit = (tsReadHit *)((UINT8 *)m_pReadHits + m_UsedReadHitsMem);
		m_UsedReadHitsMem += sizeof(tsReadHit) + CurReadLen + CurDescrLen;
		memset(pReadHit,0,sizeof(tsReadHit));
		pReadHit->HitLoci.Hit.Seg[0].Strand = '?';
		pReadHit->ReadLen = CurReadLen;
		pReadHit->DescrLen = CurDescrLen;

		if(m_FileHdr.Version == 5)
			{
			pReadHit->ReadID = pReadV5->ReadID;
			pReadHit->PairReadID = pReadV5->PairReadID;
			pReadHit->NumReads = pReadV5->NumReads;

			memcpy(pReadHit->Read,pReadV5->Read,CurDescrLen + 1 + CurReadLen);
			m_FinalReadID = pReadV5->ReadID;
			}
		else
			{
			pReadHit->ReadID = pReadV6->ReadID;
			pReadHit->PairReadID = pReadV6->PairReadID;
			pReadHit->NumReads = pReadV6->NumReads;
			memcpy(pReadHit->Read,pReadV6->Read,CurDescrLen + 1 + CurReadLen);
			m_FinalReadID = pReadV6->ReadID;
			}

		m_NumDescrReads += 1;

		// processing threads are only updated with actual number of loaded reads every 10000 reads so as
		// to minimise disruption to the actual aligner threads which will also be serialised through m_hMtxIterReads
		if(m_NumDescrReads > 0 && !(m_NumDescrReads % 10000))
			{
			AcquireSerialise();
			m_FinalReadID = m_NumDescrReads;
			m_NumReadsLoaded = m_NumDescrReads;
			ReleaseSerialise();
			}
		}
	BuffLen -= BuffOfs;
	if(BuffLen)
		memcpy(pReadBuff,&pReadBuff[BuffOfs],BuffLen);
	}
delete pReadBuff;
close(m_hInFile);
m_hInFile = -1;
if(m_NumDescrReads != m_NumReadsLoaded)
	{
	AcquireSerialise();
	m_FinalReadID = m_NumDescrReads;
	m_NumReadsLoaded = m_NumDescrReads;
	ReleaseSerialise();
	}
return(m_NumDescrReads);
}

//
//
int
CreateMutexes(void)
{
if(m_bMutexesCreated)
	return(eBSFSuccess);

#ifdef _WIN32
InitializeSRWLock(&m_hRwLock);
#else
if(pthread_rwlock_init (&m_hRwLock,NULL)!=0)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Fatal: unable to create rwlock");
	return(eBSFerrInternal);
	}
#endif

#ifdef _WIN32
if((m_hMtxIterReads = CreateMutex(NULL,false,NULL))==NULL)
	{
#else
if(pthread_mutex_init (&m_hMtxIterReads,NULL)!=0)
	{
	pthread_rwlock_destroy(&m_hRwLock);
#endif
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Fatal: unable to create mutex");
	return(eBSFerrInternal);
	}

#ifdef _WIN32
if((m_hMtxMHReads = CreateMutex(NULL,false,NULL))==NULL)
	{
#else
if(pthread_mutex_init (&m_hMtxMHReads,NULL)!=0)
	{
#endif
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Fatal: unable to create mutex");
#ifdef _WIN32
	CloseHandle(m_hMtxIterReads);
#else
	pthread_rwlock_destroy(&m_hRwLock);
	pthread_mutex_destroy(&m_hMtxIterReads);
#endif
	return(eBSFerrInternal);
	}
if(m_MLMode != eMLdefault)
	{
#ifdef _WIN32
	if((m_hMtxMultiMatches = CreateMutex(NULL,false,NULL))==NULL)
		{
		CloseHandle(m_hMtxIterReads);
		CloseHandle(m_hMtxMHReads);
#else
	if(pthread_mutex_init (&m_hMtxMultiMatches,NULL)!=0)
		{
		pthread_mutex_destroy(&m_hMtxIterReads);
		pthread_mutex_destroy(&m_hMtxMHReads);
		pthread_rwlock_destroy(&m_hRwLock);
#endif
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Fatal: unable to create mutex");
		return(eBSFerrInternal);
		}
	}
m_bMutexesCreated = true;
return(eBSFSuccess);
}

void
DeleteMutexes(void)
{
if(!m_bMutexesCreated)
	return;
#ifdef _WIN32
CloseHandle(m_hMtxIterReads);
CloseHandle(m_hMtxMHReads);
if(m_MLMode != eMLdefault)
	CloseHandle(m_hMtxMultiMatches);
#else
pthread_mutex_destroy(&m_hMtxIterReads);
pthread_mutex_destroy(&m_hMtxMHReads);
pthread_rwlock_destroy(&m_hRwLock);
if(m_MLMode != eMLdefault)
	pthread_mutex_destroy(&m_hMtxMultiMatches);
#endif
m_bMutexesCreated = false;
}

// LocateCoredApprox
// Locates all cored approximates
int
LocateCoredApprox(int MinEditDist,		// any matches must have at least this edit distance to the next best match
		int MaxSubs)					// maximum number of substitutions allowed or if -1 then 1/10th of actual read length
{
int Rslt;
int CurBlockID;							// current suffix block being processed
tBSFEntryID CurChromID;				    // current suffix array entry being processed
UINT32 TotNumReadsProc;					// total number of reads processed
UINT32 PlusHits;
UINT32 MinusHits;

UINT32 CurReadsAligned;
UINT32 PrevReadsAligned;
UINT32 CurReadsLoaded;
UINT32 PrevReadsLoaded;
int MaxNumSlides;

int ThreadIdx;
tsThreadMatchPars WorkerThreads[cMaxWorkerThreads];

m_PerThreadAllocdIdentNodes = cMaxNumIdentNodes;
m_TotAllocdIdentNodes = m_PerThreadAllocdIdentNodes * m_NumThreads;
if((m_pAllocsIdentNodes = new tsIdentNode [m_TotAllocdIdentNodes])==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Fatal: unable to allocate memory for %d tsIdentNodes",m_TotAllocdIdentNodes);
	Reset(false);
	return(eBSFerrMem);
	}

if((m_pAllocsMultiHitLoci = new tsHitLoci [m_NumThreads * (m_MaxMLmatches + cPriorityExacts)])==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Fatal: unable to allocate memory for %d tsHitLoci",m_NumThreads * m_MaxMLmatches);
	Reset(false);
	return(eBSFerrMem);
	}

if(m_MLMode == eMLall)
	{
	if((m_pAllocsMultiHitBuff = new UINT8 [m_NumThreads * cReadHitBuffLen])==NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Fatal: unable to allocate memory for %d multihit record buffering",m_NumThreads * cReadHitBuffLen);
		Reset(false);
		return(eBSFerrMem);
		}
	}
else
	m_pAllocsMultiHitBuff = NULL;




// load single SfxBlock, expected to contain all chromosomes, and process all reads against that block
CurChromID = 0;
CurBlockID = 1;
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Loading genome assembly suffix array...");
if((Rslt=m_pSfxArray->SetTargBlock(CurBlockID))<0)
	{
	while(m_pSfxArray->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pSfxArray->GetErrMsg());
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Fatal: unable to load genome assembly suffix array");
	return(Rslt);
	}
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Genome assembly suffix array loaded");

	// determine minimum core length from targeted sequence length
	// core length is a balance between sensitivity and throughput
	// reducing core size has a relatively minor effect on sensitivity but significantly reduces throughput
	// large genomes require larger cores, more sensitive alignments require smaller cores
m_BlockTotSeqLen = m_pSfxArray->GetTotSeqsLen();

if(m_BlockTotSeqLen < 20000000)				    // covers yeast
	m_MinCoreLen = cMinCoreLen;
else
	if(m_BlockTotSeqLen < 250000000)		    // covers arabidopsis and fly
		m_MinCoreLen = cMinCoreLen+3;
	else
		m_MinCoreLen = cMinCoreLen+5;			// covers the big guys...

switch(m_PMode) {
	case ePMUltraSens:				// ultra sensitive - much slower
		MaxNumSlides = 8;			// leave m_MinCoreLen at it's minimum
		break;
	case ePMMoreSens:				// more sensitive - slower
		m_MinCoreLen += 2;
		MaxNumSlides = 6;
		break;
	case ePMdefault:				// default processing mode
		m_MinCoreLen += 4;
		MaxNumSlides = 4;
		break;
	case ePMLessSens:				// less sensitive - quicker
		m_MinCoreLen += 6;
		MaxNumSlides = 3;
		break;
	default:
		MaxNumSlides = 3;
		break;
	}


gDiagnostics.DiagOut(eDLInfo,gszProcName,"Now aligning with minimum core size of %d...\n",m_MinCoreLen);

ResetThreadedIterReads();
memset(WorkerThreads,0,sizeof(WorkerThreads));
for(ThreadIdx = 0; ThreadIdx < m_NumThreads; ThreadIdx++)
	{
	WorkerThreads[ThreadIdx].ThreadIdx = ThreadIdx + 1;
	WorkerThreads[ThreadIdx].NumIdentNodes = m_PerThreadAllocdIdentNodes;
	WorkerThreads[ThreadIdx].pIdentNodes = &m_pAllocsIdentNodes[m_PerThreadAllocdIdentNodes * ThreadIdx];
	WorkerThreads[ThreadIdx].pMultiHits = &m_pAllocsMultiHitLoci[m_MaxMLmatches * ThreadIdx];
	WorkerThreads[ThreadIdx].CurBlockID = CurBlockID;
	WorkerThreads[ThreadIdx].MinEditDist = MinEditDist;
	WorkerThreads[ThreadIdx].MaxSubs = MaxSubs;
	WorkerThreads[ThreadIdx].AlignStrand = m_AlignStrand;
	WorkerThreads[ThreadIdx].microInDelLen = m_microInDelLen;
	WorkerThreads[ThreadIdx].SpliceJunctLen = m_SpliceJunctLen;
	WorkerThreads[ThreadIdx].MaxNumSlides = MaxNumSlides;
	if(m_MLMode == eMLall)
		WorkerThreads[ThreadIdx].pszOutBuff = &m_pAllocsMultiHitBuff[cReadHitBuffLen * ThreadIdx];
	else
		WorkerThreads[ThreadIdx].pszOutBuff = NULL;
	WorkerThreads[ThreadIdx].OutBuffIdx = 0;
#ifdef _WIN32
	WorkerThreads[ThreadIdx].threadHandle = (HANDLE)_beginthreadex(NULL,0x0fffff,ThreadedCoredApprox,&WorkerThreads[ThreadIdx],0,&WorkerThreads[ThreadIdx].threadID);
#else
	WorkerThreads[ThreadIdx].threadRslt =	pthread_create (&WorkerThreads[ThreadIdx].threadID , NULL , ThreadedCoredApprox , &WorkerThreads[ThreadIdx] );
#endif
	}

// allow threads a few seconds to startup
#ifdef _WIN32
	Sleep(5000);
#else
	sleep(5);
#endif

// let user know that Kanga is working hard...
ApproxNumReadsAligned(&PrevReadsAligned,&PrevReadsLoaded);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Progress: %u reads aligned from %d loaded",PrevReadsAligned,PrevReadsLoaded);

// wait for all threads to have completed
PlusHits = 0;
MinusHits = 0;
TotNumReadsProc = 0;
PrevReadsAligned = 0;
PrevReadsLoaded = 0;
for(ThreadIdx = 0; ThreadIdx < m_NumThreads; ThreadIdx++)
	{
#ifdef _WIN32
	while(WAIT_TIMEOUT == WaitForSingleObject( WorkerThreads[ThreadIdx].threadHandle, 60000))
		{
		ApproxNumReadsAligned(&CurReadsAligned,&CurReadsLoaded);
		if(CurReadsAligned > PrevReadsAligned || CurReadsLoaded > PrevReadsLoaded)
			gDiagnostics.DiagOut(eDLInfo,gszProcName,"Progress: %u reads aligned from %d loaded",CurReadsAligned,CurReadsLoaded);
		PrevReadsAligned = CurReadsAligned;
		PrevReadsLoaded = CurReadsLoaded;
		}
	CloseHandle( WorkerThreads[ThreadIdx].threadHandle);
#else
	struct timespec ts;
	int JoinRlt;
	clock_gettime(CLOCK_REALTIME, &ts);
	ts.tv_sec += 60;
	while((JoinRlt = pthread_timedjoin_np(WorkerThreads[ThreadIdx].threadID, NULL, &ts)) != 0)
		{
		ApproxNumReadsAligned(&CurReadsAligned,&CurReadsLoaded);
		if(CurReadsAligned > PrevReadsAligned || CurReadsLoaded > PrevReadsLoaded)
			gDiagnostics.DiagOut(eDLInfo,gszProcName,"Progress: %u reads aligned from %d loaded",CurReadsAligned,CurReadsLoaded);
		PrevReadsAligned = CurReadsAligned;
		PrevReadsLoaded = CurReadsLoaded;
		ts.tv_sec += 60;
		}

#endif
	PlusHits += WorkerThreads[ThreadIdx].PlusHits;
	MinusHits += WorkerThreads[ThreadIdx].MinusHits;
	TotNumReadsProc += WorkerThreads[ThreadIdx].NumReadsProc;

	if(WorkerThreads[ThreadIdx].OutBuffIdx != 0)
		{
#ifdef _WIN32
		WaitForSingleObject(m_hMtxMultiMatches,INFINITE);
#else
		pthread_mutex_lock(&m_hMtxMultiMatches);
#endif
		if((cAllocLineBuffSize - m_szLineBuffIdx) < (int)(WorkerThreads[ThreadIdx].OutBuffIdx + ((cMaxFastQSeqLen * 2) + 1024)))
			{
			CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,m_szLineBuffIdx);
			m_szLineBuffIdx = 0;
			}
		memcpy(&m_pszLineBuff[m_szLineBuffIdx],WorkerThreads[ThreadIdx].pszOutBuff,WorkerThreads[ThreadIdx].OutBuffIdx);
		m_szLineBuffIdx += WorkerThreads[ThreadIdx].OutBuffIdx;
#ifdef _WIN32
		ReleaseMutex(m_hMtxMultiMatches);
#else
		pthread_mutex_unlock(&m_hMtxMultiMatches);
#endif
		WorkerThreads[ThreadIdx].OutBuffIdx = 0;
		}
	}

// pickup the read loader thread, if the reads processing threads all finished then the loader thread should also have finished
#ifdef _WIN32
if(m_hThreadLoadReads != NULL)
	{
	while(WAIT_TIMEOUT == WaitForSingleObject(m_hThreadLoadReads, 5000))
		{
		gDiagnostics.DiagOut(eDLInfo,gszProcName,"Progress: waiting");
		}
	CloseHandle(m_hThreadLoadReads);
	}
#else
if(m_ThreadLoadReadsID != 0)
	{
	struct timespec ts;
	int JoinRlt;
	clock_gettime(CLOCK_REALTIME, &ts);
	ts.tv_sec += 5;
	while((JoinRlt = pthread_timedjoin_np(m_ThreadLoadReadsID, NULL, &ts)) != 0)
		{
		gDiagnostics.DiagOut(eDLInfo,gszProcName,"Progress: waiting");
		ts.tv_sec += 60;
		}
	}
#endif

// Checking here that the reads were all loaded w/o any major dramas!
if(m_ThreadLoadReadsRslt < 0)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Progress: problem loading");
	Reset(false);
	return(m_ThreadLoadReadsRslt);
	}
ApproxNumReadsAligned(&CurReadsAligned,&CurReadsLoaded);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Alignment of %u from %u loaded completed",CurReadsAligned,CurReadsLoaded);

m_PerThreadAllocdIdentNodes = 0;
m_TotAllocdIdentNodes = 0;
if(m_pAllocsIdentNodes != NULL)
	{
	delete m_pAllocsIdentNodes;
	m_pAllocsIdentNodes = NULL;
	}
if(m_pAllocsMultiHitLoci != NULL)
	{
	delete m_pAllocsMultiHitLoci;
	m_pAllocsMultiHitLoci = NULL;
	}

if(m_pAllocsMultiHitBuff != NULL)
	{
	delete m_pAllocsMultiHitBuff;
	m_pAllocsMultiHitBuff = NULL;
	}

if((m_FMode == eFMsam || m_FMode == eFMsamAll) && m_MLMode == eMLall)
	m_szLineBuffIdx += sprintf(&m_pszLineBuff[m_szLineBuffIdx],"\0");

if(m_szLineBuffIdx > 0)
	{
	CUtility::SafeWrite(m_hOutFile,m_pszLineBuff,m_szLineBuffIdx);
	m_szLineBuffIdx = 0;
	}

return(eBSFSuccess);
}



#ifdef _WIN32
unsigned __stdcall ThreadedCoredApprox(void * pThreadPars)
#else
void *ThreadedCoredApprox(void * pThreadPars)
#endif
{
tsThreadMatchPars *pPars = (tsThreadMatchPars *)pThreadPars; // makes it easier not having to deal with casts!
etSeqBase Sequence[cMaxFastQSeqLen+1];	// to hold sequence (sans quality scores) for current read
etSeqBase PrevSequence[cMaxFastQSeqLen+1];	// to hold sequence (sans quality scores) for previous read

int MatchLen;							// match length
int PrevMatchLen;						// previous read's match length

char szPriorityChromName[100];
int PriorityChromID;

int SeqIdx;
int NumNs;
UINT8 *pSeqVal;
etSeqBase *pSeq;

tsReadsHitBlock ReadsHitBlock;			// block of reads for this thread to process
int ReadsHitIdx;						// index of current read in ReadsHitBlock.pReadsHits[]
tsReadHit *pReadHit;					// current read being processed
tsReadHit *pPrevReadHit;				// previous to current read

UINT32 NumNonAligned = 0;				// number of reads for which no alignment was discovered
UINT32 NumAcceptedAsAligned = 0;		// number of reads accepted as being aligned
UINT32 NumLociAligned = 0;				// number of loci aligned which have been reported
UINT32 NumNotAcceptedDelta = 0;			// number of reads aligned but not accepted because of insufficient hamming
UINT32 NumAcceptedHitInsts = 0;			// number of reads aligned which were accepted even though there were too many instances
UINT32 TotAcceptedAsUniqueAligned = 0;  // number of reads aligned which were uniquely aligned
UINT32 TotAcceptedAsMultiAligned = 0;   // number of reads accepted as aligned which aligned to multiple loci

int HitRslt;
int PrevHitRslt;
int ProbeLen;
int RandIdx;
int HitIdx;
tsHitLoci *pHit;
int MaxTotMM;
int CoreLen;
int CoreDelta;

bool bForceNewAlignment;
int LowHitInstances;
int LowMMCnt;
int NxtLowMMCnt;

int	PrevLowHitInstances;
int	PrevLowMMCnt;
int	PrevNxtLowMMCnt;

int NumSloughedNs;

UINT32 ExtdProcFlags;

tsReadHit HitReads[cMaxMultiHits];
int MultiHitDist[cMaxMultiHits];		// used to record the multihit distribution

// iterate each read sequence starting from the first
// assumes that reads will have been sorted by ReadID
pPars->PlusHits = 0;
pPars->MinusHits = 0;
pPars->NumReadsProc = 0;
pReadHit = NULL;
pPrevReadHit = NULL;
PrevMatchLen = 0;
NumSloughedNs = 0;
ReadsHitBlock.MaxReads = cMaxReadsPerBlock;
ReadsHitBlock.NumReads = 0;

memset(MultiHitDist,0,sizeof(MultiHitDist));
ExtdProcFlags = 0;
pPrevReadHit = NULL;
PrevMatchLen = 0;


// m_hRwLock will be released and regained within ThreadedIterReads so need to always have acquired a read lock before calling ThreadedIterReads
AcquireLock(false);
bForceNewAlignment = true;			
while(ThreadedIterReads(&ReadsHitBlock))
	{
	for(ReadsHitIdx = 0; ReadsHitIdx < ReadsHitBlock.NumReads; ReadsHitIdx++)
		{
		pReadHit = ReadsHitBlock.pReadHits[ReadsHitIdx];
		pPars->NumReadsProc+=1;

		// get sequence for read and remove any packed quality values
		pSeqVal = &pReadHit->Read[pReadHit->DescrLen+1];
		pSeq = Sequence;
		NumNs = 0;
		int MaxNsSeq = 0;		// maximum allowed for this sequence
		if(m_MaxNs)
			MaxNsSeq = max(((pReadHit->ReadLen * m_MaxNs) / 100),m_MaxNs);

		for(SeqIdx = 0; SeqIdx < pReadHit->ReadLen; SeqIdx++,pSeq++,pSeqVal++)
			{
			if((*pSeq = (*pSeqVal & 0x07)) > eBaseN)
				break;
			*pSeq &= ~cRptMskFlg;
			if(*pSeq == eBaseN)
				{
				if(++NumNs > MaxNsSeq)
					break;
				}
			}
		if(SeqIdx != pReadHit->ReadLen) // if too many 'N's...
			{
			pPrevReadHit = NULL;
			PrevMatchLen = 0;
			NumSloughedNs += 1;
			continue;
			}

		if(m_bIsSOLiD)	// if SOLiD colorspace then need to convert read back into colorspace before attempting to locate
			{
			pSeq = Sequence;
			UINT8 PrvBase = *pSeq;
			for(SeqIdx = 1; SeqIdx < pReadHit->ReadLen; SeqIdx++,pSeq++)
				{
				*pSeq = SOLiDmap[PrvBase][pSeq[1]];
				PrvBase = pSeq[1];
				}
			ProbeLen = pReadHit->ReadLen;
			MatchLen = ProbeLen-1;
			}
		else
			{
			ProbeLen = pReadHit->ReadLen;
			MatchLen = ProbeLen;
			}

		if(pPars->MaxSubs == -1)				// use 1/10th of actual read length?
			MaxTotMM = min(MatchLen/10,cMaxAllowedSubs);
		else
			MaxTotMM = pPars->MaxSubs;			// 0..15

		// The window core length is set to be read length / (subs+1) for minimum Hamming difference of 1, and
		// to be read length / (subs+2) for minimum Hamming difference of 2
		// The window core length is clamped to be at least m_MinCoreLen
		CoreLen = max(m_MinCoreLen,MatchLen/(pPars->MinEditDist == 1 ? MaxTotMM+1 : MaxTotMM+2));
		CoreDelta = CoreLen;

		LowHitInstances = pReadHit->LowHitInstances;
		LowMMCnt = pReadHit->LowMMCnt;
		NxtLowMMCnt = pReadHit->NxtLowMMCnt;

		ExtdProcFlags &= ~0x0001;			// no trace

		// for priority alignments to known reference sequences (example would be cDNA transcripts assembled with a de Novo assembly) then
		// a) align for exact matches allowing say 10 multiloci hits
		// b) iterate these multiloci hits and discard any not aligning to a ref sequence
		// c) process those aligning to reference as if these were uniquely aligning
		int RefExacts = cPriorityExacts;
		bool bProcNorm;

		if(m_pPriorityRegionBED != NULL)
			RefExacts = cPriorityExacts;
		else
			RefExacts = 0;
			
		// Heuristic is that if read sequence is identical to previously processed sequence then
		// simply reuse previously AlignReads() hit results - saves a lot of processing time
		if(pPrevReadHit == NULL || bForceNewAlignment || MatchLen != PrevMatchLen || memcmp(Sequence,PrevSequence,MatchLen))
			{
			bProcNorm = true;
			if(RefExacts > 0)
				{
				HitRslt = m_pSfxArray->LocateCoreMultiples(0,pReadHit->ReadID,0,MatchLen,MatchLen,1,pPars->MinEditDist,pPars->AlignStrand,&LowHitInstances,
							&LowMMCnt,&NxtLowMMCnt,Sequence,MatchLen,m_MaxMLmatches+RefExacts,pPars->pMultiHits,cDfltMaxIter,pPars->NumIdentNodes,pPars->pIdentNodes);
				if(HitRslt == eHRhits)
					{
					int NumInPriorityRegions;
					int NumInNonPriorityRegions;
					tsHitLoci *pPriorityHits;
					NumInPriorityRegions = 0;
					NumInNonPriorityRegions = 0;
					pHit = pPars->pMultiHits;
					pPriorityHits = pHit;
					for(HitIdx=0; HitIdx < min(LowHitInstances,m_MaxMLmatches+RefExacts); HitIdx++,pHit++)
						{
						// check if hit loci within region designated as being a priority exact matching region
						if(m_pSfxArray->GetIdentName(pHit->Seg->ChromID,sizeof(szPriorityChromName),szPriorityChromName)!=eBSFSuccess)
							{
							NumInNonPriorityRegions += 1;
							continue;
							}
						if((PriorityChromID = m_pPriorityRegionBED->LocateChromIDbyName(szPriorityChromName)) < 1)
							{
							NumInNonPriorityRegions += 1;
							continue;
							}
						if(!m_pPriorityRegionBED->InAnyFeature(PriorityChromID,(int)pHit->Seg->MatchLoci,(int)(pHit->Seg->MatchLoci+pHit->Seg->MatchLen-1)))
							{
							NumInNonPriorityRegions += 1;
							continue;
							}
						if(NumInNonPriorityRegions > 0)
							*pPriorityHits++ = *pHit;
						NumInPriorityRegions += 1;
						}
					if(NumInPriorityRegions > 0 && (m_bClampMaxMLmatches || NumInPriorityRegions <= m_MaxMLmatches))
						{
						if(NumInPriorityRegions > m_MaxMLmatches)
							NumInPriorityRegions = m_MaxMLmatches;
						LowHitInstances = NumInPriorityRegions;
						bProcNorm = false;
						}
					}
				if(bProcNorm)
					{
					LowHitInstances = pReadHit->LowHitInstances;
					LowMMCnt = pReadHit->LowMMCnt;
					NxtLowMMCnt = pReadHit->NxtLowMMCnt;
					}
				}
			else
				bProcNorm = true;
			if(bProcNorm)
				{
				HitRslt = m_pSfxArray->AlignReads(ExtdProcFlags,						// flags indicating if lower levels need to do any form of extended processing with this specific read...
													pReadHit->ReadID,					// identifies this read
													MaxTotMM,CoreLen,CoreDelta,
													pPars->MaxNumSlides,
													pPars->MinEditDist,
													pPars->AlignStrand,				// watson, crick or both?
													pPars->microInDelLen,			// microInDel length maximum
													pPars->SpliceJunctLen,			// maximum splice junction length when aligning RNAseq reads
													&LowHitInstances,
													&LowMMCnt,
													&NxtLowMMCnt,
													Sequence,MatchLen,
													m_MaxMLmatches,					// process for at most this many hits by current read
													pPars->pMultiHits,				// where to return the loci for each hit by current read
													pPars->NumIdentNodes,
													pPars->pIdentNodes);
				}

			// user may be interested in multihits upto m_MaxMLmatches limit even if there were actually many more so in this case remap the hit result
			if(LowHitInstances > m_MaxMLmatches)
				LowHitInstances = m_MaxMLmatches + 1;
			if(m_bClampMaxMLmatches && HitRslt == eHRHitInsts)
				{
				LowHitInstances=m_MaxMLmatches;
				HitRslt = eHRhits;
				bForceNewAlignment = true;
				}
			PrevHitRslt = HitRslt;
			PrevLowHitInstances = LowHitInstances;
			PrevLowMMCnt = LowMMCnt;
			PrevNxtLowMMCnt = NxtLowMMCnt;
			PrevMatchLen = MatchLen;
			pPrevReadHit = pReadHit;
			memcpy(PrevSequence,Sequence,MatchLen);
			}
		else		// else, identical sequence, reuse previous hit results from AlignReads
			{
			HitRslt = PrevHitRslt;
			LowHitInstances = PrevLowHitInstances;
			LowMMCnt = PrevLowMMCnt;
			NxtLowMMCnt = PrevNxtLowMMCnt;
			}

		// if SOLiD colorspace then need to normalise the hits back to as if aligned in basespace
		if(m_bIsSOLiD)
			{
			switch(HitRslt) {
				case eHRHitInsts:
					if(m_MLMode != eMLall)
						break;
				case eHRhits:
					pHit = pPars->pMultiHits;
					for(HitIdx=0; HitIdx <  min(LowHitInstances,m_MaxMLmatches); HitIdx++,pHit++)
						{
						pHit->Seg[0].MatchLoci -= 1;
						pHit->Seg[0].MatchLen += 1;
						if(pHit->FlgInDel == 1 || pHit->FlgSplice == 1)
							pHit->Seg[1].ReadOfs += 1;
						}
					break;
				default:
					break;
				}
			}

		// ensure that TrimLeft/Right/Mismatches are consistent with the fact that trimming is a post alignment phase
		if(HitRslt == eHRHitInsts ||  HitRslt == eHRhits)
			{
			pHit = pPars->pMultiHits;
			for(HitIdx=0; HitIdx < min(LowHitInstances,m_MaxMLmatches); HitIdx++,pHit++)
				{
				pHit->Seg[0].TrimLeft = 0;
				pHit->Seg[0].TrimRight = 0;
				pHit->Seg[0].TrimMismatches = pHit->Seg[0].Mismatches;
				if(pHit->FlgInDel == 1 || pHit->FlgSplice == 1)
					{
					pHit->Seg[1].TrimLeft = 0;
					pHit->Seg[1].TrimRight = 0;
					pHit->Seg[1].TrimMismatches = pHit->Seg[1].Mismatches;
					}
				}
			}



		switch(HitRslt) {
			case eHRnone:			// no change or no hits
				if(m_MLMode == eMLall && m_FMode == eFMsamAll)
					{
					pReadHit->LowMMCnt = (INT8)0;
					WriteHitLoci(pPars,pReadHit,0,pPars->pMultiHits);
					}
				NumNonAligned += 1;
				bForceNewAlignment = false;
				break;

			case eHRhits:			// MMDelta criteria met and within the max allowed number of hits
				if(LowHitInstances > 1)
					bForceNewAlignment = true;
				else
					bForceNewAlignment = false;

				NumAcceptedAsAligned += 1;
				NumLociAligned += LowHitInstances;
				if(LowHitInstances == 1)
					TotAcceptedAsUniqueAligned += 1;
				else
					TotAcceptedAsMultiAligned += 1;

				if(m_MLMode == eMLall)
					{
					// report each hit here...
					pReadHit->LowMMCnt = (INT8)LowMMCnt;
					WriteHitLoci(pPars,pReadHit,LowHitInstances,pPars->pMultiHits);
					HitRslt = eHRHitInsts;
					break;
					}
				MultiHitDist[LowHitInstances-1] += 1;
				if(m_MLMode == eMLrand)
					RandIdx = m_MaxMLmatches == 1 ? 0 : (rand() % LowHitInstances);
				else
					RandIdx = 0;
				if(m_MLMode <= eMLrand || LowHitInstances == 1)
					{
					if((m_MLMode == eMLdist && LowHitInstances == 1) || m_MLMode != eMLdist)
						{
						if(LowHitInstances == 1)	// was this a unique hit?
							pReadHit->HitLoci.FlagHL = (int)eHLunique;
						else
							pReadHit->HitLoci.FlagHL = (int)eHLrandom;
						LowHitInstances = 1;			// currently just accepting one
						pReadHit->NumHits = 1;
						pReadHit->HitLoci.Hit = pPars->pMultiHits[RandIdx];
						pReadHit->HitLoci.FlagSegs = (pReadHit->HitLoci.Hit.FlgInDel == 1 || pReadHit->HitLoci.Hit.FlgSplice == 1) ? 1 : 0;
						}
					else
						pReadHit->NumHits = 0;
					}
				else
					if(LowHitInstances == 1)
						pReadHit->NumHits = 1;

				pReadHit->LowHitInstances = (INT16)LowHitInstances;
				pReadHit->LowMMCnt = (INT8)LowMMCnt;
				pReadHit->NxtLowMMCnt = (INT8)NxtLowMMCnt;
// handling multiply aligned reads
				if(m_MLMode > eMLrand)
					{
					int HitIdx;
					tsHitLoci *pHit;
					tsReadHit *pMHit;
					pHit = pPars->pMultiHits;
					pMHit = &HitReads[0];
					for(HitIdx=0; HitIdx < LowHitInstances; HitIdx++,pMHit++,pHit++)
						{
						pMHit->ReadID = pReadHit->ReadID;
						pMHit->HitLoci.Hit = *pHit;
						pMHit->HitLoci.FlagSegs = (pMHit->HitLoci.Hit.FlgInDel == 1 || pMHit->HitLoci.Hit.FlgSplice == 1) ? 1 : 0;
						pMHit->HitLoci.FlagMH = LowHitInstances > 1 ? 1 : 0;
						pMHit->HitLoci.FlagMHA = 0;
						}
					AddMHitReads(LowHitInstances,&HitReads[0]);		// pts to array of hit loci
					}
// finish handling multiply aligned reads
				break;

			case eHRMMDelta:			// same or a new LowMMCnt unique hit but MMDelta criteria not met
				NumNotAcceptedDelta += 1;
				memset(&pReadHit->HitLoci.Hit.Seg[0],0,sizeof(tsSegLoci));
				pReadHit->NumHits = 0;
				pReadHit->HitLoci.Hit.Seg[0].Strand = '?';
				pReadHit->HitLoci.Hit.BisBase = eBaseN;
				pReadHit->HitLoci.Hit.Seg[0].MatchLen = (UINT16)ProbeLen;
				pReadHit->LowHitInstances = (INT16)LowHitInstances;
				pReadHit->LowMMCnt = (INT8)LowMMCnt;
				pReadHit->NxtLowMMCnt = (INT8)NxtLowMMCnt;
				bForceNewAlignment = false;
				break;

			case eHRHitInsts:			// same or new LowMMCnt but now simply too many multiple hit instances, treat as none-aligned
				if(m_MLMode == eMLall && m_FMode == eFMsamAll)
					{
					pReadHit->LowMMCnt = (INT8)0;
					WriteHitLoci(pPars,pReadHit,0,pPars->pMultiHits);
					}
				NumNonAligned += 1;
				bForceNewAlignment = false;
				break;

			case eHRRMMDelta:			// reduced NxtLowMMCnt only
				pReadHit->NxtLowMMCnt = (INT8)NxtLowMMCnt;
				bForceNewAlignment = false;
				break;
			}

		if(HitRslt == eHRHitInsts)
			{
			pReadHit->NumHits = 0;
			memset(&pReadHit->HitLoci.Hit.Seg[0],0,sizeof(tsSegLoci));
			pReadHit->HitLoci.Hit.Seg[0].Strand = '?';
			pReadHit->HitLoci.Hit.BisBase = eBaseN;
			pReadHit->HitLoci.Hit.Seg[0].MatchLen = (UINT16)ProbeLen;
			pReadHit->LowHitInstances = (INT16)LowHitInstances;
			pReadHit->LowMMCnt = (INT8)LowMMCnt;
			pReadHit->NxtLowMMCnt = (INT8)NxtLowMMCnt;
			}

		// if SOLiD colorspace then need to restore any hits to what they were immediately following return from AlignReads
		// as when SOLiD processing MatchLoci/MatchLen and ReadOfs would have all been normalised as if basespace processing and if
		// a duplicate of this read sequence follows then hits will be simply reused w/o the overhead of a call to AlignReads
		if(m_bIsSOLiD)
			{
			switch(HitRslt) {
				case eHRHitInsts:
					if(m_MLMode != eMLall)
						break;
				case eHRhits:
					pHit = pPars->pMultiHits;
					for(HitIdx=0; HitIdx <  min(LowHitInstances,m_MaxMLmatches); HitIdx++,pHit++)
						{
						pHit->Seg[0].MatchLoci += 1;
						pHit->Seg[0].MatchLen -= 1;
						if(pHit->FlgInDel == 1 || pHit->FlgSplice == 1)
							pHit->Seg[1].ReadOfs -= 1;
						}
					break;
				default:
					break;
				}
			}
		}
	}

ReleaseLock(false);
AcquireSerialise();
m_NumSloughedNs += NumSloughedNs;
m_TotNonAligned += NumNonAligned;
m_TotAcceptedAsUniqueAligned += TotAcceptedAsUniqueAligned;
m_TotAcceptedAsMultiAligned += TotAcceptedAsMultiAligned;
m_TotAcceptedAsAligned += NumAcceptedAsAligned;
m_TotLociAligned += NumLociAligned;
m_TotNotAcceptedDelta += NumNotAcceptedDelta;
m_TotAcceptedHitInsts += NumAcceptedHitInsts;

if(m_MLMode != eMLall)
	{
	int Idx;
	for(Idx = 0; Idx < m_MaxMLmatches; Idx++)
		m_MultiHitDist[Idx] += MultiHitDist[Idx];
	}

ReleaseSerialise();

pPars->Rslt = 1;
#ifdef _WIN32
_endthreadex(0);
return(eBSFSuccess);
#else
pthread_exit(NULL);
#endif
}


// LocateRead
// Locate read with requested ReadID
tsReadHit *
LocateRead(UINT32 ReadID)
{
int Rslt;
tsReadHit *pProbe;
int Lo,Mid,Hi;	// search limits

if(m_ppReadHitsIdx == NULL || m_AllocdReadHitsIdx < m_NumReadsLoaded)
	return(NULL);

Lo = 0;
Hi = m_NumReadsLoaded-1;
while(Hi >= Lo) {
	Mid = (Hi + Lo)/2;
	pProbe = m_ppReadHitsIdx[Mid];
	Rslt = pProbe->ReadID - ReadID;
	if(Rslt > 0)
		{
		Hi = Mid - 1;
		continue;
		}
	if(Rslt < 0)
		{
		Lo = Mid + 1;
		continue;
		}
	return(pProbe);
	}
return(NULL);
}

int
AddMHitReads(UINT32 NumHits,	// number of multimatches loci in pHits
		tsReadHit *pHits)		// pts to array of hit loci
{
size_t memreq;
tsReadHit *pDstHits;
// ensure actually processing multihits
if(m_MLMode <= eMLrand)
	return(0);					// silently slough these hits

AcquireSerialiseMH();

if((m_AllocdMultiHits - m_NumMultiHits) < (NumHits+1000))	// need to realloc? -- added 1000 to provide a little safety margin
	{
	memreq = (m_AllocdMultiHits + cAllocMultihits) * sizeof(tsReadHit);
#ifdef _WIN32
	pDstHits = (tsReadHit *) realloc(m_pMultiHits,memreq);
#else
	pDstHits = (tsReadHit *)mremap(m_pMultiHits,m_AllocdMultiHitsMem,memreq,MREMAP_MAYMOVE);
	if(pDstHits == MAP_FAILED)
		pDstHits = NULL;
#endif
	if(pDstHits == NULL)
		{
		ReleaseSerialiseMH();
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"AddMHitReads: Memory re-allocation to %d bytes - %s",memreq,strerror(errno));
		return(eBSFerrMem);
		}
	m_pMultiHits = pDstHits;
	m_AllocdMultiHitsMem = memreq;
	m_AllocdMultiHits += cAllocMultihits;
	}
pDstHits = &m_pMultiHits[m_NumMultiHits];
memcpy(pDstHits,pHits,sizeof(tsReadHit) * NumHits);
m_NumMultiHits += NumHits;
if(NumHits == 1)
	m_NumUniqueMultiHits += 1;
else
	m_NumProvMultiAligned += 1;
ReleaseSerialiseMH();
return(m_NumMultiHits);
}


// ThreadedIterReads
// use to return a block of reads reserved for processing by calling thread instance
// Returns false if no more reads available for processing
unsigned long ProcessingStartSecs;

void
ResetThreadedIterReads(void) // must be called by master thread prior to worker threads calling ThreadedIterReads()
{
m_NumReadsProc = 0;
m_NxtReadProcOfs = 0;
ProcessingStartSecs = gStopWatch.ReadUSecs();
}


// Returns the number of reads thus far loaded and aligned
UINT32
ApproxNumReadsAligned(UINT32 *pNumAligned,UINT32 *pNumLoaded)
{
UINT32 NumAligned;
AcquireSerialise();
NumAligned = m_NumReadsProc;
if(pNumAligned != NULL)
	*pNumAligned = NumAligned;
*pNumLoaded = m_NumReadsLoaded;
ReleaseSerialise();
return(NumAligned);
}

// ThreadedIterReads
// Iterates over all reads
// The body of this function is serialised
bool	// returns false if no more reads availing for processing by calling thread
ThreadedIterReads(tsReadsHitBlock *pRetBlock)
{
UINT32 NumReadsLeft;
UINT32 MaxReads2Proc;
tsReadHit *pCurReadHit;
pRetBlock->NumReads = 0;


ReleaseLock(false);
while(1) {
	AcquireSerialise();
	AcquireLock(false);
	if(m_pReadHits == NULL || m_bAllReadsLoaded || m_NumReadsProc != m_NumReadsLoaded)
    	break;

	ReleaseLock(false);
	ReleaseSerialise();
#ifdef _WIN32
	Sleep(1000);			// must have caught up to the reads loader, allow it some breathing space to parse and load some more reads...
#else
	sleep(1);
#endif
	}

if(m_pReadHits == NULL ||
	(m_bAllReadsLoaded && (m_LoadReadsRslt != eBSFSuccess)) ||
	m_bAllReadsLoaded && (m_NumReadsLoaded == 0 || m_NumReadsProc == m_NumReadsLoaded)) // if all reads have been loaded and all processed then time to move onto next processing phase
	{
	pRetBlock->NumReads = 0;
	pRetBlock->pReadHits[0] = NULL;
	ReleaseSerialise();
	return(false);
	}

// adjust pRetBlock->MaxReads according to the number of reads remaining and threads still processing these reads
// idea is to maximise the number of threads still processing when most reads have been processed so that
// the last thread processing doesn't end up with a large block of reads needing lengthly processing
NumReadsLeft = m_NumReadsLoaded - m_NumReadsProc;
if(NumReadsLeft < cMaxReadsPerBlock/4)	// if < cMaxReadsPerBlock/4 yet to be processed then give it all to the one thread
	MaxReads2Proc = NumReadsLeft;
else
	MaxReads2Proc = min((UINT32)pRetBlock->MaxReads,10 + (NumReadsLeft / (UINT32)m_NumThreads));
MaxReads2Proc = min(MaxReads2Proc,NumReadsLeft);
if(!m_NumReadsProc)
	m_NxtReadProcOfs = 0;
pCurReadHit = (tsReadHit *)((UINT8 *)m_pReadHits + m_NxtReadProcOfs);

while(MaxReads2Proc)
	{
	pRetBlock->pReadHits[pRetBlock->NumReads++] = pCurReadHit;
	pCurReadHit = (tsReadHit *)((UINT8 *)pCurReadHit + sizeof(tsReadHit) + pCurReadHit->ReadLen + pCurReadHit->DescrLen);
	MaxReads2Proc -= 1;
	}

m_NumReadsProc += pRetBlock->NumReads;
m_NxtReadProcOfs = (size_t)((UINT8 *)pCurReadHit - (UINT8 *)m_pReadHits);

ReleaseSerialise();
return(true);
}


// IterReads
// use to iterate over reads returning ptr to next read following the current read
// To start from first read then pass in NULL as pCurReadHit
// Returns NULL if all read hits have been iterate
tsReadHit *
IterReads(tsReadHit *pCurReadHit)
{
tsReadHit *pNxtReadHit = NULL;
if(pCurReadHit == NULL)
	pNxtReadHit = m_pReadHits;
else
	if(pCurReadHit->ReadID != m_FinalReadID)
		pNxtReadHit = (tsReadHit *)((UINT8 *)pCurReadHit + sizeof(tsReadHit) + pCurReadHit->ReadLen + pCurReadHit->DescrLen);
return(pNxtReadHit);
}

// IterSortedReads
// use to iterate over sorted reads returning ptr to next read following the current read
// To start from first read then pass in NULL as pCurReadHit
// Returns NULL if all read hits have been iterated
tsReadHit *
IterSortedReads(tsReadHit *pCurReadHit)
{
tsReadHit *pNxtReadHit = NULL;
if(pCurReadHit == NULL)
	pNxtReadHit = m_ppReadHitsIdx[0];
else
	if(pCurReadHit->ReadHitIdx < m_NumReadsLoaded)
		pNxtReadHit = m_ppReadHitsIdx[pCurReadHit->ReadHitIdx];
return(pNxtReadHit);
}

// NumUniques
// Returns number of unique loci to which reads map which are downstream of the specified current read
int											// returned number of unique reads
NumDnUniques(tsReadHit *pCurReadHit,		// current read
				int WinLen,					// only interested in unique reads starting within this window
				bool bStrandDep)			// if true then unique loci reads must be on current read stand
{
int NumUniques;
UINT32 CurChromID;
UINT8 CurStrand;
int CurStart;
int NxtStart;
int PrvNxtStart;
UINT32 NxtReadIdx;
tsReadHit *pNxtReadHit = NULL;

if(pCurReadHit == NULL)									// if NULL then start from first
	NxtReadIdx = 0;
else
	if((NxtReadIdx = pCurReadHit->ReadHitIdx) == m_NumReadsLoaded)
		return(0);

// have the next read, iterate forward counting the uniques until loci outside of window
CurChromID = pCurReadHit->HitLoci.Hit.Seg[0].ChromID;
CurStart = AdjStartLoci(&pCurReadHit->HitLoci.Hit.Seg[0]);
PrvNxtStart = CurStart;
CurStrand = pCurReadHit->HitLoci.Hit.Seg[0].Strand;
NumUniques = 0;
do {
	pNxtReadHit = m_ppReadHitsIdx[NxtReadIdx];
	NxtReadIdx = pNxtReadHit->ReadHitIdx;
	if(CurChromID != pNxtReadHit->HitLoci.Hit.Seg[0].ChromID)		// must be on same chromosome
		return(NumUniques);
	if(pNxtReadHit->NumHits != 1)						// skip over any read not uniquely aligned
		continue;
	NxtStart = AdjStartLoci(&pNxtReadHit->HitLoci.Hit.Seg[0]);

	if((CurStart + WinLen) < NxtStart)					// outside of window?
		return(NumUniques);

	if(bStrandDep && CurStrand != pNxtReadHit->HitLoci.Hit.Seg[0].Strand) // has to be on same strand?
		continue;

	if(NxtStart != PrvNxtStart)
		{
		NumUniques += 1;
		PrvNxtStart = NxtStart;
		}
	}
while(NxtReadIdx != m_NumReadsLoaded);
return(NumUniques);
}


// NumUniques
// Returns number of unique loci to which reads map which are upstream of the specified current read
int											// returned number of unique reads
NumUpUniques(tsReadHit *pCurReadHit,		// current read
				int WinLen,					// only interested in unique reads starting within this window
				bool bStrandDep)			// if true then unique loci reads must be on current read stand
{
int NumUniques;
UINT32 CurChromID;
UINT8 CurStrand;
int CurStart;
int NxtStart;
int PrvNxtStart;
UINT32 NxtReadIdx;
tsReadHit *pNxtReadHit = NULL;

if(pCurReadHit == NULL || (NxtReadIdx = pCurReadHit->ReadHitIdx)==1) // if NULL or first then
	return(0);								// can't be any upstream from the first!

CurChromID = pCurReadHit->HitLoci.Hit.Seg[0].ChromID;
CurStart = AdjStartLoci(&pCurReadHit->HitLoci.Hit.Seg[0]);
PrvNxtStart = CurStart;
CurStrand = pCurReadHit->HitLoci.Hit.Seg[0].Strand;
NumUniques = 0;
do {
	pNxtReadHit = m_ppReadHitsIdx[NxtReadIdx-1];
	if(CurChromID != pNxtReadHit->HitLoci.Hit.Seg[0].ChromID)		// must be on same chromosome
		return(NumUniques);
	if(pNxtReadHit->NumHits != 1)						// skip over any read not uniquely aligned
		continue;
	NxtStart = AdjStartLoci(&pNxtReadHit->HitLoci.Hit.Seg[0]);

	if(CurStart > WinLen && (CurStart - WinLen) > NxtStart)					// outside of window?
		return(NumUniques);

	if(bStrandDep && CurStrand != pNxtReadHit->HitLoci.Hit.Seg[0].Strand) // has to be on same strand?
		continue;

	if(NxtStart != PrvNxtStart)
		{
		NumUniques += 1;
		PrvNxtStart = NxtStart;
		}
	}
while(NxtReadIdx-- > 0);
return(NumUniques);
}

int
SortReadHits(etReadsSortMode SortMode,		// sort mode required
				bool bSeqSorted)			// used to optimise eRSMSeq processing, if it is known that reads are already sorted in sequence order (loaded from pre-processed .rds file)
{
tsReadHit *pReadHit;
int Idx;

if(SortMode == m_CurReadsSortMode && m_ppReadHitsIdx != NULL && m_AllocdReadHitsIdx >= m_NumReadsLoaded)
	return(eBSFSuccess);					// if already in requested mode

if(m_ppReadHitsIdx == NULL || m_AllocdReadHitsIdx < m_NumReadsLoaded)
	{
	if(m_ppReadHitsIdx != NULL)
		{
		delete m_ppReadHitsIdx;
		m_ppReadHitsIdx = NULL;
		m_AllocdReadHitsIdx = 0;
		}
	if((m_ppReadHitsIdx = (tsReadHit **) new tsReadHit * [m_NumReadsLoaded])==NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"SortReadHits: Memory reads index allocation for %d ptrs - %s",m_NumReadsLoaded,strerror(errno));
		return(eBSFerrMem);
		}
	m_AllocdReadHitsIdx = m_NumReadsLoaded;
	}

if(SortMode != eRSMSeq || bSeqSorted)
	{
	pReadHit = NULL;
	tsReadHit **pIdx = m_ppReadHitsIdx;
	while((pReadHit = IterReads(pReadHit))!=NULL)
		*pIdx++ = pReadHit;
	}
else
	{
	pReadHit = m_pReadHits;
	size_t BuffOfs = 0;
	for(Idx = 0; Idx < (int)m_NumReadsLoaded; Idx++)
		{
		m_ppReadHitsIdx[Idx] = pReadHit;
		BuffOfs += sizeof(tsReadHit) + pReadHit->ReadLen + pReadHit->DescrLen;
		pReadHit = (tsReadHit *)((char *)m_pReadHits+BuffOfs);
		}
	}

switch(SortMode) {
	case eRSMReadID:
		mtqsort.qsort(m_ppReadHitsIdx,m_NumReadsLoaded,sizeof(tsReadHit *),SortReadIDs);
		break;
	case eRSMPairReadID:
		mtqsort.qsort(m_ppReadHitsIdx,m_NumReadsLoaded,sizeof(tsReadHit *),SortPairReadIDs);
		break;
	case eRSMHitMatch:
		mtqsort.qsort(m_ppReadHitsIdx,m_NumReadsLoaded,sizeof(tsReadHit *),SortHitMatch);
		break;

	case eRSMPEHitMatch:
		mtqsort.qsort(m_ppReadHitsIdx,m_NumReadsLoaded,sizeof(tsReadHit *),SortPEHitMatch);
		break;		

	case eRSMSeq:
		if(!bSeqSorted)
			mtqsort.qsort(m_ppReadHitsIdx,m_NumReadsLoaded,sizeof(tsReadHit *),SortReadSeqs);
		break;
	default:
		break;
	}

// m_ppReadHitsIdx now in requested order, assign sequentially incrementing ReadHitIdx to the reads
for(Idx = 0; Idx < (int)m_NumReadsLoaded; Idx++)
	m_ppReadHitsIdx[Idx]->ReadHitIdx = Idx + 1;

m_CurReadsSortMode = SortMode;
return(eBSFSuccess);
}


// SortReadIDs
// Sort reads by ascending read identifiers
static int
SortReadIDs(const void *arg1, const void *arg2)
{
tsReadHit *pEl1 = *(tsReadHit **)arg1;
tsReadHit *pEl2 = *(tsReadHit **)arg2;

if(pEl1->ReadID < pEl2->ReadID )
		return(-1);
if(pEl1->ReadID > pEl2->ReadID )
	return(1);
return(0);
}

// SortPairReadIDs
// Sort paired reads reads by ascending PairReadID identifiers
static int
SortPairReadIDs(const void *arg1, const void *arg2)
{
tsReadHit *pEl1 = *(tsReadHit **)arg1;
tsReadHit *pEl2 = *(tsReadHit **)arg2;
UINT32 El1ID = pEl1->PairReadID & 0x7fffffff;
UINT32 El2ID = pEl2->PairReadID & 0x7fffffff;

if(El1ID < El2ID)
	return(-1);
if(El1ID > El2ID)
	return(1);
if(pEl1->PairReadID & 0x80000000)
	return(1);
return(0);
}

// SortPEHitmatch
// Sort by ascending hit count,chrom, PairReadID, 5' forward read
static int
SortPEHitMatch(const void *arg1, const void *arg2)
{
tsReadHit *pEl1 = *(tsReadHit **)arg1;
tsReadHit *pEl2 = *(tsReadHit **)arg2;
UINT32 El1ID;
UINT32 El2ID;

if(pEl1->NumHits < pEl2->NumHits)
		return(-1);
if(pEl1->NumHits > pEl2->NumHits)
	return(1);
if(pEl1->HitLoci.Hit.Seg[0].ChromID < pEl2->HitLoci.Hit.Seg[0].ChromID)
		return(-1);
if(pEl1->HitLoci.Hit.Seg[0].ChromID > pEl2->HitLoci.Hit.Seg[0].ChromID)
	return(1);

El1ID = pEl1->PairReadID & 0x7fffffff;
El2ID = pEl2->PairReadID & 0x7fffffff;
if(El1ID < El2ID)
	return(-1);
if(El1ID > El2ID)
	return(1);
if(pEl1->PairReadID & 0x80000000)
	return(1);
return(0);
}


// SortHitmatch
// Sort by ascending hit count,chrom, loci, strand, LowMMCnt
static int
SortHitMatch(const void *arg1, const void *arg2)
{
tsReadHit *pEl1 = *(tsReadHit **)arg1;
tsReadHit *pEl2 = *(tsReadHit **)arg2;

if(pEl1->NumHits < pEl2->NumHits)
		return(-1);
if(pEl1->NumHits > pEl2->NumHits)
	return(1);
if(pEl1->HitLoci.Hit.Seg[0].ChromID < pEl2->HitLoci.Hit.Seg[0].ChromID)
		return(-1);
if(pEl1->HitLoci.Hit.Seg[0].ChromID > pEl2->HitLoci.Hit.Seg[0].ChromID)
	return(1);
if(AdjStartLoci(&pEl1->HitLoci.Hit.Seg[0]) < AdjStartLoci(&pEl2->HitLoci.Hit.Seg[0]))
		return(-1);
if(AdjStartLoci(&pEl1->HitLoci.Hit.Seg[0]) > AdjStartLoci(&pEl2->HitLoci.Hit.Seg[0]))
	return(1);

if(AdjHitLen(&pEl1->HitLoci.Hit.Seg[0]) < AdjHitLen(&pEl2->HitLoci.Hit.Seg[0]))
		return(-1);
if(AdjHitLen(&pEl1->HitLoci.Hit.Seg[0]) > AdjHitLen(&pEl2->HitLoci.Hit.Seg[0]))
	return(1);

if(pEl1->HitLoci.Hit.Seg[0].Strand < pEl2->HitLoci.Hit.Seg[0].Strand)
		return(-1);
if(pEl1->HitLoci.Hit.Seg[0].Strand > pEl2->HitLoci.Hit.Seg[0].Strand)
	return(1);
if(pEl1->LowMMCnt < pEl2->LowMMCnt)
		return(-1);
if(pEl1->LowMMCnt > pEl2->LowMMCnt)
	return(1);
return(0);
}

// SortMultiHits
// Sort by ascending ChromID, HitLoci, HitLen, Hitmismatches, Strand, then ReadID
static int
SortMultiHits(const void *arg1, const void *arg2)
{
tsReadHit *pEl1 = (tsReadHit *)arg1;
tsReadHit *pEl2 = (tsReadHit *)arg2;

if(pEl1->HitLoci.Hit.Seg[0].ChromID < pEl2->HitLoci.Hit.Seg[0].ChromID )
		return(-1);
if(pEl1->HitLoci.Hit.Seg[0].ChromID > pEl2->HitLoci.Hit.Seg[0].ChromID )
	return(1);
if(AdjStartLoci(&pEl1->HitLoci.Hit.Seg[0]) < AdjStartLoci(&pEl2->HitLoci.Hit.Seg[0]))
		return(-1);
if(AdjStartLoci(&pEl1->HitLoci.Hit.Seg[0]) > AdjStartLoci(&pEl2->HitLoci.Hit.Seg[0]))
	return(1);
if(AdjHitLen(&pEl1->HitLoci.Hit.Seg[0]) < AdjHitLen(&pEl2->HitLoci.Hit.Seg[0]))
	return(-1);
if(AdjHitLen(&pEl1->HitLoci.Hit.Seg[0]) > AdjHitLen(&pEl2->HitLoci.Hit.Seg[0]))
	return(1);

if(pEl1->HitLoci.Hit.Seg[0].Mismatches < pEl2->HitLoci.Hit.Seg[0].Mismatches )
	return(-1);
if(pEl1->HitLoci.Hit.Seg[0].Mismatches > pEl2->HitLoci.Hit.Seg[0].Mismatches )
	return(1);

if(pEl1->HitLoci.Hit.Seg[0].Strand < pEl2->HitLoci.Hit.Seg[0].Strand )
		return(-1);
if(pEl1->HitLoci.Hit.Seg[0].Strand > pEl2->HitLoci.Hit.Seg[0].Strand )
	return(1);

if(pEl1->ReadID < pEl2->ReadID )
	return(-1);
if(pEl1->ReadID > pEl2->ReadID )
	return(1);
return(0);
}

// SortMultiHitReadIDs
// sort by ascending ReadID then by descending scores
// to break tied scores, further sorted by
static int
SortMultiHitReadIDs(const void *arg1, const void *arg2)
{
tsReadHit *pEl1 = (tsReadHit *)arg1;
tsReadHit *pEl2 = (tsReadHit *)arg2;

if(pEl1->ReadID < pEl2->ReadID)
		return(-1);
if(pEl1->ReadID > pEl2->ReadID)
	return(1);

if(pEl1->HitLoci.Hit.Score > pEl2->HitLoci.Hit.Score)
		return(-1);
if(pEl1->HitLoci.Hit.Score < pEl2->HitLoci.Hit.Score)
	return(1);

if(pEl1->HitLoci.Hit.Seg[0].ChromID < pEl2->HitLoci.Hit.Seg[0].ChromID )
		return(-1);
if(pEl1->HitLoci.Hit.Seg[0].ChromID > pEl2->HitLoci.Hit.Seg[0].ChromID )
	return(1);

if(AdjHitLen(&pEl1->HitLoci.Hit.Seg[0]) < AdjHitLen(&pEl2->HitLoci.Hit.Seg[0]))
	return(-1);
if(AdjHitLen(&pEl1->HitLoci.Hit.Seg[0]) > AdjHitLen(&pEl2->HitLoci.Hit.Seg[0]))
	return(1);

if(pEl1->HitLoci.Hit.Seg[0].Mismatches < pEl2->HitLoci.Hit.Seg[0].Mismatches )
	return(-1);
if(pEl1->HitLoci.Hit.Seg[0].Mismatches > pEl2->HitLoci.Hit.Seg[0].Mismatches )
	return(1);

if(AdjStartLoci(&pEl1->HitLoci.Hit.Seg[0]) < AdjStartLoci(&pEl2->HitLoci.Hit.Seg[0]))
		return(-1);
if(AdjStartLoci(&pEl1->HitLoci.Hit.Seg[0]) > AdjStartLoci(&pEl2->HitLoci.Hit.Seg[0]))
	return(1);

if(pEl1->HitLoci.Hit.Seg[0].Strand < pEl2->HitLoci.Hit.Seg[0].Strand )
		return(-1);
if(pEl1->HitLoci.Hit.Seg[0].Strand > pEl2->HitLoci.Hit.Seg[0].Strand )
	return(1);

return(0);
}

// SortSegJuncts
// sort by ascending chrom, start, end
static int
SortSegJuncts(const void *arg1, const void *arg2)
{
tsSegJuncts *pEl1 = (tsSegJuncts *)arg1;
tsSegJuncts *pEl2 = (tsSegJuncts *)arg2;

if(pEl1->ChromID < pEl2->ChromID)
		return(-1);
if(pEl1->ChromID > pEl2->ChromID)
	return(1);

if(pEl1->Starts < pEl2->Starts)
		return(-1);
if(pEl1->Starts > pEl2->Starts)
	return(1);
if(pEl1->Ends < pEl2->Ends)
		return(-1);
if(pEl1->Ends > pEl2->Ends)
	return(1);
return(0);
}

static int
SortReadSeqs(const void *arg1, const void *arg2)
{
int Idx;
UINT8 *pSeq1;
UINT8 *pSeq2;

tsReadHit *pEl1 = *(tsReadHit **)arg1;
tsReadHit *pEl2 = *(tsReadHit **)arg2;

pSeq1 = &pEl1->Read[pEl1->DescrLen+1];
pSeq2 = &pEl2->Read[pEl2->DescrLen+1];

for(Idx = 0; Idx < pEl1->ReadLen; Idx++, pSeq1++, pSeq2++)
	{
	if((*pSeq1 & 0x07) < (*pSeq2 & 0x07))
		return(-1);
	if((*pSeq1 & 0x07) > (*pSeq2 & 0x07))
		return(1);
	if(Idx >= pEl2->ReadLen)
		return(1);
	}
if(pEl1->ReadLen < pEl2->ReadLen)
	return(-1);
return(0);
}

static int
SortLociPValues(const void *arg1, const void *arg2)
{
tsLociPValues *pEl1 = (tsLociPValues *)arg1;
tsLociPValues *pEl2 = (tsLociPValues *)arg2;
if(pEl1->PValue < pEl2->PValue)
		return(-1);
if(pEl1->PValue > pEl2->PValue)
	return(1);
return(0);
}

static int
SortPValuesLoci(const void *arg1, const void *arg2)
{
tsLociPValues *pEl1 = (tsLociPValues *)arg1;
tsLociPValues *pEl2 = (tsLociPValues *)arg2;
if(pEl1->Loci < pEl2->Loci)
		return(-1);
if(pEl1->Loci > pEl2->Loci)
	return(1);
return(0);
}


static int
SortSiteRelScale(const void *arg1, const void *arg2)
{
tsOctSitePrefs *pEl1 = (tsOctSitePrefs *)arg1;
tsOctSitePrefs *pEl2 = (tsOctSitePrefs *)arg2;
if(pEl1->RelScale < pEl2->RelScale)
		return(-1);
if(pEl1->RelScale > pEl2->RelScale)
	return(1);
return(0);
}

static int
SortSiteRelOctamer(const void *arg1, const void *arg2)
{
tsOctSitePrefs *pEl1 = (tsOctSitePrefs *)arg1;
tsOctSitePrefs *pEl2 = (tsOctSitePrefs *)arg2;
if(pEl1->Octamer < pEl2->Octamer)
		return(-1);
if(pEl1->Octamer > pEl2->Octamer)
	return(1);
return(0);
}

//---------------------




teBSFrsltCodes
LoadRawReads(bool bIsPairRead,	// true if this file to process contains the paired reads
 		  int FileID,						// uniquely identifies source file
		  char *pszFile,					// process from this file
		  char *pszPE1File);					// optionally process PE2 reads from this file

void
AcquireSerialise(void)
{
#ifdef _WIN32
WaitForSingleObject(m_hMtxIterReads,INFINITE);
#else
pthread_mutex_lock(&m_hMtxIterReads);
#endif
}

void
ReleaseSerialise(void)
{
#ifdef _WIN32
ReleaseMutex(m_hMtxIterReads);
#else
pthread_mutex_unlock(&m_hMtxIterReads);
#endif
}

void
AcquireSerialiseMH(void)
{
#ifdef _WIN32
WaitForSingleObject(m_hMtxMHReads,INFINITE);
#else
pthread_mutex_lock(&m_hMtxMHReads);
#endif
}

void
ReleaseSerialiseMH(void)
{
#ifdef _WIN32
ReleaseMutex(m_hMtxMHReads);
#else
pthread_mutex_unlock(&m_hMtxMHReads);
#endif
}
void
AcquireLock(bool bExclusive)
{
#ifdef _WIN32
if(bExclusive)
	AcquireSRWLockExclusive(&m_hRwLock);
else
	AcquireSRWLockShared(&m_hRwLock);
#else
if(bExclusive)
	pthread_rwlock_wrlock(&m_hRwLock);
else
	pthread_rwlock_rdlock(&m_hRwLock);
#endif
}

void
ReleaseLock(bool bExclusive)
{

#ifdef _WIN32
if(bExclusive)
	ReleaseSRWLockExclusive(&m_hRwLock);
else
	ReleaseSRWLockShared(&m_hRwLock);
#else
pthread_rwlock_unlock(&m_hRwLock);
#endif
}




#ifdef _WIN32
unsigned __stdcall LoadReadFilesThread(void * pThreadPars)
#else
void *LoadReadFilesThread(void * pThreadPars)
#endif
{
int *pRslt = (int *)pThreadPars;			// makes it easier not having to deal with casts!
teBSFrsltCodes Rslt;
int Idx;
char *pszInfile;

int NumInputFilesProcessed;

AcquireLock(true);
m_bAllReadsLoaded = false;
m_LoadReadsRslt = eBSFSuccess;
ReleaseLock(true);

// first try to load as pre-processed reads '.rds' (as generated by 'kangar' or 'genreads')
// if unable to load as a '.rds' then try to load as raw fasta/fastq

if(((Rslt = (teBSFrsltCodes)LoadReads(m_ppszPE1InputFiles[0])) < eBSFSuccess) && Rslt != eBSFerrNotBioseq )
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to load reads from %s",m_ppszPE1InputFiles[0]);
	AcquireLock(true);
	*pRslt = Rslt;
	m_bAllReadsLoaded = true;
	ReleaseLock(true);
#ifdef _WIN32
	_endthreadex(0);
	return(*pRslt);
#else
	pthread_exit(NULL);
#endif
	}

if(Rslt != eBSFerrNotBioseq)
	{
	if(Rslt == 0)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"There were no reads in %s",m_ppszPE1InputFiles[0]);
		Rslt = eBSFerrNoEntries;
		}
	else
		Rslt = eBSFSuccess;
	AcquireLock(true);
	*pRslt = Rslt;
	m_bAllReadsLoaded = true;
	ReleaseLock(true);
#ifdef _WIN32
	_endthreadex(0);
	return(*pRslt);
#else
	pthread_exit(NULL);
#endif
	}

if(m_hInFile != -1)
	{
	close(m_hInFile);
	m_hInFile = -1;
	}

AcquireLock(true);
m_bAllReadsLoaded = false;
memset(&m_FileHdr,0,sizeof(tsBSFRdsHdr));
m_FileHdr.Magic[0] = 'b'; m_FileHdr.Magic[1] = 'i'; m_FileHdr.Magic[2] = 'o'; m_FileHdr.Magic[3] = 'r';
m_FileHdr.Version = cBSFRdsVersion;
m_FileHdr.FlagsK = 1;
m_FileHdr.FlagsCS = m_bIsSOLiD;
m_FileHdr.FlagsPR = m_PEproc == ePEdefault ? 0 : 1;
m_FileHdr.PMode = (UINT8)0;
m_FileHdr.QMode = m_QMethod;
m_FileHdr.Trim5 = m_Trim5;
m_FileHdr.Trim3 = m_Trim3;
m_pReadHits = NULL;
m_AllocdReadHitsMem = 0;
m_NumReadsLoaded = 0;
ReleaseLock(true);

if(m_FileHdr.FlagsPR && (m_NumPE1InputFiles < 1 || (m_NumPE1InputFiles != m_NumPE2InputFiles)))
	{
	Rslt = eBSFerrParams;
	AcquireLock(true);
	*pRslt = Rslt;
	m_bAllReadsLoaded = true;
	ReleaseLock(true);
#ifdef _WIN32
	_endthreadex(0);
	return(eBSFerrParams);
#else
	pthread_exit(NULL);
#endif
	}

NumInputFilesProcessed = 0;
if(!m_FileHdr.FlagsPR)
	{
	CSimpleGlob glob(SG_GLOB_FULLSORT);
	for(Idx = 0; Idx < m_NumPE1InputFiles; Idx++)
		{
		glob.Init();
		if(glob.Add(m_ppszPE1InputFiles[Idx]) < SG_SUCCESS)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to glob '%s",m_ppszPE1InputFiles[Idx]);
			Rslt = eBSFerrOpnFile;
			AcquireLock(true);
			*pRslt = Rslt;
			m_bAllReadsLoaded = true;
			m_LoadReadsRslt = Rslt;
			ReleaseLock(true);

#ifdef _WIN32
			_endthreadex(0);
			return(eBSFerrOpnFile);	// treat as though unable to open file
#else
			pthread_exit(NULL);
#endif

			}

		if(glob.FileCount() <= 0)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to locate any source raw reads file matching '%s",m_ppszPE1InputFiles[Idx]);
			continue;
			}

		Rslt = eBSFSuccess;
		for (int FileID = 0; Rslt >= eBSFSuccess &&  FileID < glob.FileCount(); ++FileID)
			{
			pszInfile = glob.File(FileID);

			gDiagnostics.DiagOut(eDLInfo,gszProcName,"Loading and parsing reads from raw sequence file '%s'\n",pszInfile);
			Rslt = LoadRawReads(false,NumInputFilesProcessed+1,pszInfile,NULL);
			if(Rslt != eBSFSuccess)
				{
				if(m_TermBackgoundThreads == 0)
					gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: Load failed for input raw sequence file '%s'\n",pszInfile);
				AcquireLock(true);
				*pRslt = Rslt;
				m_bAllReadsLoaded = true;
				m_LoadReadsRslt = Rslt;
				ReleaseLock(true);
#ifdef _WIN32
				_endthreadex(0);
					return(Rslt);
#else
				pthread_exit(NULL);
#endif
				}
			NumInputFilesProcessed += 1;
			}
		}
	}
else
	{
	Rslt = eBSFSuccess;
	NumInputFilesProcessed = 0;
	for(int FileID = 0; Rslt >= eBSFSuccess &&  FileID < m_NumPE1InputFiles; ++FileID)
		{
		gDiagnostics.DiagOut(eDLInfo,gszProcName,"Loading and parsing reads from 5' PE1 raw sequence file '%s'",m_ppszPE1InputFiles[FileID]);
		gDiagnostics.DiagOut(eDLInfo,gszProcName,"Loading and parsing reads from 3' PE2 raw sequence file '%s'",m_ppszPE2InputFiles[FileID]);

		Rslt = LoadRawReads(true,NumInputFilesProcessed+1,m_ppszPE1InputFiles[FileID],m_ppszPE2InputFiles[FileID]);
		if(Rslt != eBSFSuccess)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Process: Load failed for input raw sequence PE files '%s' and '%s'\n",m_ppszPE1InputFiles[FileID],m_ppszPE2InputFiles[FileID]);
			AcquireLock(true);
			*pRslt = Rslt;
			m_bAllReadsLoaded = true;
			m_LoadReadsRslt = Rslt;
			ReleaseLock(true);
#ifdef _WIN32
			_endthreadex(0);
			return(Rslt);
#else
			pthread_exit(NULL);
#endif
			}
		NumInputFilesProcessed += 2;
		}
	}
gDiagnostics.DiagOut(eDLInfo,gszProcName,"%d raw sequence files were parsed and reads loaded for aligning", NumInputFilesProcessed);
if(NumInputFilesProcessed == 0)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Nothing to do, no raw sequence files to be filtered");
	AcquireLock(true);
	*pRslt = Rslt;
	m_bAllReadsLoaded = true;
	m_LoadReadsRslt = eBSFerrNoEntries;
	ReleaseLock(true);
#ifdef _WIN32
	_endthreadex(0);
	return(eBSFSuccess);
#else
	pthread_exit(NULL);
#endif
	}

// can now update header with final numbers
AcquireLock(true);
m_FileHdr.NumRds = m_NumDescrReads;
m_FileHdr.OrigNumReads = m_NumDescrReads;
m_FileHdr.TotReadsLen = m_DataBuffOfs;

m_FinalReadID = m_NumDescrReads;
m_NumReadsLoaded = m_NumDescrReads;
m_LoadReadsRslt = m_NumReadsLoaded > 0 ? eBSFSuccess : eBSFerrNoEntries;
m_bAllReadsLoaded = true;
*pRslt = eBSFSuccess;
ReleaseLock(true);
#ifdef _WIN32
_endthreadex(0);
return(eBSFSuccess);
#else
pthread_exit(NULL);
#endif
}

int
AddEntry(bool bIsPairRead,		// true if this is the paired read PE2
		 UINT32 PairReadID,		// identifies partner of this read if paired read processing
		 UINT8 FileID,			// identifies file from which this read was parsed
		 char *pszReadDescr,	// copy of descriptor, used to pair reads with matching descriptors
		 int ReadLen,			// length of following read
		 UINT8 *pszReadBuff)	// packed read + phred score
{
UINT8 *pTmpAlloc;
tsReadHit *pReadHit;
size_t memreq;
size_t DescrLen;

DescrLen = strlen(pszReadDescr);

if(m_pReadHits == NULL)
	{
	memreq = cDataBuffAlloc;
	AcquireSerialise();
	AcquireLock(true);
#ifdef _WIN32
	m_pReadHits = (tsReadHit *) malloc((size_t)memreq);
	if(m_pReadHits == NULL)
		{
		ReleaseLock(true);
		ReleaseSerialise();
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"AddEntry: Memory allocation of %lld bytes failed",(INT64)memreq);
		return(eBSFerrMem);
		}
#else
	// gnu malloc is still in the 32bit world and can't handle more than 2GB allocations
	m_pReadHits = (tsReadHit *)mmap(NULL,(size_t)memreq, PROT_READ |  PROT_WRITE,MAP_PRIVATE | MAP_ANONYMOUS, -1,0);
	if(m_pReadHits == MAP_FAILED)
		{
		m_pReadHits = NULL;
		ReleaseLock(true);
		ReleaseSerialise();
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"AddEntry: Memory allocation of %lld bytes through mmap()  failed",(INT64)memreq,strerror(errno));
		return(eBSFerrMem);
		}
#endif
	m_AllocdReadHitsMem = memreq;
	m_DataBuffOfs = 0;
	ReleaseLock(true);
	ReleaseSerialise();
	}

// need to allocate more memory? NOTE: allowing small safety margin of 1K bytes
if((m_AllocdReadHitsMem - m_DataBuffOfs) < (sizeof(tsReadHit) +  ReadLen + DescrLen + 1000))
	{
	memreq = m_AllocdReadHitsMem + cDataBuffAlloc;
	AcquireSerialise();
	AcquireLock(true);
#ifdef _WIN32
	pTmpAlloc = (UINT8 *) realloc(m_pReadHits,memreq);
	if(pTmpAlloc == NULL)
		{
#else
	pTmpAlloc = (UINT8 *)mremap(m_pReadHits,m_AllocdReadHitsMem,memreq,MREMAP_MAYMOVE);
	if(pTmpAlloc == MAP_FAILED)
		{
		pTmpAlloc = NULL;
#endif

		gDiagnostics.DiagOut(eDLFatal,gszProcName,"AddEntry: Memory reallocation to %lld bytes failed - %s",memreq,strerror(errno));
		ReleaseLock(true);
		ReleaseSerialise();
		return(eBSFerrMem);
		}
	m_pReadHits = (tsReadHit *)pTmpAlloc;
	m_AllocdReadHitsMem = memreq;
	ReleaseLock(true);
	ReleaseSerialise();
	}

pReadHit = (tsReadHit *)((UINT8 *)m_pReadHits + m_DataBuffOfs);
m_DataBuffOfs += sizeof(tsReadHit) + ReadLen + DescrLen;
memset(pReadHit,0,sizeof(tsReadHit));
pReadHit->ReadID = ++m_NumDescrReads;
pReadHit->PairReadID = PairReadID;
if(bIsPairRead)
	pReadHit->PairReadID |= 0x80000000;
pReadHit->NumReads = 1;
pReadHit->HitLoci.Hit.Seg[0].Strand = '?';
pReadHit->ReadLen = ReadLen;
pReadHit->DescrLen = (UINT8)DescrLen;
if(DescrLen > 0)
	strcpy((char *)&pReadHit->Read[0],pszReadDescr);
else
	pReadHit->Read[0] = '\0';
memcpy(&pReadHit->Read[DescrLen+1],pszReadBuff,ReadLen);

// processing threads are only updated with actual number of loaded reads every 250000 reads so as
// to minimise disruption to the actual aligner threads which will also be serialised through m_hMtxIterReads
if(m_NumDescrReads > 0 && !(m_NumDescrReads % 1000000))
	{
	AcquireSerialise();
	m_FinalReadID = m_NumDescrReads;
	m_NumReadsLoaded = m_NumDescrReads;
	ReleaseSerialise();
	}
return(eBSFSuccess);
}

teBSFrsltCodes
LoadRawReads(bool bIsPairReads,				// true if paired end processing - PE1 reads in pszPE1File and PE2 reads in pszPE2File
		  int FileID,						// uniquely identifies source file for PE1, FileID + 1 uniquely identifies PE2 file
		  char *pszPE1File,					// process PE1 reads from this file
		  char *pszPE2File)					// optionally process PE2 reads from this file
{
static int FileNamesOfs = 0;
teBSFrsltCodes Rslt;
int Idx;
bool bIsFastq;

UINT8 *pReadBuff;
UINT8 *pQualBuff;
UINT8 Qphred;

bool bPE1SimReads;
int PE1NumDescrReads;
int PE1DescrLen;
UINT8 szPE1DescrBuff[cMaxDescrLen];
int PE1ReadLen;
UINT8 szPE1ReadBuff[cMaxReadLen];
int PE1QualLen;
UINT8 szPE1QualBuff[cMaxReadLen];
int PE1NumReadsAccepted;
int PE1NumInvalValues;
int PE1NumUnsupportedBases;
int PE1NumUnderlength;

bool bPE2SimReads;
int PE2NumDescrReads;
int PE2DescrLen;
UINT8 szPE2DescrBuff[cMaxDescrLen];
int PE2ReadLen;
UINT8 szPE2ReadBuff[cMaxReadLen];
int PE2QualLen;
UINT8 szPE2QualBuff[cMaxReadLen];
int PE2NumReadsAccepted;
int PE2NumInvalValues;
int PE2NumUnsupportedBases;
int PE2NumUnderlength;

CFasta PE1Fasta;
CFasta PE2Fasta;

INT32 EstSeqLen;
INT32 EstDescrLen;
UINT32 EstNumSeqs;
INT64 ReqAllocSize;

// try and guestimate memory requirements so these can be allocated upfront - will be realloc'd if guestimate is wrong
if((EstNumSeqs = PE1Fasta.FastaEstSizes(pszPE1File,NULL,NULL,&EstDescrLen,NULL,&EstSeqLen)) == 0)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to estimate memory requirements for file '%s'",pszPE1File);
	return(eBSFerrOpnFile);
	}
ReqAllocSize = (INT64)((UINT64)EstNumSeqs+10) * (INT64)(sizeof(tsReadHit) + EstSeqLen + max(20,(EstDescrLen/2)));	// assumes that generally descriptors will be trimmed to 1st whitespace

if(bIsPairReads)
	ReqAllocSize *= 2;

UINT32 PairReadID = m_NumDescrReads + 1;				// if bIsPairReads then start paired reads identifiers from this value and increment after each read processed
if((Rslt=(teBSFrsltCodes)PE1Fasta.Open(pszPE1File,true))!=eBSFSuccess)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Load: Unable to open '%s' [%s] %s",pszPE1File,PE1Fasta.ErrText((teBSFrsltCodes)Rslt),PE1Fasta.GetErrMsg());
	return(Rslt);
	}
if(!m_FileHdr.NumFiles)
	FileNamesOfs = 0;

m_FileHdr.NumFiles += 1;
if((FileNamesOfs + strlen(pszPE1File) + 1) < sizeof(m_FileHdr.FileNames))
	{
	strcpy((char *)&m_FileHdr.FileNames[FileNamesOfs],pszPE1File);
	FileNamesOfs += (int)strlen(pszPE1File) + 1;
	}

if(m_bIsSOLiD != PE1Fasta.IsSOLiD())
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Load: Aligning for %s but reads file '%s' is in %s",m_bIsSOLiD ? "Colorspace" : "Basespace",pszPE1File,m_bIsSOLiD ? "Basespace" : "Colorspace");
	PE1Fasta.Close();
	return(eBSFerrCvrtType);
	}

bIsFastq = PE1Fasta.IsFastq();

if(bIsPairReads)	
	{
	if((Rslt=(teBSFrsltCodes)PE2Fasta.Open(pszPE2File,true))!=eBSFSuccess)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Load: Unable to open '%s' [%s] %s",pszPE2File,PE2Fasta.ErrText((teBSFrsltCodes)Rslt),PE2Fasta.GetErrMsg());
		PE1Fasta.Close();
		return(Rslt);
		}

	m_FileHdr.NumFiles += 1;
	if((FileNamesOfs + strlen(pszPE2File) + 1) < sizeof(m_FileHdr.FileNames))
		{
		strcpy((char *)&m_FileHdr.FileNames[FileNamesOfs],pszPE2File);
		FileNamesOfs += (int)strlen(pszPE2File) + 1;
		}

	if(m_bIsSOLiD != PE2Fasta.IsSOLiD())
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Load: Aligning for %s but reads file '%s' is in %s",m_bIsSOLiD ? "Colorspace" : "Basespace",pszPE2File,m_bIsSOLiD ? "Basespace" : "Colorspace");
		PE1Fasta.Close();
		PE2Fasta.Close();
		return(eBSFerrCvrtType);
		}

	if(bIsFastq != PE2Fasta.IsFastq())
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Load: Paired end files not of same type");
		PE1Fasta.Close();
		PE2Fasta.Close();
		return(eBSFerrCvrtType);
		}
	}

AcquireSerialise();
AcquireLock(true);
if(m_pReadHits == NULL)
	{
	m_AllocdReadHitsMem = (size_t)ReqAllocSize;
#ifdef _WIN32
	m_pReadHits = (tsReadHit *) malloc((size_t)m_AllocdReadHitsMem);
	if(m_pReadHits == NULL)
		{
		ReleaseLock(true);
		ReleaseSerialise();
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadReads: Concatenated sequences memory allocation of %lld bytes - %s",(INT64)m_AllocdReadHitsMem,strerror(errno));
		PE1Fasta.Close();
		m_AllocdReadHitsMem = 0;
		return(eBSFerrMem);
		}
#else
	// gnu malloc is still in the 32bit world and can't handle more than 2GB allocations
	m_pReadHits = (tsReadHit *)mmap(NULL,m_AllocdReadHitsMem, PROT_READ |  PROT_WRITE,MAP_PRIVATE | MAP_ANONYMOUS, -1,0);
	if(m_pReadHits == MAP_FAILED)
		{
		ReleaseLock(true);
	    ReleaseSerialise();
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadReads: Concatenated sequences memory of %lld bytes through mmap()  failed - %s",(INT64)m_AllocdReadHitsMem,strerror(errno));
		PE1Fasta.Close();
		m_pReadHits = NULL;
		return(eBSFerrMem);
		}
#endif
	m_DataBuffOfs = 0;

	}
else
	{
	UINT8 *pDstSeq;
	size_t memreq;
	if((m_DataBuffOfs + ReqAllocSize + 1000) >= m_AllocdReadHitsMem)		// 1000 as a small safety margin!
		{
		memreq = (size_t)(m_AllocdReadHitsMem + ReqAllocSize);
#ifdef _WIN32
		pDstSeq = (UINT8 *) realloc(m_pReadHits,memreq);
#else
		pDstSeq = (UINT8 *)mremap(m_pReadHits,m_AllocdReadHitsMem,memreq,MREMAP_MAYMOVE);
		if(pDstSeq == MAP_FAILED)
			pDstSeq = NULL;
#endif
		if(pDstSeq == NULL)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"AddSeq: Memory re-allocation to %lld bytes - %s",memreq,strerror(errno));
			PE1Fasta.Close();
			return(eBSFerrMem);
			}
		m_AllocdReadHitsMem = memreq;
		m_pReadHits = (tsReadHit *)pDstSeq;
		}
	}
ReleaseLock(true);
ReleaseSerialise();

PE1NumUnsupportedBases = 0;
PE1NumDescrReads = 0;
PE1NumReadsAccepted = 0;
PE1NumInvalValues = 0;
PE1NumUnderlength = 0;
PE2NumUnsupportedBases = 0;
PE2NumDescrReads = 0;
PE2NumReadsAccepted = 0;
PE2NumInvalValues = 0;
PE2NumUnderlength = 0;
bPE1SimReads = false;
bPE2SimReads = false;
while((Rslt = (teBSFrsltCodes)(PE1ReadLen = PE1Fasta.ReadSequence(szPE1ReadBuff,sizeof(szPE1ReadBuff)-1,true,false))) > eBSFSuccess)
	{
	if(m_TermBackgoundThreads != 0)	// need to immediately self-terminate?
		break;
	PE1NumDescrReads += 1;
	if(PE1ReadLen == eBSFFastaDescr)		// just read a descriptor line which would be as expected for multifasta or fastq
		{
		PE1DescrLen = PE1Fasta.ReadDescriptor((char *)szPE1DescrBuff,sizeof(szPE1DescrBuff)-1);
		szPE1DescrBuff[cMaxDescrLen-1] = '\0';
		PE1ReadLen = PE1Fasta.ReadSequence(szPE1ReadBuff,sizeof(szPE1ReadBuff)-1);
		if(PE1ReadLen < 0)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Problem parsing sequence after %d reads parsed",PE1NumDescrReads);
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Last descriptor parsed: %s",szPE1DescrBuff);
			PE1Fasta.Close();
			if(bIsPairReads)
				PE2Fasta.Close();
			return(eBSFerrParse);
			}

			// check if these reads have been simulated, in which case the descriptor contains the loci of where the read was simulated from
		if(PE1NumDescrReads == 1)
			{
			if(!strncmp((char *)szPE1DescrBuff,"lcl|usimreads|",14) || !strncmp((char *)szPE1DescrBuff,"lcr|usimreads|",14))
				bPE1SimReads = true;
			else
				bPE1SimReads = false;
			}

		// if paired end processing then load PE2 read
		if(bIsPairReads)
			{
			if((Rslt = (teBSFrsltCodes)(PE2ReadLen = PE2Fasta.ReadSequence(szPE2ReadBuff,sizeof(szPE2ReadBuff)-1,true,false))) <= eBSFSuccess)
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Problem parsing sequence after %d reads parsed",PE2NumDescrReads);
				if(PE2NumDescrReads)
					gDiagnostics.DiagOut(eDLFatal,gszProcName,"Last descriptor parsed: %s",szPE2DescrBuff);
				PE1Fasta.Close();
				PE2Fasta.Close();
				return(eBSFerrParse);
				}

			if(m_TermBackgoundThreads != 0)	// need to immediately self-terminate?
				break;

			PE2NumDescrReads += 1;
			if(PE2ReadLen == eBSFFastaDescr)		// just read a descriptor line which would be as expected for multifasta or fastq
				{
				PE2DescrLen = PE2Fasta.ReadDescriptor((char *)szPE2DescrBuff,sizeof(szPE2DescrBuff)-1);
				szPE2DescrBuff[cMaxDescrLen-1] = '\0';
				PE2ReadLen = PE2Fasta.ReadSequence(szPE2ReadBuff,sizeof(szPE2ReadBuff)-1);
				if(PE2ReadLen < 0)
					{
					gDiagnostics.DiagOut(eDLFatal,gszProcName,"Problem parsing sequence after %d reads parsed",PE2NumDescrReads);
					gDiagnostics.DiagOut(eDLFatal,gszProcName,"Last descriptor parsed: %s",szPE2DescrBuff);
					PE1Fasta.Close();
					PE2Fasta.Close();
					return(eBSFerrParse);
					}
				}
			else
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"raw sequence file '%s' processing error: %s ",pszPE2File,
													Rslt > 0 ? "over length read" : "not a multifasta short reads or fastq file");
				PE1Fasta.Close();
				if(bIsPairReads)
					PE2Fasta.Close();
				return(eBSFerrParse);
				}

					// check if these reads have been simulated, in which case the descriptor contains the loci of where the read was simulated from
			if(PE2NumDescrReads == 1)
				{
				if(!strncmp((char *)szPE2DescrBuff,"lcl|usimreads|",14) || !strncmp((char *)szPE2DescrBuff,"lcr|usimreads|",14))
					bPE2SimReads = true;
				else
					bPE2SimReads = false;
				}
			}

		// ensure would still have a sequence of at least cMinSeqLen after any end trims were applied
		if((m_Trim5 + m_Trim3 + (int)cMinSeqLen) > PE1ReadLen)
			{
			PE1NumUnderlength += 1;
			if(PE1NumUnderlength <= 10)
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Load: under length (%d) sequence in '%s' after end trims has been sloughed..",PE1ReadLen,pszPE1File);
			continue;
			}

		if(bIsPairReads)
			{
			if((m_Trim5 + m_Trim3 + (int)cMinSeqLen) > PE2ReadLen)
				{
				PE2NumUnderlength += 1;
				if(PE2NumUnderlength <= 10)
					gDiagnostics.DiagOut(eDLFatal,gszProcName,"Load: under length (%d) sequence in '%s' after end trims has been sloughed..",PE2ReadLen,pszPE2File);
				continue;
				}
			}

		if(bIsFastq && m_QMethod != eFQIgnore)
			{
			PE1QualLen = PE1Fasta.ReadQValues((char *)szPE1QualBuff,sizeof(szPE1QualBuff)-1);
			if(PE1QualLen != PE1ReadLen)		// must be same...
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Load: quality length (%d) not same as read length (%d) for '%s' entry in file '%s'",PE1QualLen,PE1ReadLen,szPE1DescrBuff,pszPE1File);
				PE1Fasta.Close();
				if(bIsPairReads)
					PE2Fasta.Close();
				return(eBSFerrParse);
				}
			// normalise the quality score to be in range 0..15 (needs to fit into 4 bits!)
			pQualBuff = szPE1QualBuff;
			for(Idx = 0; Idx < PE1ReadLen; Idx++,pQualBuff++)
				{
				switch(m_QMethod) {
					case eFQIgnore:		// simply treat as the minimum phred
						Qphred = 0;
						break;

					case eFQSanger:		// Qphred = -10 log10(P), where Qphred is in range 0..93
						if(*pQualBuff < 33 || *pQualBuff >= 126)
							{
							if(!PE1NumInvalValues++)
								gDiagnostics.DiagOut(eDLWarn,gszProcName,"Load: quality value of '%c' outside range expected in read '%s' from file '%s' for Sanger",*(char *)pQualBuff,szPE1DescrBuff,pszPE1File);
							if(*pQualBuff < 33)
								*pQualBuff = 33;
							else
								*pQualBuff = 125;
							}
						Qphred = *pQualBuff - 33;	// Sanger encodes into ascii starting from decimal 33 '!'
						if(Qphred > 40)				// clamp at phred equiv to 0.0001
							Qphred = 40;
						break;

					case eFQIllumia:	//Qphred = -10 log10(P), where Qphred is in range 0..63
						if(*pQualBuff < 64 || *pQualBuff >= 126)
							{
							if(!PE1NumInvalValues++)
								gDiagnostics.DiagOut(eDLWarn,gszProcName,"Load: quality value of '%c' outside range expected in read '%s' from file '%s' for Illumina 1.3+",*(char *)pQualBuff,szPE1DescrBuff,pszPE1File);
							if(*pQualBuff < 64)
								*pQualBuff = 64;
							else
								*pQualBuff = 125;
							}

						Qphred = *pQualBuff - 64;	//Illumia encodes into ascii starting from decimal 64
						if(Qphred > 40)				// clamp at phred equiv to 0.0001
							Qphred = 40;
						break;

					case eFQSolexa:		// SolexaQ = -10 log10(P/(1-P)), where SolexaQ is in range -5 to 62, note the negative value
										// negative values will result if P > 0.5
										// $Q = 10 * log(1 + 10 ** (ord(SolexaQphred) - 64) / 10.0)) / log(10);
										// once Qphred is over about 15 then essentially same as Sanger and Illumina 1.3+ so
										// is it worth doing the full conversion????
						if(*pQualBuff < 59 || *pQualBuff >= 126)
							{
							if(!PE1NumInvalValues++)
								gDiagnostics.DiagOut(eDLWarn,gszProcName,"Load: quality value of '%c' outside range expected in read '%s' from file '%s' for Solexa/Illumina pre 1.3",*(char *)pQualBuff,szPE1DescrBuff,pszPE1File);
							if(*pQualBuff < 64)
								*pQualBuff = 64;
							else
								*pQualBuff = 125;
							}
						Qphred = *pQualBuff - 59;	// Solexa/Illumina encodes into ascii starting from decimal 59
						Qphred = (UINT8)(10 * log(1 + pow(10.0,((double)Qphred/10.0) / log(10.0))));	//
						if(Qphred > 40)				// clamp at phred equiv to 0.0001
							Qphred = 40;
						break;
					}
				*pQualBuff = (UINT8)((((UINT32)Qphred+2)*15)/40);
				}
			if(bIsPairReads)
				{
				PE2QualLen = PE2Fasta.ReadQValues((char *)szPE2QualBuff,sizeof(szPE2QualBuff)-1);
				if(PE2QualLen != PE2ReadLen)		// must be same...
					{
					gDiagnostics.DiagOut(eDLFatal,gszProcName,"Load: quality length (%d) not same as read length (%d) for '%s' entry in file '%s'",PE2QualLen,PE2ReadLen,szPE2DescrBuff,pszPE2File);
					PE1Fasta.Close();
					PE2Fasta.Close();
					return(eBSFerrParse);
					}
				// normalise the quality score to be in range 0..15 (needs to fit into 4 bits!)
				pQualBuff = szPE2QualBuff;
				for(Idx = 0; Idx < PE2ReadLen; Idx++,pQualBuff++)
					{
					switch(m_QMethod) {
						case eFQIgnore:		// simply treat as the minimum phred
							Qphred = 0;
							break;

						case eFQSanger:		// Qphred = -10 log10(P), where Qphred is in range 0..93
							if(*pQualBuff < 33 || *pQualBuff >= 126)
								{
								if(!PE2NumInvalValues++)
									gDiagnostics.DiagOut(eDLWarn,gszProcName,"Load: quality value of '%c' outside range expected in read '%s' from file '%s' for Sanger",*(char *)pQualBuff,szPE2DescrBuff,pszPE2File);
								if(*pQualBuff < 33)
									*pQualBuff = 33;
								else
									*pQualBuff = 125;
								}
							Qphred = *pQualBuff - 33;	// Sanger encodes into ascii starting from decimal 33 '!'
							if(Qphred > 40)				// clamp at phred equiv to 0.0001
								Qphred = 40;
							break;

						case eFQIllumia:	//Qphred = -10 log10(P), where Qphred is in range 0..63
							if(*pQualBuff < 64 || *pQualBuff >= 126)
								{
								if(!PE2NumInvalValues++)
									gDiagnostics.DiagOut(eDLWarn,gszProcName,"Load: quality value of '%c' outside range expected in read '%s' from file '%s' for Illumina 1.3+",*(char *)pQualBuff,szPE2DescrBuff,pszPE2File);
								if(*pQualBuff < 64)
									*pQualBuff = 64;
								else
									*pQualBuff = 125;
								}

							Qphred = *pQualBuff - 64;	//Illumia encodes into ascii starting from decimal 64
							if(Qphred > 40)				// clamp at phred equiv to 0.0001
								Qphred = 40;
							break;

						case eFQSolexa:		// SolexaQ = -10 log10(P/(1-P)), where SolexaQ is in range -5 to 62, note the negative value
											// negative values will result if P > 0.5
											// $Q = 10 * log(1 + 10 ** (ord(SolexaQphred) - 64) / 10.0)) / log(10);
											// once Qphred is over about 15 then essentially same as Sanger and Illumina 1.3+ so
											// is it worth doing the full conversion????
							if(*pQualBuff < 59 || *pQualBuff >= 126)
								{
								if(!PE2NumInvalValues++)
									gDiagnostics.DiagOut(eDLWarn,gszProcName,"Load: quality value of '%c' outside range expected in read '%s' from file '%s' for Solexa/Illumina pre 1.3",*(char *)pQualBuff,szPE2DescrBuff,pszPE2File);
								if(*pQualBuff < 64)
									*pQualBuff = 64;
								else
									*pQualBuff = 125;
								}
							Qphred = *pQualBuff - 59;	// Solexa/Illumina encodes into ascii starting from decimal 59
							Qphred = (UINT8)(10 * log(1 + pow(10.0,((double)Qphred/10.0) / log(10.0))));	//
							if(Qphred > 40)				// clamp at phred equiv to 0.0001
								Qphred = 40;
							break;
						}
					*pQualBuff = (UINT8)((((UINT32)Qphred+2)*15)/40);
					}
				}
			}

		if(bIsFastq && m_QMethod != eFQIgnore)
			{
			// pack the read and quality, read into the low order bits 0..3, quality into bits 4..7
			pQualBuff = szPE1QualBuff;
			pReadBuff = szPE1ReadBuff;
			for(Idx = 0; Idx < PE1ReadLen; Idx++,pQualBuff++,pReadBuff++)
				szPE1ReadBuff[Idx] |= *pQualBuff << 4;
			}

		// apply any end trims
		if(m_Trim5)
			{
			PE1ReadLen -= m_Trim5;
			memcpy(szPE1ReadBuff,&szPE1ReadBuff[m_Trim5],PE1ReadLen);
			}
		if(m_Trim3)
			PE1ReadLen -= m_Trim3;

		// truncate descriptors at 1st whitespace unless fasta was generated by simulating reads in which case
		// the whole descriptor is retained as where the read was simulated from is of interest
		if(!bPE1SimReads)	// if not simulated reads
			{
			for(Idx = 0; Idx < cMaxDescrIDLen-1; Idx++)
				{
				if(isspace(szPE1DescrBuff[Idx]))
					break;
				}
			szPE1DescrBuff[Idx] = '\0';
			}

		if(bIsPairReads)
			{
			if(bIsFastq && m_QMethod != eFQIgnore)
				{
						// pack the read and quality, read into the low order bits 0..3, quality into bits 4..7
				pQualBuff = szPE2QualBuff;
				pReadBuff = szPE2ReadBuff;
				for(Idx = 0; Idx < PE2ReadLen; Idx++,pQualBuff++,pReadBuff++)
					szPE2ReadBuff[Idx] |= *pQualBuff << 4;
				}

					// apply any end trims
			if(m_Trim5)
				{
				PE2ReadLen -= m_Trim5;
				memcpy(szPE2ReadBuff,&szPE2ReadBuff[m_Trim5],PE2ReadLen);
				}
			if(m_Trim3)
				PE2ReadLen -= m_Trim3;

			// truncate descriptors at 1st whitespace unless fasta was generated by simulating reads in which case
			// the whole descriptor is retained as where the read was simulated from is of interest
			if(!bPE2SimReads)	// if not simulated reads
				{
				for(Idx = 0; Idx < cMaxDescrIDLen-1; Idx++)
					{
					if(isspace(szPE2DescrBuff[Idx]))
						break;
					}
				szPE2DescrBuff[Idx] = '\0';
				}
			}

		if(m_TermBackgoundThreads != 0)	// need to immediately self-terminate?
			break;

		if(!bIsPairReads)
			{
			if((Rslt=(teBSFrsltCodes)AddEntry(false,0,FileID,(char *)szPE1DescrBuff,PE1ReadLen,szPE1ReadBuff))!=eBSFSuccess)
				break;
			PE1NumReadsAccepted += 1;
			}
		else
			{
			if((Rslt=(teBSFrsltCodes)AddEntry(false,PairReadID+1,FileID,(char *)szPE1DescrBuff,PE1ReadLen,szPE1ReadBuff))!=eBSFSuccess)
				break;
			PE1NumReadsAccepted += 1;
			PairReadID += 1;
			if((Rslt=(teBSFrsltCodes)AddEntry(true,PairReadID-1,FileID+1,(char *)szPE2DescrBuff,PE2ReadLen,szPE2ReadBuff))!=eBSFSuccess)
				break;
			PE2NumReadsAccepted += 1;
			PairReadID += 1;
			}
		continue;
		}
	else
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"raw sequence file '%s' processing error: %s ",pszPE1File,
											Rslt > 0 ? "over length read" : "not a multifasta short reads or fastq file");
		PE1Fasta.Close();
		if(bIsPairReads)
			PE2Fasta.Close();
		return(eBSFerrParse);
		}
	}
if(Rslt != eBSFSuccess)
	{
	if(m_TermBackgoundThreads == 0)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Errors processing file: %s ",pszPE1File);
		while(PE1Fasta.NumErrMsgs())
			gDiagnostics.DiagOut(eDLFatal,gszProcName,PE1Fasta.GetErrMsg());
		}
	PE1Fasta.Close();
	if(bIsPairReads)
		PE2Fasta.Close();
	return(Rslt);
	}
PE1Fasta.Close();
if(bIsPairReads)
	PE2Fasta.Close();

if(m_TermBackgoundThreads != 0)	// need to immediately self-terminate?
	return(eBSErrSession);

AcquireSerialise();
m_FinalReadID = m_NumDescrReads;
m_NumReadsLoaded = m_NumDescrReads;
ReleaseSerialise();

gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadReads: Total of %1.9d reads parsed and loaded from %s",PE1NumReadsAccepted,pszPE1File);
if(PE1NumInvalValues > 0)
	gDiagnostics.DiagOut(eDLWarn,gszProcName,"Load: total of %d unexpected quality values read from file '%s'",PE1NumInvalValues,pszPE1File);
if(PE1NumUnsupportedBases > 0)
	gDiagnostics.DiagOut(eDLWarn,gszProcName,"Load: total of %d unsupported bases read from file '%s'",PE1NumUnsupportedBases,pszPE1File);
if(PE1NumUnderlength > 0)
	gDiagnostics.DiagOut(eDLWarn,gszProcName,"Load: total of %d under length sequences sloughed from file '%s'",PE1NumUnderlength,pszPE1File);

if(bIsPairReads)
	{
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadReads: Total of %1.9d reads parsed and loaded from %s",PE2NumReadsAccepted,pszPE2File);
	if(PE2NumInvalValues > 0)
		gDiagnostics.DiagOut(eDLWarn,gszProcName,"Load: total of %d unexpected quality values read from file '%s'",PE2NumInvalValues,pszPE2File);
	if(PE2NumUnsupportedBases > 0)
		gDiagnostics.DiagOut(eDLWarn,gszProcName,"Load: total of %d unsupported bases read from file '%s'",PE2NumUnsupportedBases,pszPE2File);
	if(PE2NumUnderlength > 0)
		gDiagnostics.DiagOut(eDLWarn,gszProcName,"Load: total of %d under length sequences sloughed from file '%s'",PE2NumUnderlength,pszPE2File);
	}
return(eBSFSuccess);
}





