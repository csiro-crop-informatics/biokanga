#pragma once
#include "./commdefs.h"

const int cElInitalAllocNum = 40000000;				// initially alloc to hold this many tsHyperElement instances
const int cElGrowAllocNum =   (cElInitalAllocNum/2);	// grow by this many tsHyperElement instances

const int cChromsInitalAllocNum = 100000;	// initially alloc to hold this many tsHyperChrom instances
const int cChromsGrowAllocNum = (cChromsInitalAllocNum/2);	// grow by this many tsHyperChrom instances

const int cMaxElTypes = 50;		// allow this many element types
const int cMaxSpecies = 200;	// allow this many different rel and ref species


typedef enum TAG_eCSVFormat {
	eCSVFdefault = 0,	// CSV format with <coreid>,<coretype>,<refspecies>,<refchrom>,<start>,<end>,<len>
						// may be extended with either <strand> or <relspecies>,<featurebits>
	eCSVFprobe,			// CSV format as generated by locsfx, probe details are in first 7 fields
						//   <coreid>,<coretype>,<refspecies>,<refchrom>,<start>,<end>,<len>
	eCSVFtarget,		// CSV format as generated by locsfx, target details are in fields 8..13 
						// <eCSVFprobe fields>,<relspecies>,<relchrom>,<start>,<end>,<len>,<strand>
	eCSVFQuickCount,	// <seqid>,<descr>,<COV>,<stddev>,<mean>,<sequence>
	eCSVFhyperX2,		// CSV format as generated Genhyperconserved with x2 parameter
	eCSVFAlignM3,		// GenMAlign with -m3 option
	eCSVFSeq,			// CSV adhoc format in which one of the fields contains a sequence and another contains a fasta descriptor
	eCSVFAlignPSLcsv,	// CSV format when BLAT psl file processed into csv with psl2csv
	eCSVFAlignBLASTcsv	// CSV format when BLAST format 8 or 9 processed into csv with blast2csv 
} teCSVFormat;

#pragma pack(1)

typedef struct TAG_sHyperElement {
	UINT8 ElTypeID;		// element type
	UINT8 RefSpeciesID;	// reference species identifier
	UINT8 RelSpeciesID;	// relative species list identifier or 0 if none
	UINT8 Features;
	INT32 ChromID;
	INT32 ElID;					// unique element identifier: m_pElements[ElID-1] 
	INT32 SrcID;				// identifier as parsed from source CSV file
	INT32 StartLoci;			// start loci normalised to on '+' strand
	INT32 Len;					// length
	UINT8 PlusStrand:1;			// 0 ==  '-', 1 == '+'
								// elements may be split (microInDel or splice junction spanning?) identified as they share the same SrcID
	UINT8 SplitElement:1;// this is a split element member
	UINT8 SplitFirst:1;// first member (lowest start loci)
	UINT8 SplitLast:1; // last member (highest start loci) 
	UINT8 NumSNPBases:3;		// number of alternative SNP bases called - used when generating SNP marker sequences
	UINT8 SNPBases;			// SNP bases if present are packed 4 per byte with 2 bits per base and bits 0..1 containing the first
	 
	UINT32 SplitOrder;	// 0 if 1st split element through to N-1 for the last element, ordered by ascending start loci
	 
    INT32 RelScale;			// relative scaling factor for this read
	size_t SeqBasesOfs;     // offset+1 in m_pSeqBases[] at which associated sequence starts; sequences will always be sense orientated; 0 if no associated sequence
} tsHyperElement;

typedef struct TAG_sHyperChrom {
	INT32  ChromID;			// uniquely identifies chromosome
	UINT16 Hash;				// hash on chromosome name - GenHash()
	UINT32 NxtHashChromIdx;				// index - 1 in m_pChroms of next chrom with same hashed szChromName
	char szChromName[cMaxDatasetSpeciesChrom];	// chromosome name
} tsHyperChrom;

typedef struct TAG_sItemName {
	UINT8  NameID;				// uniquely identifies this name
	UINT16 Hash;				// hash on name - GenHash()
	UINT8 szName[cMaxGeneNameLen];	// name
} tsItemName;

#pragma pack()

class CHyperEls  : public CErrorCodes
{
	int m_EstNumEls;			// an estmation of the number of elements which will need to be allocated
	int m_NumElsAllocd;			// number of elements allocated
	int m_NumEls;				// actual number of elements
	int m_NumElsPlus;			// number on plus strand (default if no strand specified)
	int m_NumElsMinus;			// number on minus strand
	int m_MinLenEl;				// actual minimal length of any element
	int m_MaxLenEl;				// actual maximum length of any element
	size_t m_MemAllocEls;	    // mem allocd for m_pElements
	tsHyperElement *m_pElements;

	int m_NumSeqs;				// total number of sequences in m_pSeqBases
	size_t m_MemUsedSeqBases;	// mem currently used for m_pSeqBases
	size_t m_MemAllocSeqBases;	// mem allocd for m_pSeqBases
	UINT8 *m_pSeqBases;		    // alloc'd to hold any element associated sequence bases which are packed 2 bases per byte

	int m_MRAChromID;			// most recently accessed chromosome identifier
	int m_NumChromsAllocd;
	int m_NumChroms;
	size_t m_MemAllocChroms;	// mem alloc'd for m_pChroms  
	tsHyperChrom *m_pChroms;
	UINT64 *m_pChromHashes;		// used to hold indexes into m_pChroms

	int m_MRAElTypeID;		// most recently accessed element type identifier
	int m_NumElTypes;
	tsItemName m_ElTypes[cMaxElTypes];

	int m_MRARefSpeciesID;		// most recently accessed ref species identifier
	int m_NumRefSpecies;
	tsItemName m_RefSpecies[cMaxSpecies];

	int m_MRARelSpeciesID;		// most recently accessed rel species identifier
	int m_NumRelSpecies;
	tsItemName m_RelSpecies[cMaxSpecies];

	int m_NumElsParsed;			// number of elements parsed before filtering
	int m_NumFiltLen;			// number elements filtered out because of length
	int m_FiltDeduped;			// number of elements filter out because of deduping
	
	static int SortElements( const void *arg1, const void *arg2);
	static int SortElementsStrand( const void *arg1, const void *arg2);
	static int SortSplitElements( const void *arg1, const void *arg2);

	int FiltPutCoresByStrand(int MaxJoinOverlap,bool bPlus = true,bool bDedupe = false);
	int FiltPutCores(int MaxJoinOverlap,bool bDedupe = false); // filter cores for overlap
	char *TrimWhitespace(char *pTxt);	// trim whitespace

public:
	CHyperEls(void);
	~CHyperEls(void);

	void Reset(void);

	int AddChrom(char *pszChrom);	// returns unique chromosome identifier
	int AddElType(char *pszElType);	// returns unique element type identifier
	int AddRefSpecies(char *pszRefSpecies);	// returns unique ref species identifier
	int AddRelSpecies(char *pszRelSpecies);	// returns unique rel species list identifier

	int PreAllocMem(int EstNumEls, int MeanSeqLen); // preallocate memory for this estimate of number elements having this mean sequence length

	int AddElCore(int SrcID,	// identifier as parsed from source CSV file
		  char *pszElType,		// element type
		  char *pszRefSpecies,	// reference species
		  char *pszRelSpecies,	// relative species list
		  char *pszChrom,		// element is on this chromosome
		  int StartLoci,		// element starts at this loci
		  int Len,				// and is of this length
		  int Features, 		// element overlays these features
		  char Strand = '+',	// and is on this strand
		  int RelScale = 0,		// relative scaling factor for this read
		  int NumSNPBases = 0,  // up to a max of 4 variant bases can be specified when SNP calling
		  etSeqBase *pSeq = NULL); // any associated sequence, NULL if none,  sequence is expected to be of length NumVariants (if not 0) otherwise Len
  
		  

	int	ParseCSVFileElements(char *pszFile,int MinLength,int MaxLength,teCSVFormat CSVFormat = eCSVFdefault);		// file (in CSV format) containing element loci
	int	ParseSAMFileElements(char *pszFile,int MinLength,int MaxLength,bool bRetainSeq = false);							// file (in SAM format) containing element loci, if bSeq true then sequence is required
	int	ParseBEDFileElements(char *pszFile,int MinLength,int MaxLength);											// file (in BED format) containing element loci


	int IdentifySplitElements(void);	// identify any elements which share the same SrcID and thus have been split - perhaps microInDels or splice junction spanning
	int DedupeSort(int MaxJoinOverlap = 4, bool bDedupe = false);				// remove any duplicates and sort elements by ChromID->StartLoci->Len
	int NumEls(void);		// returns number of elements on either plus or minus strands
	tsHyperElement *GetElement(int ElID); // returns ptr to element idexed as ElID (1..m_NumEls)
	char *GetChrom(int ChromID);	// gets ptr to chromosome identified by ChromID
	int GetChromID(char *pszChrom); // get chromosome identifier for pszChrom

	int Locate(int ChromID,int StartLoci,int Len, int MinOverlap,int nTh=1,int *pOverlapStartLoci=NULL,int *pOverlapLen=NULL);
	int LocateNumOverlapping(int ChromID,int StartLoci,int Len = 1, int MinOverlap = 1);
	int LocateLociBaseCnts(int ChromID,int StartLoci,UINT32 *pCntA, UINT32 *pCntC,UINT32 *pCntG,UINT32 *pCntT,UINT32 *pCntN); // returns counts of all bases aligning to specified chrom+loci

	
	tsHyperElement *							// Use to iterate through elements on specified chrom, returning ptr to element instance
		LocateChromNthElement(int ChromID,		// iterate elements on this chrom
					int nTh);					// return this element instance (1..N)


	int		// Use to iterate through elements on specified chrom, returning the element loci and length
		LocateChromNthElement(int ChromID,		// iterate elements on this chrom
					int nTh,					// return this element instance (1..N)
					int *pElLoci,				// element is at this loci on the chrom
					int *pElLen);				// and is this length

	char *GetType(unsigned char ElTypeID);			// get element type
	char *GetRelSpecies(unsigned char RelSpeciesID);		// get relative species
	char *GetRefSpecies(unsigned char RefSpeciesID);		// get reference species

	int NumElsFiltLen(void);	// returns number of elements filtered out because of length
	int NumElsParsed(void);		// returns number of elements parsed before filtering
	int NumElsDeduped(void);	// returns number of elements filtered out because of deduping

};

