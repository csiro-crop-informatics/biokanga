#pragma once

#if _WIN32

#include "../libbiokanga/commhdrs.h"
#else
#include "../libbiokanga/commhdrs.h"
#endif

const int cASSMaxNameLen = 25;				// max length of any species or chromosome name
const int cASSAllocSubSeqIncr = 10000000;	// alloc memory for m_pSubSeqs as this many tsASSeq blocks
const int cASSAllocChromNamesIncr = 10000;	// alloc memory for m_pChroms in this sized (tsARchromname) increments
											// NOTE: species may not be fully asembled and contain scaffolds instead of chromosomes - there can be 100K+ scaffolds!
const int cASSAllocSpeciesNamesIncr = 50;	// alloc memory for m_pSpecies in this sized (tsARspeciesname) increments
const int cASSAllocSeqStatsIncr = 1000000;  // alloc memory for m_pSubSeqStats in this sized (tsSSStats) increments

const int cASSSeqLen = 0x03ffff;				// maximum length of any individual aligned sequence incl InDels
const int cASSSMaxBlockSize = cASSSeqLen * 4;	// allocate to hold alignment blocks of this length	

#pragma pack(1)

typedef struct TAG_sASSSpeciesName {
	char SpeciesID;							// uniquely identifies this species
	unsigned short int Hash;				// hash on szName
	char szName[cASSMaxNameLen+1];			// place holder for species name + '\0'
	} tsASSSpeciesName;

typedef struct TAG_sASSChromName {
	int ChromID;							// uniquely identifies this chromosome name
	char SpeciesID;							// chromosome in this species
	int ChromLen;							// chromosome length
	unsigned short int Hash;				// hash on szName
	char szName[cASSMaxNameLen+1];			// place holder for chromosome name + '\0'
	} tsASSChromName;

typedef struct TAG_sSSStats {
	int RefChromOfs;			 // primary alignment reference species offset
	int RelChromOfs;			 // primary alignment relative offset
	unsigned short SpeciesRefChromID;	// primary alignment reference chromosome identifier
	unsigned short SpeciesRelChromID;	 // primary alignment relative chromosome identifier
	unsigned short Matches;  	 // number of identical matches in subsequence primary alignment
	unsigned short SubSeqLen;	 // primary alignment subsequence length
	unsigned short RefMisses;	 // number of reference bases in primary alignment but not present in secondary
	unsigned short RefHits;		 // number of reference bases present in both primary and secondary alignments
	unsigned short RelMisses;	 // number of bases present in both primary and secondary but which differ in relative species chroms.ofs
	unsigned short NumReciprocal;// number of bases which are reciprocal in both primary and secondary
	char RefStrand;				 // primary alignment reference strand
	char RelStrand;				 // primary alignment relative strand
	} tsSSStats;

typedef struct TAG_sASSubSeq {
	int RefChromOfs;			// secondary alignment reference species offset
	int RelChromOfs;			// secondary alignment relative offset
	unsigned short SubSeqLen;	// secondary alignment subsequence length
	unsigned short SpeciesRefChromID;	// secondary alignment reference chromosome identifier
	unsigned short SpeciesRelChromID;	// secondary alignment relative chromosome identifier
	char RefStrand;				// secondary alignment reference strand
	char RelStrand;				// secondary alignment relative strand
} tsASSubSeq;

typedef struct TAG_sASSpeciesSubSeqAlign {
	int SpeciesID;				    // species identifier
	char szSpeciesName[cASSMaxNameLen+1];
	int ChromID;					// chromosome identifier
	char szChromName[cASSMaxNameLen+1];
	int ChromOfs;					// offset on chromosome
	char Strand;					// strand '+' or '-'
	int SeqLen;						// sequence length in this block with no InDels
	int srcSize;						// length of sequence from which this block sequence was derived (chrom length)
	etSeqBase UCSCSeq[cASSSeqLen];		// sequence with InDels as loaded from UCSC alignments
	etSeqBase MuscleSeq[cASSSeqLen];	// sequence with InDels as generated by Muscle
	etSeqBase ClustalwSeq[cASSSeqLen];	// sequence with InDels as generated by clustalw
} tsASSpeciesSubSeqAlign;

// alignment scores as generated by QScore
typedef struct TAG_sASAlignQScores {
	double PREFABQScore;			
	double ModelerScore;
	double ClineScore;
	double TCScore;
} sASAlignQScores;

typedef struct TAG_sASAlignerBlock {
	char szMFA[_MAX_PATH];		// file holding generated multialignment
	int SeqInDelsLen;			// sequence length with InDels (block size)
	} tsASAlignerBlock;

typedef struct TAG_sASSubSeqAligns {
	int BlockID;					// block identifier
	char FileBuffer[(cASSSMaxBlockSize * 4) / 3];	// used to buffer fasta files submitted to external aligners and to buffer their generated alignments
	char MAFseqBuff[cASSSeqLen]; // used to buffer generated MAF lines
	int Region;						// which region is this block completly contained within?
	int MaxNumSpecies;				// maximum number of species 
	int CurNumSpecies;				// current number of species in this subseq alignment
	char szUCSCfa[_MAX_PATH];		// UCSC unaligned multifasta full path
	char szClustalwExe[_MAX_PATH];	// Clustalw full path
	char szMuscleExe[_MAX_PATH];	// Muscle full path
	char szQScoreExe[_MAX_PATH];	// QScore full path
	char szQScoreCSV[_MAX_PATH];	// QScore results full path

	char szUCSCMAFfile[_MAX_PATH];	// name of file to hold UCSC generated alignments
	char szMuscleMAFfile[_MAX_PATH];	// name of file to hold Muscle generated alignments
	char szClustalWMAFfile[_MAX_PATH]; // name of file to hold ClustalW generated alignments
	sASAlignQScores Scores[3];		// 0: Muscle vs UCSC, 1: Clustalw vs UCSC, 2: Muscle vs Clustalw
	tsASAlignerBlock Blocks[3];		// 0: UCSC, 1: Muscle, 2: Clustalw
	tsASSpeciesSubSeqAlign Species[1];	// place holder for all species specific subseqs in alignment
									// aditional species are concatenated on to the end of this structure
	} tsASSubSeqAligns;
#pragma pack()


class CAlignSubSeqs
{
	int m_NumSubSeqs;			// number of alignment subsequence instances in m_pAlignSeqs
	int m_AllocdSubSeqs;		// memory has been allocated to hold this many instances
	tsASSubSeq *m_pSubSeqs;		// pts to array holding instances of tsASSubSeq's

	int m_NumSubSeqStats;			// number of subsequence stats instances in m_pSubSeqStats
	int m_AllocdSubSeqStats;		// memory has been allocated to hold this many instances
	tsSSStats *m_pSubSeqStats;		// pts to array holding instances of tsSSStats's

	int m_NumSpecies;				// number of species
	int m_AllocdSpeciesInsts;		// how many instances have been allocd to m_pSpecies
	tsASSSpeciesName *m_pSpecies;

	int m_NumChroms;				// number of chromosomes
	int m_AllocdChromsInsts;		// how many instances have been allocd to m_pChroms
	tsASSChromName *m_pChroms;

	int m_TotalNumReciprocal;		// total number of bases which are reciprocal in both primary and secondary
	int m_TotalRefHits;				// total number of reference bases present in both primary and secondary alignments
	int m_TotalRefMisses;			// total number of reference bases in primary alignment but not present in secondary
	int m_TotalRelMisses;			// total number of bases present in both primary and secondary but which differ in relative species chroms.ofs

	CBEDfile *m_pBiobed;			// biobed file used to characterise regions
	int m_RegLen;					// regulatory region size
	bool m_bMultipleFeatBits;		// true if overlapping featurebits allowed
	int m_hRsltsFile;				// results file handle

	int m_hUCSCMAF;					// file handle for opened MuscleMAFfile
	int m_hMuscleMAF;				// file handle for opened MuscleMAFfile
	int m_hClustalWMAF;				// file handle for opened ClustalWMAFfile

	int AddSubSeq(int SpeciesRefChromID,	// reference chromosome identifier
		  char RefStrand,		// reference strand
		  int RefChromOfs,		// reference offset
		  int SpeciesRelChromID,// relative chromosome identifier
		  char RelStrand,		// relative strand
		  int RelChromOfs,		// relative offset
		  int SubSeqLen);		// subsequence length


	int								// returns number of bases reciprocally aligned
 		CalcSeqStats(tsSSStats *pStats);			// subsequence alignment stats

	int					// returned m_NumSubSeqStats
		AddSeqStats(tsSSStats *pSeqStats);

	int AddSpeciesChrom(char *pszSpecies,char *pszChrom,bool bChkDups);
	int GetSpeciesID(char *pszSpecies);
	int GetChromID(char *pszSpecies,char *pszChrom);
	int GetChromID(int SpeciesID,char *pszChrom);

	char *GetChrom(int SpeciesRelChromID);
	char *GetSpecies(int SpeciesRelChromID);
	int CharacteriseRegion(char *pszChrom,int ChromOfs,int ChromOfsEnd);
	char *Region2Text(int RegionIdx);

	unsigned short GenNameHash(char *pszName);
	static int SortAlignRef( const void *arg1, const void *arg2);
	static int SortAlignRel( const void *arg1, const void *arg2);
	static int SortSpeciesChroms( const void *arg1, const void *arg2);

public:
	CAlignSubSeqs(void);
	~CAlignSubSeqs(void);

	int Reset(void);
	int SortSubSeqsByRef(void);

	int InitResults(int Mode,char *pszRsltsFile,char *pszBiobedFile,bool bMultipleFeatBits, int RegLen);
	int EndResults(void);

	int ProcessAlignment(bool bSecondary,	// true if secondary alignment being processed
				  char *pszRefSpecies,			// reference species
				  char *pszRelSpecies,			// relative species
				  char *pszAlignmentFile);		// alignment file

	int ProcessCompareAlignment(char *pszChrom,			// only process this chromosome - "*" for all
							int Region, // blocks must be completely contained within this region
							int MinBlockLen,	  // blocks must of at least this length
							int MaxBlockLen,	  // and no longer than this
							int MinNumSpecies, // blocks must have at least this number of species
							int MaxNumSpecies, // and no more than this
							char *pszTmpFilePrfx,	// intermediate file prefix e.g tmp 
							char *pszTmpFilePath,	// intermediate file path e.g d:\\results\expr1 
							char *pszExePath,	    //where to load external aligners - qscore, clustalw and muscle from 
							char *pszRefSpecies,// reference species
					   		char *pszAlignmentFile); // alignment file


	int ProcessExtern(CMAlignFile *pAlignments,
			tsASSubSeqAligns *pAlignSubSeqs);

	int ExternAlign(bool bMuscle,	// false: clustalw, true: muscle
			CMAlignFile *pAlignments,
			tsASSubSeqAligns *pAlignSubSeqs);

	int ExternScore(tsASSubSeqAligns *pAlignSubSeqs);
	int OpenMAFs(tsASSubSeqAligns *pSubSeqAligns);
	int CloseMAFs(void);
	int GenerateMAFBlocks(CMAlignFile *pAlignments,tsASSubSeqAligns *pSubSeqAligns);
	int OutputExternAlignResults(tsASSubSeqAligns *pAlignSubSeqs,CMAlignFile *pAlignments);
	int OutputResults(void);

};
